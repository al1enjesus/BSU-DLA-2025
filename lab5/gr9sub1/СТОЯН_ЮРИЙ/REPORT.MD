# Отчет по лабораторной работе №5 - Модули ядра Linux

## Цель работы

Изучить архитектуру ядра Linux, научиться разрабатывать, собирать, загружать и отлаживать простые модули ядра, а также освоить механизмы взаимодействия модулей с пространством пользователя.

## Ход работы
**Студент:** Стоян Юрий
**Группа:** 9, подгруппа 1
**Дата:** 7 ноября 2025
**Вариант:** 1 (нечётные номера, 25 по списку)
Данная работа выполнялась в изолированной среде VirtualBox Oracle на Ubuntu 22.04 с целью не допустить возможных осложнений в основной системе.

### Задание A: Hello World модуль

**Описание:** Создан простой модуль `hello_module.c` со следующей функциональностью:

- При загрузке выводит "Hello from Kaiser Yury,first of his name,module!"
- При выгрузке выводит "Goodbye from Kaiser Yury,first of his name module!"
- Поддерживает параметр `message` для пользовательского сообщения

Код находится в файле  /src/hello_module.c
**Результаты тестирования:**
В файле MAKEFILE были прописаны команды для создания файлов модуля ядра.
Теперь перейдем к командам и результатам.

```bash
modinfo hello_module.ko
```
```
filename:       /home/kaiser/BSU-DLA-2025/hello_module.ko
version:        1.0
description:    Simple Hello World kernel module
author:         Kaiser Yury,first of his name
license:        GPL
srcversion:     AF76657038B44E0800C5E49
depends:        
name:           hello_module
retpoline:      Y
vermagic:       6.14.0-35-generic SMP preempt mod_unload modversions 
parm:           message:Custom message parameter (charp)
```

```bash
lsmod | grep hello_module
```
Вывод:
```
hello_module           12288  0
```
Проверяем системный журнал `dmesg` на наличие приветственного сообщения.

```bash
sudo dmesg | tail -3
```

Получим следующее сообщение:

```bash
[ 2430.826326] === ЗАГРУЗКА МОДУЛЯ ===
[ 2430.826333] Hello from Kaiser Yury,first of his namemodule!
[ 2430.826336] Модуль успешно загружен!
```

**Шаг 3: Выгрузка модуля**

Выгружаем модуль с помощью `rmmod`.

```bash
sudo rmmod hello_module
```

Проверяем `dmesg` на наличие прощального сообщения.

```bash
sudo dmesg | tail -1
```

Получим следующее сообщение:

```bash
[ 3954.059215]Goodbye from Kaiser Yury,first of his name,module!
```
**Тест с параметром:**

```
$ sudo insmod hello_module.ko message="Shalom!"
$ dmesg | tail -1
[ 3954.059] hello_module: Shalom!
```
```bash
sudo rmmod hello_module
```

### Задание B: /proc файл с информацией

**Описание:** Создан модуль `proc_module.c` который:

- Создает файл `/proc/student_info`
- Выводит имя, группу, время загрузки модуля (jiffies)
- Ведет счетчик обращений к файлу

**Результаты тестирования:**
```
echo "=== ПЕРВОЕ ЧТЕНИЕ ==="
cat /proc/student_info

echo "=== ВТОРОЕ ЧТЕНИЕ ==="
cat /proc/student_info

echo "=== ТРЕТЬЕ ЧТЕНИЕ ==="
cat /proc/student_info

echo "=== ЧЕТВЁРТОЕ ЧТЕНИЕ ==="
cat /proc/student_info
=== ПЕРВОЕ ЧТЕНИЕ ===
Name: Kaiser Yury
Module loaded at: 4300330623 jiffies
Current jiffies: 4300361558
Uptime: 4300361 seconds
Read count: 1
=== ВТОРОЕ ЧТЕНИЕ ===
Name: Kaiser Yury
Module loaded at: 4300330623 jiffies
Current jiffies: 4300361561
Uptime: 4300361 seconds
Read count: 2
=== ТРЕТЬЕ ЧТЕНИЕ ===
Name: Kaiser Yury
Module loaded at: 4300330623 jiffies
Current jiffies: 4300361566
Uptime: 4300361 seconds
Read count: 3
```
### Задание C: Простой character device

**Описание:** Создан модуль `chardev_module.c` который:

- Создает character device `/dev/mychardev`
- Поддерживает операции открытия/закрытия
- Реализует чтение и запись данных (буфер 1024 байта)
- Логирует операции в dmesg
Изначально было отказано в доступе,но команда 'sudo chmod 666 /dev/mychardev' решила проблему.

**Результаты тестирования:**
```bash
echo "Hello from user space!" > /dev/mychardev
cat /dev/mychardev
Hello from user space!
echo "Test message 1" > /dev/mychardev
cat /dev/mychardev

echo "This is lab5 character device test" > /dev/mychardev
cat /dev/mychardev
Test message 1
This is lab5 character device test
sudo dmesg | tail -15
[  418.375595] Written 15 bytes to device
[  418.375597] Data: Test message 1

[  418.375601] Character device closed
[  418.378800] Character device opened
[  418.378819] Read 15 bytes from device
[  418.378911] Character device closed
[  418.382155] Character device opened
[  418.382202] Written 35 bytes to device
[  418.382205] Data: This is lab5 character device test

[  418.382211] Character device closed
[  418.387260] Character device opened
[  418.387287] Read 35 bytes from device
[  418.387620] Character device closed
```
Видим,что программа полностью выполняет поставленные ей требования.
Все необходимы скриншоты находятся в папке screenshots.

### Базовые понятия:

1.  **Что такое модуль ядра и зачем он нужен?**
    Модуль ядра — это фрагмент кода, который можно динамически загружать и выгружать из ядра Linux без перезагрузки системы. Он нужен для расширения функциональности ядра (например, добавления драйверов, файловых систем) без необходимости перекомпиляции всего ядра, что делает систему более гибкой и экономичной по памяти.

2.  **Чем отличается kernel-space от user-space?**
    **User-space** — это непривилегированное пространство, где работают обычные приложения. Оно имеет ограниченный доступ к ресурсам, и сбой программы влияет только на нее саму. **Kernel-space** — это привилегированное пространство, где работает ядро и его модули. Оно имеет полный доступ ко всем ресурсам системы, и ошибка в коде может привести к краху всей системы (kernel panic).

3.  **Что произойдёт, если в модуле обратиться к NULL указателю?**
    Обращение к NULL-указателю в модуле ядра приведет к ошибке "segmentation fault" на уровне ядра, что немедленно вызовет **kernel panic** и крах всей операционной системы.

4.  **Почему нельзя использовать `printf()` в модуле ядра?**
    `printf()` является частью стандартной библиотеки C (libc), которая работает в user-space и выводит данные в стандартные потоки (stdout). Модули ядра работают в kernel-space, где libc недоступна. Вместо `printf()` используется `printk()`, которая записывает сообщения в кольцевой буфер логов ядра.

5.  **Что такое kernel panic и как его избежать?**
    **Kernel panic** — это критическая ошибка ядра, при которой система не может продолжать работу и останавливается. Избежать ее можно, следуя правилам безопасного программирования в ядре: всегда проверять возвращаемые значения функций, проверять указатели на NULL, не выходить за границы массивов и использовать специальные функции (`copy_to/from_user`) для работы с данными из user-space.

### Жизненный цикл модуля:

6.  **Какие функции вызываются при `insmod` и `rmmod`?**
    При `insmod` вызывается функция, зарегистрированная макросом `module_init()`. При `rmmod` вызывается функция, зарегистрированная макросом `module_exit()`.

7.  **Что должна делать функция `module_exit()`?**
    Функция `module_exit()` должна освободить все ресурсы, которые были выделены в функции `module_init()`. Это включает отмену регистрации обработчиков (`/proc`, `/dev`), освобождение выделенной памяти (`kfree`) и любую другую "очистку".

8.  **Что происходит, если `module_init()` возвращает ошибку?**
    Если `module_init()` возвращает ненулевое значение (ошибку), загрузка модуля прерывается, и он не будет загружен в ядро. При этом функция `module_exit()` **не вызывается**, поэтому `module_init()` должна сама освободить все ресурсы, выделенные до момента возникновения ошибки.

9.  **Можно ли выгрузить модуль, если он используется?**
    Нет, ядро отслеживает счетчик использования модуля. Если этот счетчик больше нуля (например, открыт файл устройства, созданный модулем), `rmmod` завершится с ошибкой "Module is in use".

### Логирование и отладка:

10. **Чем `printk()` отличается от `printf()`?**
    `printk()` работает в kernel-space и выводит сообщения в лог ядра, а `printf()` работает в user-space и выводит в stdout. `printk()` поддерживает уровни важности (например, `KERN_INFO`, `KERN_ERR`), а `printf()` — нет.

11. **Какие уровни логирования существуют в ядре?**
    Существует 8 уровней логирования, от `KERN_EMERG` (0, самая высокая важность) до `KERN_DEBUG` (7, самая низкая). Наиболее часто используемые: `KERN_ERR`, `KERN_WARNING`, `KERN_INFO`.

12. **Как посмотреть логи модуля?**
    Логи модуля можно посмотреть с помощью команды `dmesg`. Также можно использовать `journalctl -k` в системах с systemd или читать файлы `/var/log/kern.log` или `/var/log/messages`.

13. **Что означает "tainted kernel"?**
    "Tainted kernel" ("испорченное" ядро) — это флаг, который устанавливает ядро, если был загружен проприетарный модуль, модуль без GPL-совместимой лицензии или если произошли определенные серьезные ошибки. Это означает, что ядро находится в неподдерживаемом состоянии, и разработчики ядра, скорее всего, не будут рассматривать отчеты о сбоях от такой системы.

### Память:

14. **Чем `kmalloc()` отличается от `malloc()`?**
    `kmalloc()` работает в kernel-space и выделяет физически непрерывные блоки памяти. `malloc()` работает в user-space и выделяет виртуальную память. `kmalloc()` требует указания флага GFP, определяющего контекст выделения.

15. **Что такое флаги GFP и зачем они нужны?**
    Флаги GFP (Get Free Pages) указывают функции `kmalloc()` контекст выделения памяти. Например, `GFP_KERNEL` означает, что процесс может "уснуть" в ожидании памяти, и используется в контексте процесса. `GFP_ATOMIC` означает, что процесс не может спать, и используется в контекстах, где блокировка недопустима (например, в обработчиках прерываний).

16. **Что произойдёт, если не освободить память в `module_exit()`?**
    Произойдет утечка памяти в ядре. Эта память останется занятой и недоступной для использования до следующей перезагрузки системы.

17. **Почему нельзя использовать user-space указатели напрямую в ядре?**
    Память user-space может быть выгружена в swap в любой момент. Прямое обращение к такому указателю из ядра может привести к ошибке страницы (page fault) в недопустимом контексте или к доступу к неверным данным, что вызовет kernel panic. Кроме того, это нарушает модель безопасности.

### Взаимодействие с user-space:

18. **Что такое `/proc` и для чего он используется?**
    `/proc` (procfs) — это виртуальная файловая система, которая предоставляет интерфейс для доступа к информации о процессах и другим данным ядра в виде файлов. Она используется для мониторинга состояния системы и взаимодействия с ядром.

19. **Что такое `/sys` (sysfs) и чем отличается от procfs?**
    `/sys` (sysfs) — это более современная виртуальная файловая система для представления иерархии устройств и драйверов. В отличие от `procfs`, `sysfs` следует правилу "один файл — одно значение", что делает ее более структурированной.

20. **Зачем нужны функции `copy_to_user()` и `copy_from_user()`?**
    Эти функции необходимы для безопасного копирования данных между kernel-space и user-space. Они выполняют необходимые проверки и обрабатывают возможные ошибки, предотвращая kernel panic.

21. **Что такое character device и как он работает?**
    Character device (символьное устройство) — это тип файла устройства в `/dev`, который предоставляет интерфейс для прямого, небуферизованного доступа к драйверу. Он работает как поток байтов, позволяя user-space программам взаимодействовать с ним через стандартные файловые операции (`open`, `read`, `write`, `close`).

### Параметры и метаданные:

22. **Как передать параметры модулю при загрузке?**
    Параметры передаются команде `insmod` в формате `имя_параметра=значение`. В коде модуля параметр должен быть объявлен с помощью макроса `module_param()`.

23. **Зачем нужен `MODULE_LICENSE()`?**
    Макрос `MODULE_LICENSE()` указывает лицензию модуля. Это важно, так как некоторые функции ядра доступны только для модулей с GPL-совместимой лицензией.

24. **Что произойдёт, если не указать лицензию?**
    Если лицензия не указана или она несовместима с GPL, ядро пометит себя как "tainted" (испорченное) при загрузке такого модуля.

### Безопасность:

25. **Какие основные правила безопасного кода в ядре?**

    1. Всегда проверять возвращаемые значения функций. 2. Освобождать все захваченные ресурсы. 3. Использовать `copy_to/from_user` для обмена данными с user-space. 4. Не использовать указатели из user-space напрямую. 5. Избегать длительных операций и бесконечных циклов.

26. **Можно ли использовать бесконечный цикл в модуле?**
    Нет, бесконечный цикл в коде, который выполняется не в контексте отдельного потока ядра, заблокирует ядро или как минимум одно из CPU, что приведет к зависанию системы.

27. **Почему в ядре нет FPU операций?**
    В ядре по умолчанию избегают операций с плавающей точкой (FPU), так как сохранение и восстановление контекста FPU при переключении задач является дорогостоящей операцией, что может привести к непредсказуемым задержкам.

28. **Что делать, если модуль вызвал kernel panic?**
    1. Перезагрузить систему. 2. После перезагрузки проанализировать логи ядра (`dmesg`, `journalctl`) в поисках сообщения об ошибке. 3. Проанализировать и исправить код модуля. 4. Повторить тестирование в изолированной среде (VM).

### Практические вопросы:

29. **Как узнать, какие модули загружены в системе?**
    С помощью команд `lsmod` или `cat /proc/modules`.

30. **Как получить информацию о модуле (версия, параметры)?**
    С помощью команды `modinfo имя_модуля.ko`. Она показывает метаданные: автора, описание, лицензию, версию и доступные параметры.

---

## Выводы

В ходе лабораторной работы были изучены:

1. Основы разработки модулей ядра Linux
2. Механизмы взаимодействия kernel-space и user-space
3. Работа с procfs для экспорта данных
4. Безопасное программирование в ядре (mutex, RCU, copy_to/from_user)

Особое внимание было уделено безопасности и обработке ошибок.

---

## Использование AI

AI использовался для генерации создания отчетности и помощи в работе с Virtual Box Oracle.
