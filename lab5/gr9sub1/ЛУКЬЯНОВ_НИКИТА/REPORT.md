# Отчёт по лабораторной работе №5: Модули ядра Linux

**Студент:** Лукьянов Никита
**Группа:** 9
**Подгруппа:** 1
**Вариант:** 2 (чётный номер по списку)

---

## 1. Цель работы

Изучить архитектуру модулей ядра Linux, научиться создавать простые модули, освоить взаимодействие с пользовательским пространством через `/proc` файловую систему, понять принципы работы с kernel-space кодом.

---

## 2. Задания

### Задание A: Hello World модуль

**Описание:** Создание простого модуля с параметрами для вывода приветствия и прощания.

**Реализация:**
- Модуль принимает два параметра: `init_output_string` и `exit_output_string`
- При загрузке выводит приветствие, при выгрузке — прощание
- Использованы функции `pr_info()` для логирования

**Результаты тестирования:**

```bash
# Загрузка с параметрами по умолчанию
sudo insmod hello_world_module.ko
# Вывод: "Hello from Nikita module!"

# Загрузка с пользовательским сообщением инициализации
sudo insmod hello_world_module.ko init_output_string="HI!"
# Вывод: "HI!"

# Загрузка с обоими параметрами
sudo insmod hello_world_module.ko init_output_string="HI!" exit_output_string="BYE!"
# Вывод при загрузке: "HI!"
# Вывод при выгрузке: "BYE!"
```

**Скриншот dmesg:**
```
[ 7543.202064] Hello from Nikita module!
[ 7563.779575] Goodbye from Nikita module!
[ 7595.880383] HI!
[ 7606.806626] Goodbye from Nikita module!
[ 7638.905728] HI!
[ 7646.130469] BYE!
```

---

### Задание B: /proc файл с записью

**Описание:** Создание файла `/proc/my_config` с возможностью чтения и записи.

**Реализация:**
- Файл создаётся с правами `0666` (чтение/запись для всех)
- По умолчанию содержит строку "default"
- Реализованы функции `procfs_read` и `procfs_write`
- Максимальный размер буфера: 256 байт
- Используются `copy_to_user()` и `copy_from_user()` для безопасной работы с памятью

**Результаты тестирования:**

```bash
# Чтение значения по умолчанию
cat /proc/my_config
# Вывод: default

# Запись нового значения
echo "Nikita" > /proc/my_config
cat /proc/my_config
# Вывод: Nikita

# Запись другого значения
echo "bye bye" > /proc/my_config
cat /proc/my_config
# Вывод: bye bye
```

**Логи работы модуля:**
```
[ 7977.153888] /proc/my_config created
[ 8002.886798] procfs_read: read 8 bytes
[ 8020.709638] procfs_write: write 7 bytes
[ 8024.072826] procfs_read: read 7 bytes
[ 8097.672982] procfs_write: write 8 bytes
[ 8104.240850] procfs_read: read 8 bytes
[ 8118.029863] /proc/my_config removed
```

---

### Задание C: /proc файл со статистикой системы

**Описание:** Создание файла `/proc/sys_stats` с информацией о системе.

**Реализация:**
- Подсчёт процессов через `for_each_process()`
- Вычисление используемой памяти через `si_meminfo()` и `si_mem_available()`
- Получение uptime системы через `ktime_get_boottime()`
- Форматированный вывод статистики

**Результаты тестирования:**

```bash
cat /proc/sys_stats
# Вывод:
# Processes: 265
# Memory Used: 2207 MB
# System Uptime 8387 seconds
```

**Сравнение с системными данными:**

| Параметр | /proc/sys_stats | Системная утилита | Расхождение |
|----------|-----------------|-------------------|-------------|
| Процессы | 265 | 266 (ps -e) | -1 процесс |
| Память | 2207 MB | ~2200 MB (расчёт по meminfo) | Незначительное |
| Uptime | 8387 sec | 8388 sec (/proc/uptime) | -1 секунда |

*Небольшие расхождения объясняются временем выполнения команд и округлением.*

---

## 3. Структура кода

### hello_world_module.c
- Использует `module_param()` для определения параметров
- Минимальная реализация init/exit функций
- Корректные метаданные модуля

### proc_module.c
- Создание proc-файла через `proc_create()`
- Реализация чтения и записи с проверкой offset
- Использование `copy_to_user()`/`copy_from_user()`
- Совместимость с разными версиями ядра через `HAVE_PROC_OPS`

### system_info_module.c
- Итерация по процессам через `for_each_process()`
- Работа с системной информацией о памяти
- Преобразование времени работы системы
- Форматирование вывода для пользователя

### Makefile
- Компиляция всех трёх модулей
- Стандартная структура для kernel modules
- Цели `all` и `clean`

---

## 4. Ответы на контрольные вопросы

### Базовые понятия

**1. Что такое модуль ядра и зачем он нужен?**
Модуль ядра — это динамически загружаемый фрагмент кода, расширяющий функциональность ядра без перекомпиляции и перезагрузки. Позволяет добавлять драйверы, файловые системы и другие функции по требованию.

**2. Чем отличается kernel-space от user-space?**
Kernel-space выполняется с полными привилегиями, имеет прямой доступ к оборудованию, ошибки приводят к kernel panic. User-space изолирован, защищён, ошибки не влияют на систему.

**3. Что произойдёт, если в модуле обратиться к NULL указателю?**
Kernel panic — полный крах системы с остановкой всех процессов.

**4. Почему нельзя использовать `printf()` в модуле ядра?**
Стандартная библиотека C недоступна в ядре. Вместо неё используется `printk()`, выводящий в kernel log buffer.

**5. Что такое kernel panic и как его избежать?**
Критическая ошибка ядра, останавливающая систему. Избежать можно через тщательную проверку указателей, границ массивов, возвращаемых значений и работу в VM.

### Жизненный цикл модуля

**6. Какие функции вызываются при `insmod` и `rmmod`?**
При `insmod` вызывается функция, зарегистрированная через `module_init()`. При `rmmod` — через `module_exit()`.

**7. Что должна делать функция `module_exit()`?**
Освобождать все ресурсы, выделенные в `module_init()`: память, proc-файлы, устройства, регистрации.

**8. Что происходит, если `module_init()` возвращает ошибку?**
Модуль не загружается, `module_exit()` НЕ вызывается, необходимо освободить ресурсы вручную в `init`.

**9. Можно ли выгрузить модуль, если он используется?**
Нет, система не позволит выгрузить модуль с ненулевым счётчиком использования.

### Логирование и отладка

**10. Чем `printk()` отличается от `printf()`?**
`printk()` пишет в kernel log buffer с уровнями важности, не может блокироваться. `printf()` пишет в stdout, может блокироваться.

**11. Какие уровни логирования существуют в ядре?**
`KERN_EMERG`, `KERN_ALERT`, `KERN_CRIT`, `KERN_ERR`, `KERN_WARNING`, `KERN_NOTICE`, `KERN_INFO`, `KERN_DEBUG` (0-7).

**12. Как посмотреть логи модуля?**
Через `dmesg`, `dmesg -w`, `/var/log/kern.log`, `journalctl -k`.

**13. Что означает "tainted kernel"?**
"Испорченное" ядро — загружен проприетарный модуль или модуль без GPL лицензии.

### Память

**14. Чем `kmalloc()` отличается от `malloc()`?**
`kmalloc()` выделяет физическую память в kernel-space с флагами GFP, не может использовать swap. `malloc()` выделяет виртуальную память в user-space.

**15. Что такое флаги GFP и зачем они нужны?**
Get Free Pages флаги определяют поведение аллокатора: `GFP_KERNEL` (может спать), `GFP_ATOMIC` (не может спать), `GFP_USER` (для user-данных).

**16. Что произойдёт, если не освободить память в `module_exit()`?**
Утечка памяти — ОЗУ будет недоступно до перезагрузки системы.

**17. Почему нельзя использовать user-space указатели напрямую в ядре?**
User-space адреса виртуальные и могут быть невалидными в kernel context. Нужны `copy_to_user()`/`copy_from_user()` для безопасного доступа.

### Взаимодействие с user-space

**18. Что такое `/proc` и для чего он используется?**
Виртуальная файловая система для экспорта информации из ядра в user-space и простого взаимодействия.

**19. Что такое `/sys` (sysfs) и чем отличается от procfs?**
Современная ФС для управления устройствами и их атрибутами. Философия: один файл = одно значение. ProcFS более хаотичен.

**20. Зачем нужны функции `copy_to_user()` и `copy_from_user()`?**
Для безопасного копирования данных между kernel-space и user-space с проверкой валидности адресов.

**21. Что такое character device и как он работает?**
Устройство, доступное через файловые операции (open, read, write, close). Реализуется через структуру `file_operations`.

### Параметры и метаданные

**22. Как передать параметры модулю при загрузке?**
Через `module_param()` в коде и `insmod module.ko param=value` в командной строке.

**23. Зачем нужен `MODULE_LICENSE()`?**
Для указания лицензии модуля. GPL совместим с ядром, другие лицензии помечают kernel как tainted.

**24. Что произойдёт, если не указать лицензию?**
Модуль загрузится, но ядро будет помечено как tainted, некоторые функции могут быть недоступны.

### Безопасность

**25. Какие основные правила безопасного кода в ядре?**
Проверять все возвращаемые значения, освобождать ресурсы, использовать `copy_*_user()`, проверять границы, избегать бесконечных циклов.

**26. Можно ли использовать бесконечный цикл в модуле?**
Нет, это заблокирует систему. В ядре нет вытесняющей многозадачности для kernel threads.

**27. Почему в ядре нет FPU операций?**
Контекст FPU принадлежит процессам user-space. Использование в ядре потребует сохранения/восстановления состояния.

**28. Что делать, если модуль вызвал kernel panic?**
Перезагрузить систему, изучить логи (если сохранились), исправить код, использовать VM для тестирования.

### Практические вопросы

**29. Как узнать, какие модули загружены в системе?**
`lsmod`, `cat /proc/modules`

**30. Как получить информацию о модуле (версия, параметры)?**
`modinfo module.ko`

---

## 5. Выводы

В ходе выполнения лабораторной работы:

1. **Освоены базовые принципы разработки модулей ядра Linux**: создание init/exit функций, использование метаданных, работа с параметрами модулей.

2. **Изучено взаимодействие с user-space через procfs**: реализованы операции чтения и записи, обеспечена безопасная работа с памятью через `copy_to_user()` и `copy_from_user()`.

3. **Получены навыки работы с системной информацией**: итерация по процессам, получение данных о памяти и uptime системы.

4. **Понято различие между kernel-space и user-space**: ограничения kernel-кода, отсутствие стандартной библиотеки, необходимость осторожности при работе с указателями.

5. **Практически применены средства отладки**: `dmesg`, `printk()`, сравнение результатов с системными утилитами.

Все три модуля успешно компилируются, загружаются и выгружаются без ошибок. Функциональность полностью соответствует заданию. Работа выполнялась в безопасной среде Ubuntu 24.04.
