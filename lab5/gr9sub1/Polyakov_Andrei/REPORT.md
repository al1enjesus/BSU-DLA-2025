# Отчет по лабораторной работе №5 - Модули ядра Linux

**Студент:** Поляков Андрей
**Группа:** 9, подгруппа 1
**Дата:** 7 декабря 2024
**Вариант:** 1 (нечётные номера, 19 по списку)

## Выполненные задания

### Задание A: Hello World модуль

**Описание:** Создан простой модуль `hello_module.c` со следующей функциональностью:

- При загрузке выводит "Hello from Polyakov Andrei module!"
- При выгрузке выводит "Goodbye from Polyakov Andrei module!"
- Поддерживает параметр `message` для пользовательского сообщения
- Использует корректные метаданные модуля

**Результаты тестирования:**

```
$ make test-hello
=== Testing hello_module ===
Loading module...
Output:
[ 9098.800042] hello_module: Hello from Polyakov Andrei module!

Unloading module...
Output:
[ 9098.855170] hello_module: Goodbye from Polyakov Andrei module!
```

**Тест с параметром:**

```
$ sudo insmod hello_module.ko message="Hi!"
$ dmesg | tail -1
[ 9199.126871] hello_module: Hi!
```

### Задание B: /proc файл с информацией

**Описание:** Создан модуль `proc_module.c` который:

- Создает файл `/proc/student_info`
- Выводит имя, группу, время загрузки модуля (jiffies)
- Ведет счетчик обращений к файлу

**Результаты тестирования:**

```
$ make test-proc
=== Testing proc_module ===
Loading module...
Reading /proc/student_info:
Name: Polyakov Andrei
Group: 9, Subgroup: 1
Module loaded at: 4303771965 jiffies
Read count: 1

dmesg output:
[ 9104.915373] proc_module: Initializing
[ 9104.915402] proc_module: Created /proc/student_info
[ 9104.942270] proc_module: Removed /proc/student_info
[ 9104.942274] proc_module: Exiting. Total reads: 1
```

### Задание C: Простой character device

**Описание:** Создан модуль `chardev_module.c` который:

- Создает character device `/dev/mychardev`
- Поддерживает операции открытия/закрытия
- Реализует чтение и запись данных (буфер 1024 байта)
- Логирует операции в dmesg

**Результаты тестирования:**

```
$ make test-chardev
=== Testing chardev_module ===
Loading module...
Creating device node with major 240...
Writing to device...
Reading from device:
Test data

dmesg output:
[ 9113.746091] chardev: Registered with major number 240
[ 9113.801507] chardev: Device opened
[ 9113.801514] chardev: Written 10 bytes
[ 9113.803161] chardev: Read 10 bytes
[ 9113.803224] chardev: Device closed
[ 9113.830699] chardev: Device unregistered
```

## Информация о модулях

```bash
$ modinfo hello_module.ko
filename: hello_module.ko
version: 1.0
description: Simple Hello World kernel module
author: Polyakov Andrei <polyakov@example.com>
license: GPL
parm: message:Custom greeting message (charp)

$ modinfo proc_module.ko
filename: proc_module.ko
version: 1.0
description: Proc filesystem example
author: Polyakov Andrei <polyakov@example.com>
license: GPL

$ modinfo chardev_module.ko
filename: chardev_module.ko
version: 1.0
description: Simple character device driver
author: Polyakov Andrei <polyakov@example.com>
license: GPL
```

## Ответы на вопросы

### Базовые понятия

#### 1. Что такое модуль ядра и зачем он нужен?

Модуль ядра - это часть кода, которая может быть динамически загружена в работающее ядро Linux без перезагрузки системы. Модули нужны для:

- Добавления поддержки нового оборудования (драйверы)
- Расширения функциональности ядра
- Экономии памяти (загрузка только нужных компонентов)
- Упрощения разработки и отладки

#### 2. Чем отличается kernel-space от user-space?

- **Kernel-space**: привилегированный режим процессора с полным доступом к оборудованию и памяти, выполнение критичного кода ядра
- **User-space**: непривилегированный режим, ограниченный доступ к ресурсам, изолированные процессы пользователей

Основные отличия:

- Уровень привилегий (ring 0 vs ring 3)
- Доступ к памяти (полный vs ограниченный)
- Функции API (системные вызовы vs стандартная библиотека)
- Обработка ошибок (kernel panic vs segmentation fault)

#### 3. Что произойдёт, если в модуле обратиться к NULL указателю?

Произойдет kernel panic - критическая ошибка ядра, которая приведет к аварийному завершению работы системы. В отличие от user-space, где процесс просто завершится с segmentation fault, в kernel-space нет защиты от таких ошибок.

#### 4. Почему нельзя использовать printf() в модуле ядра?

`printf()` - это функция стандартной библиотеки C, которая:

- Работает только в user-space
- Использует файловые дескрипторы и системы ввода-вывода user-space
- Недоступна в контексте ядра

Вместо этого используется `printk()` - аналог для kernel-space.

#### 5. Что такое kernel panic и как его избежать?

Kernel panic - критическая ошибка ядра, при которой система не может продолжить безопасную работу. Чтобы избежать:

- Проверять возвращаемые значения функций
- Правильно инициализировать указатели
- Использовать безопасные функции копирования данных
- Тестировать код в виртуальной машине

### Жизненный цикл модуля

#### 6. Какие функции вызываются при insmod и rmmod?

- `insmod`: вызывается функция, указанная в `module_init()`
- `rmmod`: вызывается функция, указанная в `module_exit()`

#### 7. Что должна делать функция module_exit()?

- Освобождать все выделенные ресурсы
- Удалять созданные файлы (/proc, /sys)
- Освобождать выделенную память
- Отменять регистрацию устройств
- Выводить информационные сообщения

#### 8. Что происходит, если module_init() возвращает ошибку?

- Модуль не загружается в систему
- Вызывается `module_exit()` для очистки частично инициализированных ресурсов
- `insmod` возвращает код ошибки
- В dmesg появляется сообщение об ошибке

#### 9. Можно ли выгрузить модуль, если он используется?

Нет, нельзя. Ядро отслеживает счетчик использования модуля (`lsmod` показывает колонку "Used by"). Модуль можно выгрузить только когда счетчик равен 0.

### Логирование и отладка

#### 10. Чем printk() отличается от printf()?

- `printk()` работает в kernel-space, `printf()` в user-space
- `printk()` использует уровни логирования (KERN_INFO, KERN_ERR, etc.)
- `printk()` записывает в кольцевой буфер ядра, доступный через dmesg
- `printk()` может вызываться из любого контекста ядра

#### 11. Какие уровни логирования существуют в ядре?

- `KERN_EMERG` (0) - система неработоспособна
- `KERN_ALERT` (1) - необходимо немедленное вмешательство
- `KERN_CRIT` (2) - критические условия
- `KERN_ERR` (3) - ошибки
- `KERN_WARNING` (4) - предупреждения
- `KERN_NOTICE` (5) - нормальные, но значимые события
- `KERN_INFO` (6) - информационные сообщения
- `KERN_DEBUG` (7) - отладочные сообщения

#### 12. Как посмотреть логи модуля?

```bash
dmesg | tail                    # последние сообщения
dmesg | grep module_name        # фильтр по имени модуля
journalctl -k                   # через systemd
cat /var/log/kern.log          # лог-файл ядра
```

#### 13. Что означает "tainted kernel"?

"Запятнанное" ядро - ядро, в которое загружены модули:

- С несовместимой лицензией (не GPL)
- Собранные для другой версии ядра
- Принудительно загруженные
- Из-за которых произошел kernel panic

### Память

#### 14. Чем kmalloc() отличается от malloc()?

- `kmalloc()` выделяет память в kernel-space, `malloc()` в user-space
- `kmalloc()` использует флаги GFP для управления выделением
- `kmalloc()` может вызываться из контекста прерывания (с определенными флагами)
- `kmalloc()` выделяет физически непрерывную память

#### 15. Что такое флаги GFP и зачем они нужны?

GFP (Get Free Page) флаги управляют поведением аллокатора памяти:

- `GFP_KERNEL` - обычное выделение, может заблокировать поток
- `GFP_ATOMIC` - атомарное выделение, не блокирует (для прерываний)
- `GFP_USER` - выделение для пользовательских данных
- `GFP_DMA` - память, доступная для DMA

#### 16. Что произойдёт, если не освободить память в module_exit()?

- Утечка памяти ядра
- Память останется занятой до перезагрузки
- Возможная нестабильность системы
- Сообщения в логах о неосвобожденной памяти

#### 17. Почему нельзя использовать user-space указатели напрямую в ядре?

- Разные адресные пространства
- Отсутствие гарантий валидности адресов
- Возможность нарушения безопасности
- Необходимо использовать `copy_to_user()`/`copy_from_user()`

### Взаимодействие с user-space

#### 18. Что такое /proc и для чего он используется?

`/proc` - виртуальная файловая система (procfs), предоставляющая интерфейс к внутренним структурам ядра:

- Информация о процессах (`/proc/PID/`)
- Системная информация (`/proc/cpuinfo`, `/proc/meminfo`)
- Настройки ядра (`/proc/sys/`)
- Интерфейс для модулей ядра

#### 19. Что такое /sys (sysfs) и чем отличается от procfs?

`/sys` (sysfs) - файловая система для экспорта информации об устройствах и драйверах:

- Структурированное представление устройств
- Один параметр на файл (в отличие от `/proc`)
- Более современная альтернатива `/proc` для конфигурации
- Интеграция с udev для управления устройствами

#### 20. Зачем нужны функции copy_to_user() и copy_from_user()?

Эти функции обеспечивают безопасное копирование данных между kernel-space и user-space:

- Проверяют валидность адресов user-space
- Обрабатывают page fault'ы
- Предотвращают нарушения безопасности
- Корректно работают с виртуальной памятью

#### 21. Что такое character device и как он работает?

Character device - тип устройства, работающего с данными как с потоком байтов:

- Последовательный доступ к данным
- Операции read/write/open/close
- Примеры: `/dev/tty`, `/dev/null`, `/dev/random`
- Регистрируется через `cdev_add()`

### Параметры и метаданные

#### 22. Как передать параметры модулю при загрузке?

```bash
# Через insmod
sudo insmod module.ko param1=value1 param2=value2

# В коде модуля
module_param(param1, type, permissions);
MODULE_PARM_DESC(param1, "Description");
```

#### 23. Зачем нужен MODULE_LICENSE()?

- Указывает лицензию модуля для ядра
- Влияет на возможность использования GPL-only символов
- Предотвращает "запятнание" ядра
- Требуется для совместимости с GPL ядром Linux

#### 24. Что произойдёт, если не указать лицензию?

- Ядро будет помечено как "tainted"
- Недоступны GPL-only символы ядра
- Предупреждения в dmesg
- Возможные ограничения функциональности

### Безопасность

#### 25. Какие основные правила безопасного кода в ядре?

- Проверять все возвращаемые значения
- Использовать безопасные функции копирования
- Правильно управлять памятью
- Избегать бесконечных циклов
- Проверять границы буферов
- Корректно обрабатывать ошибки

#### 26. Можно ли использовать бесконечный цикл в модуле?

Крайне не рекомендуется:

- Блокирует весь процессор
- Может привести к зависанию системы
- Нарушает отзывчивость системы
- Лучше использовать kernel thread'ы или рабочие очереди

#### 27. Почему в ядре нет FPU операций?

- Состояние FPU принадлежит пользовательским процессам
- Использование FPU в ядре может повредить данные процессов
- Необходимо сохранение/восстановление состояния FPU
- Увеличивает накладные расходы на переключение контекста

#### 28. Что делать, если модуль вызвал kernel panic?

- Перезагрузить систему
- Проанализировать стек трейс в логах
- Исправить ошибку в коде
- Тестировать в виртуальной машине
- Использовать отладчики (kgdb, kdump)

### Практические вопросы

#### 29. Как узнать, какие модули загружены в системе?

```bash
lsmod                    # список загруженных модулей
cat /proc/modules        # подробная информация
modinfo module_name      # информация о конкретном модуле
```

#### 30. Как получить информацию о модуле (версия, параметры)?

```bash
modinfo module.ko                    # информация о файле модуля
cat /sys/module/module_name/version  # версия загруженного модуля
ls /sys/module/module_name/parameters/  # параметры модуля
```

---

## Использование AI

Был использован Claude AI (Sonnet 4.5) для составления отчета и инструкций запуска
