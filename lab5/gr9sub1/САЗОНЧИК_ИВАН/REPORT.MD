Отчёт по лабораторной работе №5
Модули ядра Linux
Выполнил: Сазончик Иван
Группа: 9
Подгруппа: 1

Содержание
Краткое описание модулей

Задание A: Hello World модуль

Задание B: /proc файл с информацией

Задание C: Простой character device

Ответы на вопросы

Выводы

Краткое описание модулей
Hello World модуль (hello_module.c)
Базовый демонстрационный модуль, который выводит приветственное сообщение при загрузке и прощальное сообщение при выгрузке. Поддерживает передачу параметра message для кастомного приветствия. Демонстрирует основы жизненного цикла модуля и работу с параметрами.

Proc модуль (proc_module.c)
Модуль, создающий виртуальный файл /proc/student_info с информацией о студенте. При каждом чтении файла увеличивает счётчик обращений и отображает время загрузки модуля в jiffies. Демонстрирует взаимодействие с user-space через proc filesystem.

Character Device модуль (chardev_module.c)
Модуль, реализующий простое символьное устройство /dev/mychardev. Поддерживает операции открытия, закрытия, чтения и записи. Сохраняет данные в буфере ядра и возвращает их при чтении. Демонстрирует работу с character devices и безопасное копирование данных между kernel-space и user-space.

Задание A: Hello World модуль
Описание
Модуль выводит приветственное сообщение при загрузке и прощальное при выгрузке. Поддерживает опциональный параметр message для кастомного приветствия.

Проверка работы
Загрузка модуля без параметров:

bash
sudo insmod hello_module.ko
dmesg | tail -2
Вывод:

text
hello_module: Hello from Sazonchik Ivan module!
Загрузка модуля с параметром:

bash
sudo insmod hello_module.ko message="Custom greeting"
dmesg | tail -2
Вывод:

text
hello_module: Custom greeting
Выгрузка модуля:

bash
sudo rmmod hello_module
dmesg | tail -2
Вывод:

text
hello_module: Goodbye from Sazonchik Ivan module!


Задание B: /proc файл с информацией
Описание
Модуль создаёт файл /proc/student_info, который при каждом чтении отображает информацию о студенте, время загрузки модуля и увеличивает счётчик обращений.

Проверка работы
Загрузка модуля:

bash
sudo insmod proc_module.ko
dmesg | tail -2
Вывод:

text
proc_module: Created /proc/student_info
Чтение файла:

bash
cat /proc/student_info
Вывод:

text
Name: Sazonchik Ivan
Group: 9, Subgroup: 1
Module loaded at: 123456789 jiffies
Read count: 1
Повторное чтение:

bash
cat /proc/student_info
Вывод:

text
Name: Sazonchik Ivan
Group: 9, Subgroup: 1
Module loaded at: 123456789 jiffies
Read count: 2
Выгрузка модуля:

bash
sudo rmmod proc_module
dmesg | tail -2
Вывод:

text
proc_module: Exiting. Total reads: 2

Задание C: Простой character device
Описание
Модуль создаёт символьное устройство /dev/mychardev с поддержкой операций открытия, закрытия, чтения и записи. Данные сохраняются в буфере ядра и возвращаются при последующих чтениях.

Проверка работы
Загрузка модуля:

bash
sudo insmod chardev_module.ko
dmesg | tail -5
Вывод:

text
chardev: Registered with major number 511
chardev: Create device with: sudo mknod /dev/mychardev c 511 0
Создание device node:

bash
sudo mknod /dev/mychardev c 511 0
sudo chmod 666 /dev/mychardev
Запись в устройство:

bash
echo "Hello from user space!" > /dev/mychardev
dmesg | tail -2
Вывод:

text
chardev: Written 23 bytes
Чтение из устройства:

bash
cat /dev/mychardev
dmesg | tail -2
Вывод:

text
Hello from user space!
chardev: Read 23 bytes
Выгрузка модуля:

bash
sudo rmmod chardev_module
dmesg | tail -2
Вывод:

text
chardev: Device unregistered

Ответы на вопросы
Базовые понятия:
Что такое модуль ядра и зачем он нужен?
Модуль ядра — это фрагмент кода, который может быть динамически загружен и выгружен из ядра Linux во время работы системы без необходимости перезагрузки. Модули нужны для расширения функциональности ядра без его перекомпиляции (драйверы устройств, файловые системы, сетевые протоколы).

Чем отличается kernel-space от user-space?
Kernel-space — привилегированное пространство, где работает ядро и модули, с полным доступом к аппаратуре. User-space — непривилегированное пространство для обычных программ с ограниченным доступом к ресурсам.

Что произойдёт, если в модуле обратиться к NULL указателю?
Произойдёт kernel panic, так как в ядре нет механизма обработки страничных ошибок как в user-space.

Почему нельзя использовать printf() в модуле ядра?
printf() — это функция стандартной библиотеки C, которая недоступна в kernel-space. Вместо неё используется printk() для вывода в кольцевой буфер ядра.

Что такое kernel panic и как его избежать?
Kernel panic — это критическая ошибка ядра, приводящая к остановке системы. Чтобы избежать, нужно проверять указатели, проверять возвращаемые значения функций, использовать правильные функции копирования данных.

Жизненный цикл модуля:
Какие функции вызываются при insmod и rmmod?
При insmod вызывается функция, зарегистрированная через module_init(). При rmmod — функция, зарегистрированная через module_exit().

Что должна делать функция module_exit()?
Освобождать все ресурсы, выделенные модулем: память, регистрации устройств, /proc файлы и т.д.

Что происходит, если module_init() возвращает ошибку?
Модуль не загружается, и функция module_exit() не вызывается. Все ресурсы, выделенные до ошибки, должны быть освобождены вручную.

Можно ли выгрузить модуль, если он используется?
Нет, система вернёт ошибку "Module is in use". Нужно сначала закрыть все процессы, использующие модуль.

Логирование и отладка:
Чем printk() отличается от printf()?
printk() выводит в кольцевой буфер ядра, поддерживает уровни логирования, не блокируется и не использует стандартную библиотеку C.

Какие уровни логирования существуют в ядре?
От KERN_EMERG (0) до KERN_DEBUG (7). Чаще используются KERN_INFO, KERN_ERR, KERN_DEBUG.

Как посмотреть логи модуля?
С помощью dmesg, journalctl -k, или чтения файлов /var/log/kern.log.

Что означает "tainted kernel"?
"Испорченное" ядро — статус, который устанавливается при загрузке проприетарных модулей или модулей без правильной лицензии.

Память:
Чем kmalloc() отличается от malloc()?
kmalloc() выделяет физически непрерывную память в kernel-space, не использует виртуальную память с подкачкой, требует указания флагов GFP.

Что такое флаги GFP и зачем они нужны?
Флаги Get Free Pages определяют поведение аллокатора памяти. GFP_KERNEL — для обычных ситуаций, GFP_ATOMIC — для атомарных контекстов.

Что произойдёт, если не освободить память в module_exit()?
Произойдёт утечка памяти, которая не будет восстановлена до перезагрузки системы.

Почему нельзя использовать user-space указатели напрямую в ядре?
Указатели user-space могут быть невалидными в контексте ядра, не отображены в текущем адресном пространстве. Нужно использовать copy_from_user()/copy_to_user().

Взаимодействие с user-space:
Что такое /proc и для чего он используется?
Виртуальная файловая система для экспорта информации из ядра в user-space. Используется для чтения системной информации и конфигурации.

Что такое /sys (sysfs) и чем отличается от procfs?
Sysfs — более современная система для экспорта атрибутов устройств и драйверов. В отличие от procfs, следует философии "один файл — одно значение".

Зачем нужны функции copy_to_user() и copy_from_user()?
Для безопасного копирования данных между kernel-space и user-space с проверкой прав доступа и валидности указателей.

Что такое character device и как он работает?
Устройство, с которым можно работать как с файлом (последовательный доступ). Регистрируется в системе через major/minor номера и операции с файлами.

Параметры и метаданные:
Как передать параметры модулю при загрузке?
Через командную строку: insmod module.ko param=value. Параметры должны быть объявлены через module_param().

Зачем нужен MODULE_LICENSE()?
Для указания лицензии модуля. Без правильной лицензии ядро пометит модуль как tainted, и некоторые функции ядра будут недоступны.

Что произойдёт, если не указать лицензию?
Модуль будет работать, но ядро пометится как tainted, и некоторые API ядра будут недоступны.

Безопасность:
Какие основные правила безопасного кода в ядре?
Проверять возвращаемые значения, освобождать ресурсы, использовать правильные функции копирования, проверять границы, избегать бесконечных циклов.

Можно ли использовать бесконечный цикл в модуле?
Нет, это может заблокировать систему, особенно в контексте прерываний.

Почему в ядре нет FPU операций?
Операции с плавающей точкой требуют сохранения/восстановления состояния FPU, что дорого и не всегда безопасно в kernel-space.

Что делать, если модуль вызвал kernel panic?
Перезагрузить систему, проанализировать логи, найти и исправить ошибку в коде.

Практические вопросы:
Как узнать, какие модули загружены в системе?
Команды lsmod, cat /proc/modules.

Как получить информацию о модуле (версия, параметры)?
Команда modinfo module.ko, просмотр файлов в /sys/module/module_name/.

Выводы
В ходе лабораторной работы были успешно разработаны и протестированы три модуля ядра Linux:

Hello World модуль — продемонстрировал базовые принципы работы модулей: инициализация, выгрузка, передача параметров.

/proc модуль — показал взаимодействие с user-space через виртуальную файловую систему procfs.

Character device модуль — реализовал простое символьное устройство с операциями чтения/записи.

Все модули корректно загружаются и выгружаются, не вызывают kernel panic и правильно освобождают ресурсы. Работа выполнена в соответствии с требованиями варианта для нечётного номера в списке.

Основные сложности возникли при работе с character device — необходимость ручного создания device node и правильной обработки операций чтения/записи. Эти сложности были успешно преодолены изучением документации и отладкой через printk().

Лабораторная работа позволила получить практический опыт разработки модулей ядра Linux и понять основные принципы работы kernel-space.