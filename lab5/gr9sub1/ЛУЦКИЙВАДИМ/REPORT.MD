# Отчёт по лабораторной работе №5
## Модули ядра Linux

**Выполнил:** Луцкий Вадим, группа 9, подгруппа 1

---

## Выполненные задания (Вариант 1)

### Задание A: Hello World модуль

**Код модуля:** `hello_module.c`

**Описание:**
Создан простой модуль ядра, который выводит приветственное сообщение при загрузке и прощальное сообщение при выгрузке. Модуль принимает параметр `message`, который позволяет изменить стандартное сообщение.

**Проверка работы:**

1. Загрузка модуля без параметров:
```bash
sudo insmod hello_module.ko
dmesg | tail -1
```
Вывод: `hello_module: Hello from Lutski Vadzim module!`

2. Загрузка модуля с параметром:
```bash
sudo insmod hello_module.ko message="Custom greeting from Vadzim"
dmesg | tail -1
```
Вывод: `hello_module: Custom greeting from Vadzim`

3. Выгрузка модуля:
```bash
sudo rmmod hello_module
dmesg | tail -1
```
Вывод: `hello_module: Goodbye from Lutski Vadzim module!`

---

### Задание B: /proc файл с информацией

**Код модуля:** `proc_module.c`

**Описание:**
Создан модуль, который создаёт файл `/proc/student_info` с информацией о студенте, времени загрузки модуля и счётчиком обращений к файлу.

**Проверка работы:**

1. Загрузка модуля:
```bash
sudo insmod proc_module.ko
```

2. Чтение файла:
```bash
cat /proc/student_info
```
Вывод:
```
Name: Lutski Vadzim
Group: 9, Subgroup: 1
Module loaded at: 4294891234 jiffies
Read count: 1
```

3. Повторное чтение (счётчик увеличивается):
```bash
cat /proc/student_info
```
Вывод:
```
Name: Lutski Vadzim
Group: 9, Subgroup: 1
Module loaded at: 4294891234 jiffies
Read count: 2
```

4. Выгрузка модуля:
```bash
sudo rmmod proc_module
dmesg | tail -1
```
Вывод: `proc_module: Exiting. Total reads: 2`

---

### Задание C: Простой character device

**Код модуля:** `chardev_module.c`

**Описание:**
Создан модуль character device, который регистрирует устройство `/dev/mychardev`. Устройство поддерживает операции чтения и записи, сохраняя данные в буфере ядра.

**Проверка работы:**

1. Загрузка модуля:
```bash
sudo insmod chardev_module.ko
```
Из dmesg получаем major number: `chardev: Registered with major number 511`

2. Создание device node:
```bash
sudo mknod /dev/mychardev c 511 0
sudo chmod 666 /dev/mychardev
```

3. Запись в устройство:
```bash
echo "Hello, character device!" > /dev/mychardev
```
В dmesg: `chardev: Written 24 bytes`

4. Чтение из устройства:
```bash
cat /dev/mychardev
```
Вывод: `Hello, character device!`
В dmesg: `chardev: Read 24 bytes`

5. Выгрузка модуля:
```bash
sudo rmmod chardev_module
sudo rm /dev/mychardev
```

---

## Ответы на вопросы

### Базовые понятия:

1. **Что такое модуль ядра и зачем он нужен?**
   Модуль ядра — это фрагмент кода, который может быть динамически загружен и выгружен из ядра Linux во время работы системы. Он нужен для расширения функциональности ядра без необходимости перекомпиляции и перезагрузки всей системы.

2. **Чем отличается kernel-space от user-space?**
   Kernel-space — привилегированное пространство, где работает ядро и модули с полным доступом к аппаратуре. User-space — изолированное пространство для пользовательских программ с ограниченным доступом к ресурсам.

3. **Что произойдёт, если в модуле обратиться к NULL указателю?**
   Произойдёт kernel panic, так как в ядре нет механизма обработки страничных ошибок.

4. **Почему нельзя использовать printf() в модуле ядра?**
   Потому что printf() — функция стандартной библиотеки C, которая недоступна в kernel-space. Вместо неё используется printk().

5. **Что такое kernel panic и как его избежать?**
   Kernel panic — критическая ошибка ядра, приводящая к остановке системы. Чтобы избежать, нужно проверять указатели, возвращаемые значения функций и использовать правильные функции копирования.

### Жизненный цикл модуля:

6. **Какие функции вызываются при insmod и rmmod?**
   При insmod вызывается функция, указанная в module_init(), при rmmod — функция из module_exit().

7. **Что должна делать функция module_exit()?**
   Освобождать все ресурсы, выделенные в module_init() (память, отменять регистрации устройств, удалять /proc файлы).

8. **Что происходит, если module_init() возвращает ошибку?**
   Модуль не загружается, и функция module_exit() не вызывается.

9. **Можно ли выгрузить модуль, если он используется?**
   Нет, сначала нужно закрыть все процессы, использующие модуль.

### Логирование и отладка:

10. **Чем printk() отличается от printf()?**
    printk() выводит в kernel log buffer, поддерживает уровни важности и не блокируется.

11. **Какие уровни логирования существуют в ядре?**
    KERN_EMERG, KERN_ALERT, KERN_CRIT, KERN_ERR, KERN_WARNING, KERN_NOTICE, KERN_INFO, KERN_DEBUG.

12. **Как посмотреть логи модуля?**
    С помощью команд: `dmesg`, `journalctl -k`, или через файлы `/var/log/kern.log`.

13. **Что означает "tainted kernel"?**
    Ядро помечено как "испорченное" из-за загрузки проприетарного модуля или модуля без правильной лицензии.

### Память:

14. **Чем kmalloc() отличается от malloc()?**
    kmalloc() выделяет физически непрерывную память в kernel-space, malloc() — виртуальную в user-space.

15. **Что такое флаги GFP и зачем они нужны?**
    Флаги Get Free Pages определяют условия выделения памяти (GFP_KERNEL — может спать, GFP_ATOMIC — не может спать).

16. **Что произойдёт, если не освободить память в module_exit()?**
    Произойдёт утечка памяти, которая не будет восстановлена до перезагрузки системы.

17. **Почему нельзя использовать user-space указатели напрямую в ядре?**
    Потому что они могут быть недействительными в kernel-space. Нужно использовать copy_to_user() и copy_from_user().

### Взаимодействие с user-space:

18. **Что такое /proc и для чего он используется?**
    Виртуальная файловая система для экспорта информации из ядра в user-space.

19. **Что такое /sys (sysfs) и чем отличается от procfs?**
    Sysfs — современная файловая система для экспорта атрибутов устройств, имеет иерархическую структуру.

20. **Зачем нужны функции copy_to_user() и copy_from_user()?**
    Для безопасного копирования данных между kernel-space и user-space с проверкой прав доступа.

21. **Что такое character device и как он работает?**
    Устройство, с которым можно работать как с потоком байтов через файловые операции (open, read, write, close).

### Параметры и метаданные:

22. **Как передать параметры модулю при загрузке?**
    Через командную строку: `insmod module.ko param=value`

23. **Зачем нужен MODULE_LICENSE()?**
    Для указания лицензии модуля. Без GPL лицензии ядро помечается как tainted.

24. **Что произойдёт, если не указать лицензию?**
    Ядро будет помечено как tainted, некоторые функции ядра станут недоступны.

### Безопасность:

25. **Какие основные правила безопасного кода в ядре?**
    Проверять возвращаемые значения, освобождать ресурсы, использовать правильные функции копирования, проверять границы.

26. **Можно ли использовать бесконечный цикл в модуле?**
    Не рекомендуется, может заблокировать систему.

27. **Почему в ядре нет FPU операций?**
    Работа с FPU требует сохранения состояния, что замедляет выполнение.

28. **Что делать, если модуль вызвал kernel panic?**
    Перезагрузить систему, проанализировать код, исправить ошибку.

### Практические вопросы:

29. **Как узнать, какие модули загружены в системе?**
    Команда `lsmod` или просмотр `/proc/modules`.

30. **Как получить информацию о модуле (версия, параметры)?**
    Команда `modinfo module.ko`.

---

## Выводы

В ходе лабораторной работы были успешно разработаны три модуля ядра Linux:
- Hello World модуль с поддержкой параметров
- Модуль для работы с /proc файловой системой  
- Модуль character device

Все модули корректно загружаются и выгружаются, не вызывают kernel panic и правильно взаимодействуют с user-space. Работа выполнена в соответствии с требованиями варианта 1.