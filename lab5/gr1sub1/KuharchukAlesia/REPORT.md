# Лабораторная работа №5: Модули ядра Linux

**Номер по списку:** 11  
**Вариант:** 1 (нечётный номер)

## Цель работы
Изучить архитектуру ядра Linux, научиться разрабатывать, собирать, загружать и отлаживать простые модули ядра, а также освоить механизмы взаимодействия модулей с пространством пользователя.

---
### Задание A: Модуль "Hello, World!"
Создать простой модуль ядра, который:
- При загрузке (`insmod`) выводит в системный журнал приветственное сообщение
- При выгрузке (`rmmod`) выводит прощальное сообщение
- Принимает строковый параметр `message`

Команды:
```bash
sudo insmod hello_module.ko
sudo rmmod hello_module
sudo insmod hello_module.ko message=Custom_greeting_from_Alesia
sudo rmmod hello_module
```
Результат:
```bash
[ 6807.379060] Hello from Alesia module!
[ 6816.670444] Goodbye from Alesia module!
[ 6826.334720] Custom_greeting_from_Alesia
[ 6836.215554] Goodbye from Alesia module!
```
### Вывод:
 Модуль корректно загружается, выгружается и принимает параметры.

### Задание B: /proc файл с информацией о студенте
Создать модуль, который создаёт файл `/proc/student_info` с информацией:
- Имя студента
- Группа и подгруппа
- Время загрузки модуля (в jiffies)
- Счётчик обращений к файлу

Команды:
```bash
sudo insmod proc_module.ko
ls -la /proc/student_info
cat /proc/student_info
cat /proc/student_info
sudo rmmod proc_module
ls -la /proc/student_info
```
Результат:
```bash
# ls -la /proc/student_info
-r--r--r-- 1 root root 0 Nov 11 00:44 /proc/student_info

# Первое чтение:
Name: Alesia
Group: 1, Subgroup: 1
Module loaded at: 4296627484 jiffies
Read count: 1

# Второе чтение:
Name: Alesia
Group: 1, Subgroup: 1
Module loaded at: 4296627484 jiffies
Read count: 2

# Логи:
[ 6940.804029] Created /proc/student_info
[ 6984.594087] Removed /proc/student_info
```
### Вывод:
Файл корректно создаётся в /proc, отображает информацию о студенте, время загрузки модуля и ведёт счётчик обращений, который увеличивается при каждом чтении. Файл удаляется при выгрузке модуля.

### Задание C: Character Device
Создать character device /dev/mychardev, который:
- Можно открыть/закрыть
- При записи сохраняет данные в kernel buffer (1024 байта)
- При чтении возвращает сохранённые данные
- Логирует все операции в системный журнал

Команды:
```bash
sudo insmod char_device.ko
ls -la /dev/mychardev
sudo chmod 666 /dev/mychardev
echo "Hello from Alesia character device!" > /dev/mychardev
cat /dev/mychardev
sudo rmmod char_device
```

Результат:
```bash
# ls -la /dev/mychardev
crw------- 1 root root 237, 0 Nov 11 00:47 /dev/mychardev

# Чтение после записи:
Hello from Alesia character device!

# Логи операций:
[ 7238.036630] mychardev: Device opened (1 times)
[ 7238.036641] mychardev: Wrote 36 bytes: Hello from Alesia character device!
[ 7238.036644] mychardev: Device closed
[ 7249.526799] mychardev: Device opened (2 times)
[ 7249.526812] mychardev: Read 36 bytes
[ 7249.526825] mychardev: Device closed
```

### Вывод:
Character device работает корректно - устройство создаётся автоматически, поддерживает операции записи и чтения данных, логирует все операции открытия/закрытия и передачи данных. Устройство удаляется при выгрузке модуля.

## Ответы на вопросы

### Базовые понятия

#### 1. Что такое модуль ядра и зачем он нужен?

Модуль ядра - это фрагмент кода, который может быть динамически загружен и выгружен из ядра Linux во время работы системы без необходимости перезагрузки.  
Модули нужны для:

- Добавления драйверов
- Расширения функциональности ядра
- Экономии памяти
- Упрощения разработки и отладки

#### 2. Чем отличается kernel-space от user-space?

- **Kernel-space**: Привилегированный режим, полный доступ к оборудованию, сбой приводит к панике ядра (kernel panic). Использует API ядра.
- **User-space**: Непривилегированный режим, доступ к ресурсам через системные вызовы, сбой затрагивает только процесс.

#### 3. Что произойдёт, если в модуле обратиться к NULL указателю?

В модуле вызовет исключение в ядре, что приведет к kernel panic и аварийной остановке системы.

#### 4. Почему нельзя использовать printf() в модуле ядра?
`printf()` - это функция стандартной библиотеки C, которая:

- Работает только в user-space
- Использует файловые дескрипторы и системы ввода-вывода user-space
- Недоступна в контексте ядра

Вместо этого используется `printk()` - аналог для kernel-space.

#### 5. Что такое kernel panic и как его избежать?

**Kernel panic** - это неисправимая ошибка ядра, приводящая к остановке системы. Чтобы избежать: проверять указатели перед использованием, проверять возвращаемые значения функций, корректно освобождать ресурсы.

### Жизненный цикл модуля

#### 6. Какие функции вызываются при insmod и rmmod?

- `insmod`: вызывается функция, указанная в `module_init()`
- `rmmod`: вызывается функция, указанная в `module_exit()`

#### 7. Что должна делать функция module_exit()?

Должна освобождать все ресурсы, выделенные модулем (память, номера устройств, записи в /proc).

#### 8. Что происходит, если module_init() возвращает ошибку?

- Модуль не загружается в систему
- Вызывается `module_exit()` для очистки частично инициализированных ресурсов
- `insmod` возвращает код ошибки
- В dmesg появляется сообщение об ошибке

#### 9. Можно ли выгрузить модуль, если он используется?

Нет, нельзя. Ядро отслеживает счетчик использования модуля (`lsmod` показывает колонку "Used by"). Модуль можно выгрузить только когда счетчик равен 0.

### Логирование и отладка

#### 10. Чем printk() отличается от printf()?

- `printk()` работает в kernel-space, `printf()` в user-space
- `printk()` использует уровни логирования (KERN_INFO, KERN_ERR, etc.)
- `printk()` записывает в кольцевой буфер ядра, доступный через dmesg
- `printk()` может вызываться из любого контекста ядра

#### 11. Какие уровни логирования существуют в ядре?

- `KERN_EMERG` (0) - система неработоспособна
- `KERN_ALERT` (1) - необходимо немедленное вмешательство
- `KERN_CRIT` (2) - критические условия
- `KERN_ERR` (3) - ошибки
- `KERN_WARNING` (4) - предупреждения
- `KERN_NOTICE` (5) - нормальные, но значимые события
- `KERN_INFO` (6) - информационные сообщения
- `KERN_DEBUG` (7) - отладочные сообщения

#### 12. Как посмотреть логи модуля?

```bash
dmesg | tail                    # последние сообщения
dmesg | grep module_name        # фильтр по имени модуля
journalctl -k                   # через systemd
cat /var/log/kern.log          # лог-файл ядра
```

#### 13. Что означает "tainted kernel"?

Флаг, указывающий, что ядро загрузило проприетарный модуль, модуль без лицензии или модуль, загруженный принудительно. Это может ограничить поддержку при отладке.

### Память

#### 14. Чем kmalloc() отличается от malloc()?

- `kmalloc()` выделяет физически непрерывную память в kernel-space, `malloc()` в user-space
- `kmalloc()` использует флаги GFP для управления выделением
- `kmalloc()` может вызываться из контекста прерывания (с определенными флагами)

#### 15. Что такое флаги GFP и зачем они нужны?

GFP (Get Free Page) определяют контекст и приоритет выделения памяти:

- `GFP_KERNEL` — стандартное выделение, может спать.
- `GFP_ATOMIC` — для атомарных контекстов (например, в прерываниях), не спит.
- `GFP_USER` - выделение для пользовательских данных.
- `GFP_DMA` - память, доступная для DMA.

#### 16. Что произойдёт, если не освободить память в module_exit()?

- Утечка памяти ядра
- Память останется занятой до перезагрузки системы
- Возможная нестабильность системы
- Сообщения в логах о неосвобожденной памяти

#### 17. Почему нельзя использовать user-space указатели напрямую в ядре?

Указатели user-space нельзя использовать напрямую в ядре, так как они являются виртуальными адресами в адресном пространстве пользовательского процесса и могут быть невалидными или недоступными в контексте ядра. Для работы с ними используются функции copy_from_user() и copy_to_user().

### Взаимодействие с user-space

#### 18. Что такое /proc и для чего он используется?

`/proc` - виртуальная файловая система для предоставления информации о системе и процессах, а также для простого взаимодействия с модулями ядра.

#### 19. Что такое /sys (sysfs) и чем отличается от procfs?

`/sys` (sysfs) - файловая система для экспорта информации об устройствах и драйверах:

- Структурированное представление устройств
- Один параметр на файл (в отличие от `/proc`)

#### 20. Зачем нужны функции copy_to_user() и copy_from_user()?

Эти функции обеспечивают безопасное копирование данных между kernel-space и user-space:

- Проверяют валидность адресов user-space
- Обрабатывают page fault
- Корректно работают с виртуальной памятью

#### 21. Что такое character device и как он работает?

Character device — это устройство, с которым можно работать как с потоком байтов (например, /dev/ttyS0). Модуль регистрирует операции с устройством (open, read, write, release) через структуру file_operations.

### Параметры и метаданные

#### 22. Как передать параметры модулю при загрузке?

Параметры модулю передаются при загрузке: 
`insmod module.ko param_name=value`. 
Внутри модуля они объявляются с помощью `module_param()`.

#### 23. Зачем нужен MODULE_LICENSE()?

Необходим для указания лицензии модуля. Модули без лицензии GPL помечают ядро как "tainted" и не имеют доступа к некоторым символам (функциям) ядра, экспортируемым только для GPL-модулей.

#### 24. Что произойдёт, если не указать лицензию?

Если не указать лицензию, ядро пометит себя как "tainted", что может осложнить получение поддержки при отладке проблем.

### Безопасность

#### 25. Какие основные правила безопасного кода в ядре?

- Проверять все возвращаемые значения
- Использовать безопасные функции копирования
- Правильно управлять памятью
- Избегать бесконечных циклов
- Проверять границы буферов
- Корректно обрабатывать ошибки

#### 26. Можно ли использовать бесконечный цикл в модуле?

Бесконечный цикл в модуле может полностью заблокировать ядро, особенно если он выполняется в атомарном контексте или с отключенными прерываниями.

#### 27. Почему в ядре нет FPU операций?

FPU операции в ядре не используются, потому что контекст ядра не сохраняет и не восстанавливает состояние FPU по умолчанию для производительности. Это ложится на пользовательские процессы.

#### 28. Что делать, если модуль вызвал kernel panic?

- Перезагрузить систему
- Проанализировать стек трейс в логах
- Исправить ошибку в коде
- Тестировать в виртуальной машине
- Использовать отладчики (kgdb, kdump)

### Практические вопросы

#### 29. Как узнать, какие модули загружены в системе?

```bash
lsmod                    # список загруженных модулей
cat /proc/modules        # подробная информация
modinfo module_name      # информация о конкретном модуле
```

#### 30. Как получить информацию о модуле (версия, параметры)?

```bash
modinfo module.ko                    # информация о файле модуля
cat /sys/module/module_name/version  # версия загруженного модуля
ls /sys/module/module_name/parameters/  # параметры модуля
```

## Использование AI
Корректное написание и форматирование файлов-отчётов, помощь в решении возникающих ошибок во время выполнения работы