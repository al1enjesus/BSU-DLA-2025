ФИО: Козловский Антон
Группа: 1
Подгруппа: 1
Вариант: 1 (9 номер)

Выводы по результатам работы

1. Hello Module

Наблюдения:

Модуль успешно загружается и выгружается
Сообщения выводятся в kernel log через printk()
Параметр message корректно передаётся и обрабатывается
При использовании параметра выводится кастомное сообщение
Время загрузки/выгрузки отображается в логах
Пример вывода:
```
[   12.345678] Hello from Kazlouski Anton module!
[   12.345679] Hello module loaded successfully
[   15.123456] Custom message: My custom greeting
[   15.123457] Hello module loaded successfully
[   18.789012] Goodbye from Kazlouski Anton module!
[   18.789013] Hello module unloaded successfully
```

2. Proc Module

Наблюдения:

Файл /proc/student_info успешно создаётся
Информация корректно форматируется и выводится
Счётчик обращений увеличивается при каждом чтении
Время загрузки модуля фиксируется в jiffies
Модуль корректно очищает ресурсы при выгрузке
Пример вывода:
```
Name: Kazlouski Anton
Group: 1, Subgroup: 1
Module loaded at: 123456 jiffies
Current time: 130000 jiffies
Read count: 1
```

3. Character Device

Наблюдения:

Устройство успешно регистрируется с динамическим major номером
Операции open/close логируются в dmesg
Данные корректно записываются и читаются через буфер ядра
Используются безопасные функции копирования данных
Ресурсы освобождаются при выгрузке модуля
Пример вывода:
```
[   25.123456] Character device opened by process
[   25.123457] Wrote 13 bytes to device: Hello Kernel
[   25.123458] Read 13 bytes from device
[   25.123459] Character device closed
```

Ответы на вопросы

### Базовые понятия:

1. Что такое модуль ядра и зачем он нужен?

Модуль ядра - это фрагмент кода, который может быть динамически загружен и выгружен из ядра Linux во время работы системы. Он нужен для:
Добавления поддержки новых устройств (драйверы)
Реализации файловых систем
Расширения функциональности ядра без перекомпиляции
Экономии памяти (загружаются только нужные модули)

2. Чем отличается kernel-space от user-space?

Kernel-space: привилегированный режим, полный доступ к оборудованию, ошибки приводят к kernel panic, нет стандартной библиотеки C
User-space: непривилегированный режим, ограниченный доступ через системные вызовы, ошибки затрагивают только процесс, есть стандартная библиотека C

3. Что произойдёт, если в модуле обратиться к NULL указателю?

Произойдёт kernel panic - система аварийно остановится с сообщением об ошибке. В отличие от user-space, где обращение к NULL вызывает segmentation fault только в текущем процессе.

4. Почему нельзя использовать printf() в модуле ядра?

printf() является частью стандартной библиотеки C, которая недоступна в kernel-space. Вместо неё используется printk(), которая работает с буфером ядра и не зависит от пользовательских библиотек.

5. Что такое kernel panic и как его избежать?

Kernel panic - это критическая ошибка ядра, приводящая к остановке системы. Чтобы избежать:

Работать в виртуальной машине
Проверять все указатели перед использованием
Использовать правильные функции копирования данных
Освобождать все ресурсы в module_exit()
Тестировать код тщательно перед загрузкой

### Жизненный цикл модуля:

6. Какие функции вызываются при insmod и rmmod?

При insmod: вызывается функция, зарегистрированная через module_init()
При rmmod: вызывается функция, зарегистрированная через module_exit()
7. Что должна делать функция module_exit()?
   
Должна освобождать все ресурсы, выделенные в module_init():

Освобождать память (kfree)
Отменять регистрации устройств, /proc файлов
Закрывать открытые ресурсы
Восстанавливать исходное состояние системы
8. Что происходит, если module_init() возвращает ошибку?
   
Модуль не загружается, функция module_exit() не вызывается. Все ресурсы, выделенные до момента ошибки, должны быть освобождены вручную перед возвратом ошибки.

9. Можно ли выгрузить модуль, если он используется?
   
Нет, при попытке выгрузки используемого модуля команда rmmod вернёт ошибку "Module is in use". Необходимо сначала закрыть все процессы, использующие модуль.

### Логирование и отладка:

10. Чем printk() отличается от printf()?

printk() выводит в буфер ядра, printf() - в stdout
printk() имеет уровни логирования (KERN_INFO, KERN_ERR и т.д.)
printk() может работать в любом контексте, даже когда система почти упала
Вывод printk() просматривается через dmesg, а не напрямую в терминале
11. Какие уровни логирования существуют в ядре?

KERN_EMERG (0) - аварийные сообщения
KERN_ALERT (1) - сообщения, требующие немедленных действий
KERN_CRIT (2) - критические условия
KERN_ERR (3) - ошибки
KERN_WARNING (4) - предупреждения
KERN_NOTICE (5) - важные уведомления
KERN_INFO (6) - информационные сообщения
KERN_DEBUG (7) - отладочные сообщения

12. Как посмотреть логи модуля?
```
dmesg | tail -20              # последние 20 сообщений
dmesg | grep "module_name"    # фильтрация по имени модуля
dmesg -w                      # просмотр в реальном времени
journalctl -k                 # через systemd journal
```

13. Что означает "tainted kernel"?
    
"Tainted kernel" означает, что ядро было "испорчено" загрузкой неподписанных или проприетарных модулей. Это влияет на отладку - разработчики ядра могут отказаться анализировать проблемы на таких системах.

###  Память:

14. Чем kmalloc() отличается от malloc()?

kmalloc() выделяет физически непрерывную память в kernel-space
malloc() выделяет виртуальную память в user-space
kmalloc() не может использовать swap
kmalloc() требует указания флагов GFP (Get Free Pages)
15. Что такое флаги GFP и зачем они нужны?
    
Флаги GFP определяют поведение при выделении памяти:

GFP_KERNEL - обычное выделение (может спать)
GFP_ATOMIC - атомарное выделение (не может спать, для обработчиков прерываний)
GFP_USER - для пользовательских данных
GFP_DMA - для DMA-совместимой памяти
16. Что произойдёт, если не освободить память в module_exit()?
    
Произойдёт утечка памяти - выделенная память будет потеряна до перезагрузки системы. В ядре нет garbage collector, поэтому ответственность за управление памятью полностью на разработчике.

17. Почему нельзя использовать user-space указатели напрямую в ядре?
    
User-space указатели работают в виртуальном адресном пространстве процесса, которое недоступно в kernel-space. Прямое использование таких указателей вызовет kernel panic. Необходимо использовать copy_from_user() и copy_to_user().

### Взаимодействие с user-space:

18. Что такое /proc и для чего он используется?
    
/proc - виртуальная файловая система, предоставляющая интерфейс для получения информации о системе и процессах, а также для взаимодействия с ядром. Примеры: /proc/cpuinfo, /proc/meminfo.

19. Что такое /sys (sysfs) и чем отличается от procfs?
    
/sys - виртуальная ФС для экспорта информации об устройствах и драйверах. Отличия от procfs:

Иерархическая структура, отражающая устройство системы
Один файл = одно значение
Используется для конфигурации устройств
Более структурированный подход
20. Зачем нужны функции copy_to_user() и copy_from_user()?
    
Эти функции обеспечивают безопасное копирование данных между kernel-space и user-space, проверяя валидность указателей и обрабатывая особенности архитектуры. Они предотвращают kernel panic при работе с пользовательскими данными.

21. Что такое character device и как он работает?
    
Character device - это устройство, с которым можно работать как с потоком байтов (последовательно). Примеры: /dev/null, /dev/random. Работает через регистрацию структур file_operations с реализацией операций open, read, write, release.

### Параметры и метаданные:

22. Как передать параметры модулю при загрузке?
```
sudo insmod module.ko param1=value1 param2=value2
```
В коде модуля параметры объявляются через module_param() и соответствующие переменные.

23. Зачем нужен MODULE_LICENSE()?
    
Указывает лицензию модуля. Без правильной лицензии (например, "GPL") ядро пометит себя как "tainted", и некоторые функции ядра будут недоступны.

24. Что произойдёт, если не указать лицензию?
    
Модуль будет работать, но ядро пометит себя как "tainted", что может ограничить доступ к некоторым API и затруднить отладку со стороны разработчиков ядра.

### Безопасность:

25. Какие основные правила безопасного кода в ядре?

Всегда проверять возвращаемые значения
Освобождать все ресурсы в module_exit()
Использовать правильные функции копирования данных
Проверять границы массивов и буферов
Избегать бесконечных циклов
Работать в виртуальной машине

26. Можно ли использовать бесконечный цикл в модуле?
    
Не рекомендуется, особенно в обработчиках прерываний. Бесконечный цикл может заблокировать систему. Если необходим цикл, нужно предусмотреть условие выхода.

27. Почему в ядре нет FPU операций?
    
Операции с плавающей точкой требуют сохранения/восстановления состояния FPU, что дорого и не всегда безопасно в контексте ядра. Вместо них используют fixed-point arithmetic или целочисленные вычисления.

28. Что делать, если модуль вызвал kernel panic?

Не паниковать
Перезагрузить систему (в VM это безопасно)
Проанализировать логи (если система загрузилась)
Исправить код и повторить тестирование
Использовать отладочные выводы для локализации проблемы

### Практические вопросы:

29. Как узнать, какие модули загружены в системе?
```
lsmod                    # список загруженных модулей
cat /proc/modules        # детальная информация
ls /sys/module/          # через sysfs
```

30. Как получить информацию о модуле (версия, параметры)?
```
modinfo module_name      # информация о модуле
modinfo module.ko        # информация из файла .ko
cat /sys/module/module_name/parameters/*  # параметры модуля
```