# Отчёт по лабораторной работе №5: Динамические модули ядра Linux

**Студент:** Залещенок Евгений  
**Группа:** 1  
**Подгруппа:** 1  
**Вариант:** 1 (Нечётный)  
**Среда разработки:** Виртуальная машина (Ubuntu 24.04)

---

## 1. Цели и задачи

Основная цель лабораторной работы — получение практических навыков разработки, сборки и отладки динамических модулей для ядра Linux. Задачи включали в себя изучение архитектуры ядра, освоение механизмов взаимодействия между пространством ядра (Kernel Space) и пространством пользователя (User Space) через параметры модуля, файловую систему `/proc` и создание символьного устройства (`character device`).

## 2. Реализация и верификация

### 2.1. Задание A: Модуль приветствия с параметром

**Описание:** Разработан базовый модуль `hello_module`, который выводит приветствие в журнал ядра при загрузке. С помощью макроса `module_param` реализована возможность передавать собственное сообщение через параметр `message` при загрузке модуля командой `insmod`.

| Действие | Команда в терминале | Результат в `dmesg` |
| :--- | :--- | :--- |
| Загрузка (по умолчанию) | `sudo insmod hello_module.ko` | `[timestamp] Hello from Zhenya module!` |
| Выгрузка | `sudo rmmod hello_module` | `[timestamp] Goodbye from Zhenya module!` |
| Загрузка с параметром | `sudo insmod hello_module.ko message="Custom test"` | `[timestamp] Custom test` |

**Фрагмент журнала ядра (`dmesg`):**
```plaintext
[ 2108.086789] Hello from Zhenya module!
[ 2115.341256] Goodbye from Zhenya module!
[ 2120.118901] Custom test
[ 2125.983411] Goodbye from Zhenya module!
```**Вывод:** Модуль корректно обрабатывает как дефолтное состояние, так и переданные параметры.

### 2.2. Задание B: Файл `/proc/student_info` со счётчиком

**Описание:** Создан модуль `proc_module`, который регистрирует в файловой системе `/proc` файл `student_info`. Файл доступен только для чтения и содержит информацию о студенте, времени загрузки модуля в `jiffies` и атомарный счётчик количества обращений к файлу.

**Тестирование функциональности:**

| Операция | Команда | Вывод в терминале |
| :--- | :--- | :--- |
| Проверка создания | `ls -l /proc/student_info` | Показывает наличие файла и права `-r--r--r--`. |
| Первое чтение | `cat /proc/student_info` | `... Read count: 1` |
| Второе чтение | `cat /proc/student_info` | `... Read count: 2` |
| Проверка удаления | `sudo rmmod proc_module && ls /proc/student_info` | `ls: cannot access ... No such file or directory` |

**Пример вывода `cat /proc/student_info`:**
```plaintext
Name: Zhenya
Group: 1, Subgroup: 1
Module loaded at: 345678 jiffies
Read count: 1```
**Вывод:** Модуль успешно создаёт и удаляет файл, а логика счётчика работает корректно, инкрементируя значение при каждом чтении.

### 2.3. Задание C: Символьное устройство `/dev/mychardev`

**Описание:** Реализован модуль `char_device`, который регистрирует в системе символьное устройство `/dev/mychardev`. Устройство использует буфер в памяти ядра (1024 байта) для хранения данных, полученных от пользователя. Для работы с устройством реализованы функции `open`, `release`, `read` и `write`.

**Верификация работы устройства:**

| Действие | Команда | Результат / Лог `dmesg` |
| :--- | :--- | :--- |
| Загрузка и проверка | `sudo insmod char_device.ko && ls -l /dev/mychardev` | Устройство создано. dmesg: `mychardev: Module loaded. Major: 240` |
| Установка прав | `sudo chmod 666 /dev/mychardev` | Права изменены на `crw-rw-rw-`, что позволяет запись. |
| Запись данных | `echo "Test data" > /dev/mychardev` | dmesg: `Device opened`, `Wrote 10 bytes`, `Device closed` |
| Чтение данных | `cat /dev/mychardev` | Вывод в терминале: `Test data` |
| Проверка логов | `sudo dmesg` | В логах видна полная сессия: `open`, `write`, `close`, `open`, `read`, `close`. |

**Вывод:** Модуль корректно регистрирует символьное устройство, а реализованные файловые операции позволяют безопасно обмениваться данными между ядром и пользовательским пространством.

---

## 3. Теоретические основы (Контрольные вопросы)

### 3.1. Архитектура и безопасность

*   **Что такое модуль ядра и зачем он нужен?**  
    Модуль ядра — это скомпилированный объектный код, который можно динамически загружать и выгружать из работающего ядра ОС. Это позволяет расширять функциональность системы (добавлять поддержку нового оборудования, файловых систем) без необходимости её полной перекомпиляции и перезагрузки.

*   **Чем отличается kernel-space от user-space?**  
    **Kernel-space** — это область памяти, где исполняется ядро. Код здесь работает в привилегированном режиме с неограниченным доступом к аппаратуре. **User-space** — это изолированная область памяти для пользовательских приложений. Программы здесь имеют ограниченные права и взаимодействуют с ядром через системные вызовы. Ошибка в user-space приведёт к падению программы, а в kernel-space — к краху всей системы (Kernel Panic).

*   **Что произойдёт, если в модуле обратиться к NULL указателю?**  
    Это вызовет немедленный **Kernel Panic**. В пространстве ядра нет механизмов защиты памяти, как в user-space, поэтому разыменование нулевого или невалидного указателя является критической, невосстановимой ошибкой.

*   **Почему нельзя использовать `printf()` в модуле ядра?**  
    Функция `printf()` является частью стандартной библиотеки C (`libc`), которая недоступна в пространстве ядра. Вместо неё используется функция `printk()`, которая записывает сообщения в специальный кольцевой буфер ядра, откуда их можно прочитать с помощью утилиты `dmesg`.

*   **Что такое kernel panic и как его избежать?**  
    **Kernel Panic** — это критическая ошибка ядра, при которой система не может продолжать безопасную работу и останавливается. Чтобы его избежать, необходимо: всегда проверять возвращаемые значения функций (особенно выделяющих память), никогда не доверять данным от пользователя, использовать безопасные API (`copy_from_user`), работать в виртуальной машине и тщательно тестировать код.

### 3.2. Жизненный цикл модуля

*   **Какие функции вызываются при `insmod` и `rmmod`?**  
    При `insmod` вызывается функция, зарегистрированная макросом `module_init()`. При `rmmod` вызывается функция, зарегистрированная макросом `module_exit()`.

*   **Что должна делать функция `module_exit()`?**  
    Она должна выполнить полную очистку: освободить всю выделенную память (`kfree`), отменить регистрацию устройств (`unregister_chrdev_region`, `cdev_del`), удалить файлы из `/proc` (`proc_remove`) и отменить любые другие действия, выполненные в функции `init`.

*   **Что происходит, если `module_init()` возвращает ошибку?**  
    Если `module_init()` возвращает любое отрицательное значение, загрузка модуля прерывается, и он не будет добавлен в систему. Важно, что `module_exit()` в этом случае **не вызывается**. Поэтому функция `init` должна сама позаботиться об освобождении всех ресурсов, которые она успела выделить до момента возникновения ошибки.

*   **Можно ли выгрузить модуль, если он используется?**  
    Нет. Ядро отслеживает счётчик использования модуля. Если он больше нуля (например, открыт файл устройства, созданного модулем), команда `rmmod` завершится ошибкой `Device or resource busy`.

### 3.3. Логирование и отладка

*   **Чем `printk()` отличается от `printf()`?**  
    `printf()` выводит данные в стандартный поток вывода (stdout) и является частью `libc`. `printk()` записывает данные в кольцевой буфер ядра, не зависит от `libc` и поддерживает уровни логирования для фильтрации сообщений.

*   **Какие уровни логирования существуют в ядре?**  
    Существует 8 уровней, от `KERN_EMERG` (чрезвычайная ситуация) до `KERN_DEBUG` (отладочная информация), которые позволяют классифицировать важность сообщений.

*   **Как посмотреть логи модуля?**  
    Основной способ — использовать команду `dmesg`. Также логи ядра можно найти в системных журналах, например, через `journalctl -k` или в файле `/var/log/kern.log`.

*   **Что означает "tainted kernel"?**  
    Это статус, который присваивается ядру, если в него был загружен модуль без GPL-совместимой лицензии (например, проприетарный драйвер). Это служит предупреждением, что система была модифицирована, и её стабильность не гарантируется.

### 3.4. Память

*   **Чем `kmalloc()` отличается от `malloc()`?**  
    `kmalloc()` работает в пространстве ядра и выделяет физически непрерывные блоки памяти. `malloc()` работает в пространстве пользователя и выделяет виртуальную память, которая может быть физически фрагментирована.

*   **Что такое флаги GFP и зачем они нужны?**  
    Флаги GFP (Get Free Pages) управляют поведением `kmalloc`. Например, `GFP_KERNEL` позволяет процессу "уснуть" в ожидании свободной памяти, а `GFP_ATOMIC` гарантирует, что выделение не будет блокироваться (это критично для обработчиков прерываний).

*   **Что произойдёт, если не освободить память в `module_exit()`?**  
    Произойдёт **утечка памяти**. Память останется занятой и недоступной для остальной системы до следующей перезагрузки, так как в ядре нет автоматического сборщика мусора.

*   **Почему нельзя использовать user-space указатели напрямую в ядре?**  
    Это грубое нарушение безопасности. Указатель из user-space может быть невалидным, указывать на другую программу или даже на само ядро. Для безопасного доступа к таким данным необходимо использовать функции `copy_to_user()` и `copy_from_user()`.

### 3.5. Взаимодействие с user-space

*   **Что такое `/proc` и для чего он используется?**  
    Это виртуальная файловая система, которая предоставляет удобный текстовый интерфейс для просмотра и изменения параметров ядра "на лету". Она идеально подходит для экспорта статистики и данных о состоянии системы.

*   **Что такое `/sys` (sysfs) и чем отличается от procfs?**  
    Sysfs — это более современная и структурированная файловая система, отражающая иерархию устройств в системе. В отличие от `/proc`, где один файл может содержать много информации, в `/sys` действует правило "один файл — одно значение".

*   **Зачем нужны функции `copy_to_user()` и `copy_from_user()`?**  
    Они обеспечивают безопасное копирование данных между пространством ядра и пространством пользователя. Эти функции не только копируют байты, но и проверяют, что пользовательский указатель валиден и указывает на память, доступную данному процессу.

*   **Что такое character device и как он работает?**  
    Это тип файла устройства, который предоставляет неструктурированный, последовательный доступ к данным (подобно потоку байт). Примеры: терминал, последовательный порт. Работа с ним из user-space выглядит как работа с обычным файлом (открытие, чтение, запись).

### 3.6. Параметры и метаданные

*   **Как передать параметры модулю при загрузке?**  
    Параметры объявляются в коде модуля с помощью макроса `module_param()` и передаются в командной строке: `insmod mymodule.ko my_param=value`.

*   **Зачем нужен `MODULE_LICENSE()`?**  
    Этот макрос является обязательным. Он объявляет лицензию модуля. Указание совместимой лицензии, такой как `"GPL"`, предотвращает "заражение" (tainting) ядра и открывает доступ к некоторым функциям, доступным только для GPL-модулей.

---

## 4. Использование искусственного интеллекта (ИИ) в работе

В процессе выполнения данной лабораторной работы активно использовался большой языковой модель (LLM) ассистент Gemini в качестве инструмента для ускорения разработки и решения возникающих проблем.

Роль ИИ заключалась в следующем:

*   **Генерация шаблонного кода:** ИИ был использован для создания первоначальных «скелетов» кода для всех трех модулей на основе текстового описания заданий. Это позволило сократить время на написание стандартных конструкций (`module_init`, `module_exit`, метаданные) и сосредоточиться на основной логике.

*   **Анализ и исправление ошибок компиляции:** На начальном этапе возникли проблемы со сборкой модулей из-за неверной структуры `Makefile` и расположения файлов. ИИ проанализировал логи ошибок, предоставленные в виде скриншотов, точно определил причину проблемы и предложил несколько вариантов решения, включая реструктуризацию проекта до плоской структуры, которая в итоге и была использована.

*   **Интерпретация ошибок времени выполнения:** ИИ помог объяснить причины распространенных ошибок, таких как `File exists` (попытка повторной загрузки модуля), `Permission denied` (необходимость использования `sudo` или изменения прав через `chmod`), и `Operation not permitted` (необходимость `sudo` для `dmesg`).

*   **Структурирование и написание отчета:** Ассистент был использован для форматирования отчета в Markdown, адаптации предоставленного шаблона под выполненный вариант работы и переформулирования ответов на теоретические вопросы для улучшения ясности и стиля изложения.

Таким образом, ИИ выступил в роли интерактивного наставника и инструмента отладки. Его применение не заменило необходимость понимания ключевых концепций разработки модулей ядра, но значительно ускорило процесс, позволив быстро преодолевать технические трудности и концентрироваться на изучении самих Kernel API и правил безопасного программирования в ядре.

---

## 5. Выводы

В ходе выполнения лабораторной работы были успешно решены все поставленные задачи для Варианта 1. Разработанные модули скомпилированы и протестированы в виртуальной среде, продемонстрировав корректную работу.
*   Получены практические навыки создания, сборки и управления жизненным циклом модулей ядра.
*   Реализованы основные механизмы взаимодействия с User-space: передача параметров при загрузке, экспорт данных через `/proc` и создание полноценного символьного устройства в `/dev`.
*   На практике освоены фундаментальные правила безопасного программирования в Kernel-space, включая обработку пользовательских данных и управление системными ресурсами.
*   Закреплены теоретические знания об архитектуре ОС Linux, управлении памятью и процессах отладки кода ядра.

