# Отчет по лабораторной работе №5

**Студент:** Богук Дарья
**Вариант:** 1 (1 по списку)


## Результаты выполнения

### Задание A: Hello World модуль

**Код:** `src/hello_module.c`

**Тестирование:**
```bash
sudo insmod hello_module.ko
dmesg | tail -1
# [  425.549488] hello_module: Hello from Boguk_Darya module!

sudo rmmod hello_module  
dmesg | tail -1
# [  487.335912] hello_module: Goodbye from Boguk_Darya module!

sudo insmod hello_module.ko message="Ho-ho-ho"
dmesg | tail -1
# [  638.597287] hello_module: Ho-ho-ho
```

**Результат:**
Модуль корректно загружается/выгружается, поддерживает параметры.  


### Задание B: /proc файл

**Код:** `src/proc_module.c`
**Тестирование:**
```bash
sudo insmod proc_module.ko
ls -la /proc/student_info
# -r--r--r-- 1 root root 0 Nov 11 16:44 /proc/student_info

cat /proc/student_info
# Name: Boguk Darya
# Group: 1, Subgroup: 1
# Module loaded at: 4295080536 jiffies
# Read count: 1

cat /proc/student_info
# Name: Boguk Darya
# Group: 1, Subgroup: 1
# Module loaded at: 4295080536 jiffies
# Read count: 2 (счётчик увеличивается)

```
**Результат:**
Файл создаётся в /proc, информация отображается корректно, счётчик работает.

### Задание C: Character device

**Код:** `src/char_device.c`
**Тестирование:**
```bash
sudo insmod char_device.ko
# chardev: Registered with major number 237

sudo mknod /dev/mychardev c 237 0
sudo chmod 666 /dev/mychardev

echo "HO-HO-HO" > /dev/mychardev
cat /dev/mychardev
# HO-HO-HO

dmesg | tail -3
# chardev: Device opened
# chardev: Write 9 bytes
# chardev: Device closed
```
**Результат:**
Устройство работает, данные сохраняются и читаются, логируются операции.


## Ответы на вопросы

### Базовые понятия

#### 1. Что такое модуль ядра и зачем он нужен?

Модуль ядра - это фрагмент кода, который может быть динамически загружен и выгружен из ядра Linux во время работы системы без необходимости перезагрузки.  
Модули нужны для:

- Добавления драйверов
- Расширения функциональности ядра
- Экономии памяти
- Упрощения разработки и отладки

#### 2. Чем отличается kernel-space от user-space?

- **Kernel-space**: Привилегированный режим, полный доступ к оборудованию, сбой приводит к панике ядра (kernel panic). Использует API ядра.
- **User-space**: Непривилегированный режим, доступ к ресурсам через системные вызовы, сбой затрагивает только процесс.

#### 3. Что произойдёт, если в модуле обратиться к NULL указателю?

В модуле вызовет исключение в ядре, что приведет к kernel panic и аварийной остановке системы.

#### 4. Почему нельзя использовать printf() в модуле ядра?
`printf()` - это функция стандартной библиотеки C, которая:

- Работает только в user-space
- Использует файловые дескрипторы и системы ввода-вывода user-space
- Недоступна в контексте ядра

Вместо этого используется `printk()` - аналог для kernel-space.

#### 5. Что такое kernel panic и как его избежать?

**Kernel panic** - это неисправимая ошибка ядра, приводящая к остановке системы. Чтобы избежать: проверять указатели перед использованием, проверять возвращаемые значения функций, корректно освобождать ресурсы.

### Жизненный цикл модуля

#### 6. Какие функции вызываются при insmod и rmmod?

- `insmod`: вызывается функция, указанная в `module_init()`
- `rmmod`: вызывается функция, указанная в `module_exit()`

#### 7. Что должна делать функция module_exit()?

Должна освобождать все ресурсы, выделенные модулем (память, номера устройств, записи в /proc).

#### 8. Что происходит, если module_init() возвращает ошибку?

- Модуль не загружается в систему
- Вызывается `module_exit()` для очистки частично инициализированных ресурсов
- `insmod` возвращает код ошибки
- В dmesg появляется сообщение об ошибке

#### 9. Можно ли выгрузить модуль, если он используется?

Нет, нельзя. Ядро отслеживает счетчик использования модуля (`lsmod` показывает колонку "Used by"). Модуль можно выгрузить только когда счетчик равен 0.

### Логирование и отладка

#### 10. Чем printk() отличается от printf()?

- `printk()` работает в kernel-space, `printf()` в user-space
- `printk()` использует уровни логирования (KERN_INFO, KERN_ERR, etc.)
- `printk()` записывает в кольцевой буфер ядра, доступный через dmesg
- `printk()` может вызываться из любого контекста ядра

#### 11. Какие уровни логирования существуют в ядре?

- `KERN_EMERG` (0) - система неработоспособна
- `KERN_ALERT` (1) - необходимо немедленное вмешательство
- `KERN_CRIT` (2) - критические условия
- `KERN_ERR` (3) - ошибки
- `KERN_WARNING` (4) - предупреждения
- `KERN_NOTICE` (5) - нормальные, но значимые события
- `KERN_INFO` (6) - информационные сообщения
- `KERN_DEBUG` (7) - отладочные сообщения

#### 12. Как посмотреть логи модуля?

```bash
dmesg | tail                    # последние сообщения
dmesg | grep module_name        # фильтр по имени модуля
journalctl -k                   # через systemd
cat /var/log/kern.log          # лог-файл ядра
```

#### 13. Что означает "tainted kernel"?

Флаг, указывающий, что ядро загрузило проприетарный модуль, модуль без лицензии или модуль, загруженный принудительно. Это может ограничить поддержку при отладке.

### Память

#### 14. Чем kmalloc() отличается от malloc()?

- `kmalloc()` выделяет физически непрерывную память в kernel-space, `malloc()` в user-space
- `kmalloc()` использует флаги GFP для управления выделением
- `kmalloc()` может вызываться из контекста прерывания (с определенными флагами)

#### 15. Что такое флаги GFP и зачем они нужны?

GFP (Get Free Page) определяют контекст и приоритет выделения памяти:

- `GFP_KERNEL` — стандартное выделение, может спать.
- `GFP_ATOMIC` — для атомарных контекстов (например, в прерываниях), не спит.
- `GFP_USER` - выделение для пользовательских данных.
- `GFP_DMA` - память, доступная для DMA.

#### 16. Что произойдёт, если не освободить память в module_exit()?

- Утечка памяти ядра
- Память останется занятой до перезагрузки системы
- Возможная нестабильность системы
- Сообщения в логах о неосвобожденной памяти

#### 17. Почему нельзя использовать user-space указатели напрямую в ядре?

Указатели user-space нельзя использовать напрямую в ядре, так как они являются виртуальными адресами в адресном пространстве пользовательского процесса и могут быть невалидными или недоступными в контексте ядра. Для работы с ними используются функции copy_from_user() и copy_to_user().

### Взаимодействие с user-space

#### 18. Что такое /proc и для чего он используется?

`/proc` - виртуальная файловая система для предоставления информации о системе и процессах, а также для простого взаимодействия с модулями ядра.

#### 19. Что такое /sys (sysfs) и чем отличается от procfs?

`/sys` (sysfs) - файловая система для экспорта информации об устройствах и драйверах:

- Структурированное представление устройств
- Один параметр на файл (в отличие от `/proc`)

#### 20. Зачем нужны функции copy_to_user() и copy_from_user()?

Эти функции обеспечивают безопасное копирование данных между kernel-space и user-space:

- Проверяют валидность адресов user-space
- Обрабатывают page fault
- Корректно работают с виртуальной памятью

#### 21. Что такое character device и как он работает?

Character device — это устройство, с которым можно работать как с потоком байтов (например, /dev/ttyS0). Модуль регистрирует операции с устройством (open, read, write, release) через структуру file_operations.

### Параметры и метаданные

#### 22. Как передать параметры модулю при загрузке?

Параметры модулю передаются при загрузке: 
`insmod module.ko param_name=value`. 
Внутри модуля они объявляются с помощью `module_param()`.

#### 23. Зачем нужен MODULE_LICENSE()?

Необходим для указания лицензии модуля. Модули без лицензии GPL помечают ядро как "tainted" и не имеют доступа к некоторым символам (функциям) ядра, экспортируемым только для GPL-модулей.

#### 24. Что произойдёт, если не указать лицензию?

Если не указать лицензию, ядро пометит себя как "tainted", что может осложнить получение поддержки при отладке проблем.

### Безопасность

#### 25. Какие основные правила безопасного кода в ядре?

- Проверять все возвращаемые значения
- Использовать безопасные функции копирования
- Правильно управлять памятью
- Избегать бесконечных циклов
- Проверять границы буферов
- Корректно обрабатывать ошибки

#### 26. Можно ли использовать бесконечный цикл в модуле?

Бесконечный цикл в модуле может полностью заблокировать ядро, особенно если он выполняется в атомарном контексте или с отключенными прерываниями.

#### 27. Почему в ядре нет FPU операций?

FPU операции в ядре не используются, потому что контекст ядра не сохраняет и не восстанавливает состояние FPU по умолчанию для производительности. Это ложится на пользовательские процессы.

#### 28. Что делать, если модуль вызвал kernel panic?

- Перезагрузить систему
- Проанализировать стек трейс в логах
- Исправить ошибку в коде
- Тестировать в виртуальной машине
- Использовать отладчики (kgdb, kdump)

### Практические вопросы

#### 29. Как узнать, какие модули загружены в системе?

```bash
lsmod                    # список загруженных модулей
cat /proc/modules        # подробная информация
modinfo module_name      # информация о конкретном модуле
```

#### 30. Как получить информацию о модуле (версия, параметры)?

```bash
modinfo module.ko                    # информация о файле модуля
cat /sys/module/module_name/version  # версия загруженного модуля
ls /sys/module/module_name/parameters/  # параметры модуля
```

## Использование AI
Корректное написание и форматирование файлов-отчётов, помощь в решении возникающих ошибок