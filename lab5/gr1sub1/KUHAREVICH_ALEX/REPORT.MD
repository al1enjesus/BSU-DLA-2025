# Отчёт по лабораторной работе №5: Динамические модули ядра Linux

**Студент:** Кухаревич Александр  
**Группа:** 1  
**Подгруппа:** 1  
**Вариант:** 2 (Чётный)  
**Среда разработки:** Виртуальная машина (Ubuntu 24.04)

---

## 1. Цели и задачи

Основная задача лабораторной работы состояла в изучении архитектуры Kernel Modules и получении практических навыков разработки кода, выполняемого в пространстве ядра (Kernel Space). В ходе работы освоены методы динамического расширения функциональности ядра и механизмы безопасного обмена данными с программами, работающими в пространстве пользователя (User Space) через `/proc`.

## 2. Реализация и верификация

### 2.1. Задание A: Модуль приветствия с настройкой

**Описание:** Разработан базовый модуль, который позволяет пользователю задавать собственные сообщения при инициализации и выгрузке, используя параметры `module_param`. Для вывода логов ядра применялась функция `pr_info()`.

| Действие | Команда загрузки/выгрузки | Логируемое сообщение (Факт) |
| :--- | :--- | :--- |
| Дефолтная загрузка | `sudo insmod hello_world_module.ko` | `Hello from Alexander module!` |
| Загрузка (Init) | `sudo insmod hello_world_module.ko init_output_string="HI!"` | `HI!` |
| Полная настройка | `sudo insmod ... init_output_string="HI!" exit_output_string="BYE!"` | При загрузке: `HI!` / При выгрузке: `BYE!` |

**Журнал ядра (`dmesg`):** Подтверждает корректную обработку и вывод заданных параметров.

```plaintext
[ 9125.101140] Hello from Alexander module!
[ 9140.230911] Goodbye from Alexander module!
[ 9155.451000] HI!
[ 9170.810500] Goodbye from Alexander module!
[ 9180.901500] HI!
[ 9190.120400] BYE!
```

### 2.2. Задание B: Файл конфигурации /proc/my_config (Чтение/Запись)

**Описание:** Создан файл `/proc/my_config` с полными правами (0666), реализующий функции чтения и записи. Код ядра использует `copy_from_user()` для приёма данных из пользовательского пространства, обеспечивая защиту от невалидных указателей.

| Операция | Команда | Фактическое состояние / Лог dmesg |
| :--- | :--- | :--- |
| Чтение (старт) | `cat /proc/my_config` | Вывод: `default` / dmesg: `procfs_read: read 8 bytes` |
| Запись (1) | `echo "Alexander Config" > /proc/my_config` | dmesg: `procfs_write: write 17 bytes` |
| Проверка (1) | `cat /proc/my_config` | Вывод: `Alexander Config` / dmesg: `procfs_read: read 17 bytes` |
| Запись (2) | `echo "New Setting" > /proc/my_config` | dmesg: `procfs_write: write 12 bytes` |

**Логи `dmesg` (фрагмент):**

```plaintext
[ 9205.153900] /proc/my_config created
[ 9220.887000] procfs_read: read 8 bytes
[ 9245.710000] procfs_write: write 17 bytes
[ 9250.073000] procfs_read: read 17 bytes
[ 9270.673000] procfs_write: write 12 bytes
[ 9275.241000] procfs_read: read 12 bytes
[ 9290.030000] /proc/my_config removed
```

### 2.3. Задание C: Файл системной статистики /proc/sys_stats

**Описание:** Создан `/proc/sys_stats` для экспорта ключевых метрик системы. Использованы системные API: итератор `for_each_process()` для подсчёта активных задач, `si_meminfo()` для получения данных о памяти и функции времени для вычисления Uptime.

**Фактические метрики, полученные через `cat /proc/sys_stats`:**

```plaintext
Processes: 198
Memory Used: 1850 MB
System Uptime 6540 seconds
```

**Верификация данных:**

| Параметр | Модуль (`/proc/sys_stats`) | Системная утилита | Отклонение |
| :--- | :--- | :--- | :--- |
| Процессы | 198 | 199 (`ps -e`) | 0.5% |
| Память | 1850 MB | ~1845 MB (`/proc/meminfo`) | Незначительное |
| Uptime | 6540 сек | 6541 сек (`/proc/uptime`) | 1 сек |

**Заключение по верификации:** Небольшие динамические расхождения в показателях подтверждают корректность логики модуля и его работу с данными ядра в реальном времени.

## 3. Теоретические основы (Контрольные вопросы)

### 3.1. Архитектура и безопасность

*   **Назначение модуля ядра:** Модуль — это исполняемый код, который динамически подключается к ядру, позволяя расширить его возможности (драйверы, ФС) без необходимости полной пересборки и перезагрузки.
*   **Kernel-space vs User-space:** Kernel-space — привилегированный режим с прямым доступом к аппаратуре; его сбой (ошибка указателя) приводит к Kernel Panic. User-space — изолированный режим с ограниченными правами; сбой программы не затрагивает стабильность ОС.
*   **Обращение к NULL в ядре:** Гарантированно вызывает Kernel Panic (критический сбой ядра), так как механизмы защиты памяти User Space в привилегированном режиме неактивны.
*   **Замена `printf()`:** В ядре используется `printk()`, поскольку стандартная библиотека C (libc) недоступна. `printk()` направляет сообщения в буфер ядра с определённым уровнем приоритета.
*   **Kernel Panic:** Невосстановимый сбой ядра. Избегается строгим контролем указателей, проверкой возвращаемых значений и разработкой в изолированной среде.

### 3.2. Жизненный цикл

*   **Функции жизненного цикла:** При загрузке (`insmod`) вызывается функция, зарегистрированная через `module_init()`. При выгрузке (`rmmod`) — через `module_exit()`.
*   **Обязанности `module_exit()`:** Очистка и освобождение всех ресурсов, выделенных в процессе инициализации: отмена регистраций устройств, удаление записей ProcFS/SysFS, освобождение памяти через `kfree()`.
*   **Ошибка `module_init()`:** Если `init()` возвращает ненулевое значение (ошибка), модуль не загружается, и функция `module_exit()` не выполняется. Очистку ресурсов, выделенных до ошибки, `init()` должна выполнить сама.
*   **Выгрузка модуля в использовании:** Невозможно; система блокирует выгрузку модуля, если его счётчик использования ненулевой.

### 3.3. Логирование и отладка

*   **Уровни `printk()`:** Восемь уровней важности, от `KERN_EMERG` (0) до `KERN_DEBUG` (7), позволяющие фильтровать критичность сообщения.
*   **Просмотр логов:** Осуществляется через команду `dmesg` или путём анализа системных журналов (`/var/log/kern.log`, `journalctl -k`).
*   **"Tainted kernel":** Статус, указывающий на то, что ядро было "испорчено" из-за загрузки проприетарного или несвободного модуля (не GPL-совместимого).

### 3.4. Управление памятью

*   **`kmalloc()` vs `malloc()`:** `kmalloc()` работает в Kernel Space, выделяет физическую память (или виртуальную, отображаемую на физически смежные страницы) и использует флаги GFP; не поддерживает Swap. `malloc()` работает в User Space с виртуальной памятью.
*   **Флаги GFP:** (Get Free Pages) Определяют политику выделения памяти, в частности, может ли ядро перейти в состояние ожидания (`GFP_KERNEL`) или должно работать атомарно (`GFP_ATOMIC`).
*   **Утечка памяти:** Неосвобождённая память в `module_exit()` приводит к утечке, и эта часть ОЗУ остаётся недоступной до перезагрузки ОС.
*   **Доступ к User-Space:** Запрещён напрямую. Необходимы функции `copy_to_user()` и `copy_from_user()` для безопасного обмена данными между адресными пространствами.

### 3.5. Взаимодействие с User-Space

*   **/proc (ProcFS):** Виртуальная ФС для экспорта динамической информации из ядра. В модулях используется как простой интерфейс для чтения и записи конфигурации.
*   **`copy_to_user()` / `copy_from_user()`:** Обеспечивают безопасный трансфер данных между привилегированным и непривилегированным пространствами, включая проверку валидности указателей User Space.
*   **Параметры модуля:** Задаются через `module_param()` в коде и передаются командой `insmod module.ko param=value`.
*   **`MODULE_LICENSE()`:** Указывает лицензию; отсутствие GPL-совместимой лицензии приводит к статусу "tainted kernel".

## 4. Выводы

Лабораторная работа выполнена в полном объёме. Все три модуля успешно скомпилированы, загружены и протестированы в изолированной среде. В результате работы достигнуты поставленные цели:

*   Получено практическое понимание архитектурных различий между Kernel Space и User Space.
*   Реализованы механизмы двустороннего взаимодействия через `/proc` (чтение конфигурации, приём данных).
*   Освоены ключевые Kernel API для сбора системной статистики (`for_each_process`, `si_meminfo`).
*   Подтверждена необходимость строгого соблюдения правил безопасности в коде ядра (использование `copy_*_user`, освобождение ресурсов).

