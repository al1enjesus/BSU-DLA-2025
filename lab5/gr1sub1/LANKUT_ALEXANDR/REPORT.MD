# Lab 5 - Kernel Modules
## Ланкуть Александр Вячеславович
## Вариант: 2 (чётные номера)

---

## Окружение

- **Docker**: Ubuntu 22.04 LTS с флагом `--privileged`
- **Ядро**: 5.15.133.1
- **GCC**: 11.4.0, Make 4.3
---

## Реализованные модули (Вариант 2)

### Задание A: hello_module.c
**Функция**: Hello World модуль ядра  
**Параметр**: `message` - пользовательское приветствие  
**Использование**:
```bash
sudo insmod src/hello_module.ko
sudo insmod src/hello_module.ko message="Custom text"
dmesg | tail -3
sudo rmmod hello_module
```

### Задание B: proc_module.c
**Функция**: `/proc/my_config` с поддержкой чтения И записи  
**Буфер**: 256 байт, начальное значение "default"  
**Использование**:
```bash
sudo insmod src/proc_module.ko
cat /proc/my_config
echo "new value" > /proc/my_config
cat /proc/my_config
sudo rmmod proc_module
```

### Задание C: sys_stats_module.c
**Функция**: `/proc/sys_stats` со статистикой системы  
**Выводит**: количество процессов, использование памяти, uptime  
**Использование**:
```bash
sudo insmod src/sys_stats_module.ko
cat /proc/sys_stats
cat /proc/sys_stats
sudo rmmod sys_stats_module
```

---

## Компиляция

```bash
cd /root/BSU-DLA-2025/lab5/gr1sub1/LANKUT_ALEXANDR
make check
make
make clean
```

---

## Ответы на 30 вопросов

### Базовые понятия (1-5)

**1. Что такое модуль ядра и зачем он нужен?**  
Динамически загружаемый код, позволяющий расширять функциональность ядра без перезагрузки. Используется для драйверов, файловых систем, протоколов.

**2. Чем отличается kernel-space от user-space?**  
Kernel-space имеет полные привилегии и доступ к памяти напрямую. User-space имеет ограниченный доступ и виртуальную адресацию. Крах в kernel-space = kernel panic.

**3. Что произойдёт, если в модуле обратиться к NULL указателю?**  
Возникнет kernel panic - полный крах системы. В kernel-space нет защиты.

**4. Почему нельзя использовать printf() в модуле ядра?**  
В kernel-space нет libc. Используется printk() для логирования в kernel log (dmesg).

**5. Что такое kernel panic и как его избежать?**  
Необратимое состояние ядра. Избежать: проверять указатели на NULL, использовать copy_to_user/copy_from_user, не делать бесконечные циклы, правильно управлять памятью.

### Жизненный цикл (6-9)

**6. Какие функции вызываются при insmod и rmmod?**  
insmod вызывает module_init(), rmmod вызывает module_exit().

**7. Что должна делать функция module_exit()?**  
Отменить все регистрации, освободить память, удалить /proc файлы и device nodes, вывести информацию о выгрузке.

**8. Что происходит, если module_init() возвращает ошибку?**  
Модуль не загружается, module_exit() не вызывается, пользователь получает ошибку.

**9. Можно ли выгрузить модуль, если он используется?**  
Нет. Нужно закрыть все процессы, использующие модуль.

### Логирование (10-13)

**10. Чем printk() отличается от printf()?**  
printk() выводит в kernel log (dmesg), printf() в stdout. printk() имеет уровни (KERN_INFO, KERN_ERR и т.д.).

**11. Какие уровни логирования существуют в ядре?**  
KERN_EMERG(0), KERN_ALERT(1), KERN_CRIT(2), KERN_ERR(3), KERN_WARNING(4), KERN_NOTICE(5), KERN_INFO(6), KERN_DEBUG(7).

**12. Как посмотреть логи модуля?**  
`dmesg | tail`, `dmesg | grep module_name`, `dmesg -w` (реальное время), `dmesg -T` (с метками времени).

**13. Что означает "tainted kernel"?**  
Ядро загружено с кодом, который может компрометировать стабильность (проприетарные модули, модули без GPL).

### Память (14-17)

**14. Чем kmalloc() отличается от malloc()?**  
kmalloc() работает в kernel-space, возвращает физически смежные страницы. malloc() в user-space, может быть разрозненной.

**15. Что такое флаги GFP и зачем они нужны?**  
GFP (Get Free Pages) - флаги для контроля выделения памяти. GFP_KERNEL (обычное), GFP_ATOMIC (для прерываний), GFP_USER (user-space).

**16. Что произойдёт, если не освободить память в module_exit()?**  
Утечка памяти. В ядре нет garbage collector, память останется выделённой до перезагрузки.

**17. Почему нельзя использовать user-space указатели напрямую в ядре?**  
Они существуют в другом адресном пространстве. Нужно использовать copy_to_user() и copy_from_user().

### Взаимодействие user-space (18-21)

**18. Что такое /proc и для чего он используется?**  
Виртуальная FS для экспорта информации из ядра в user-space. Примеры: /proc/cpuinfo, /proc/meminfo.

**19. Что такое /sys (sysfs) и чем отличается от procfs?**  
/sys - современный интерфейс, упорядоченная иерархия, один параметр = один файл. /proc - исторический, смешанное назначение.

**20. Зачем нужны copy_to_user() и copy_from_user()?**  
Безопасное копирование между kernel и user-space. Проверяют валидность, обрабатывают page faults, предотвращают kernel panic.

**21. Что такое character device и как он работает?**  
Специальное устройство в /dev для read/write операций. Примеры: /dev/null, /dev/random.

### Параметры (22-24)

**22. Как передать параметры модулю при загрузке?**  
`sudo insmod module.ko param1=value1 param2=value2`. В коде: `static int count = 1; module_param(count, int, 0644);`

**23. Зачем нужен MODULE_LICENSE()?**  
Указывает лицензию модуля. Важно для соответствия GPL, предотвращения "tainted kernel", доступа к GPL-only функциям.

**24. Что произойдёт, если не указать лицензию?**  
Ядро помечается как "tainted", некоторые функции недоступны, разработчики могут отказать в поддержке.

### Безопасность (25-28)

**25. Какие основные правила безопасного кода в ядре?**  
1. Проверяйте ВСЕ возвращаемые значения. 2. Освобождайте все ресурсы. 3. Используйте copy_to_user/copy_from_user. 4. Проверяйте границы. 5. Не делайте бесконечные циклы. 6. Правильно копируйте данные.

**26. Можно ли использовать бесконечный цикл в модуле?**  
Нет, категорически. Заблокирует весь CPU.

**27. Почему в ядре нет FPU операций?**  
FPU недоступна в kernel-space для максимальной скорости и надёжности.

**28. Что делать, если модуль вызвал kernel panic?**  
В VM: Force Power Off → restore snapshot. После загрузки: проверить /var/log/kern.log, добавить printk для отладки, использовать addr2line.

### Практические (29-30)

**29. Как узнать, какие модули загружены в системе?**  
`lsmod`, `lsmod | grep my_module`, `cat /proc/modules`.

**30. Как получить информацию о модуле?**  
`modinfo src/hello_module.ko`, `modinfo -p` (параметры), `modinfo -d` (описание).
