# Лабораторная работа 5 — Модули ядра Linux

## Цель работы

Изучение базовой архитектуры ядра Linux, разработка простых модулей ядра, организация взаимодействия с user-space через `/proc` и реализация простого character device.

## Состав сделанных файлов

Проектная папка: `lab5/gr9sub2/PopovaDS/src/`

* `Makefile` — сборка модулей при помощи `KERNEL_DIR=/lib/modules/$(uname -r)/build`.
* `hello_module.c` — модуль "Hello World" с параметром `message`.
* `proc_module.c` — модуль, создающий `/proc/student_info` с информацией и счётчиком обращений.
* `chardev_module.c` — простой character device `/dev/mychardev`, буфер 1024 байта, поддержка read/write.


## Среда подготовки

```bash
sudo apt update
sudo apt install -y build-essential git vim dkms kmod
sudo apt install -y linux-headers-$(uname -r)
uname -r
gcc --version
ls /lib/modules/$(uname -r)/build
```

## Инструкция по сборке и запуску 

1. Сборка модулей:

```bash
cd lab5/gr9sub2/PopovaDS
make
```

2. Hello-module:

```bash
sudo insmod src/hello_module.ko
dmesg | tail -5
sudo rmmod hello_module
```

3. Proc-module:

```bash
sudo insmod src/proc_module.ko
cat /proc/student_info
cat /proc/student_info
sudo rmmod proc_module
```

4. Chardev-module:

```bash
sudo insmod src/chardev_module.ko
# найти major в dmesg
MAJOR=$(dmesg | grep "chardev: Registered" | tail -1 | grep -o "number [0-9]*" | awk '{print $2}')
sudo mknod /dev/mychardev c $MAJOR 0
sudo chmod 666 /dev/mychardev
echo "Hello kernel" > /dev/mychardev
cat /dev/mychardev
sudo rm /dev/mychardev
sudo rmmod chardev_module
```

## Ответы на вопросы

**1. Что такое модуль ядра и зачем он нужен?**
Модуль ядра — отдельный объект (фрагмент кода), который загружается в kernel space во время работы системы. Используется для добавления/удаления функциональности (драйверы, файловые системы, сетевые протоколы) без перекомпиляции и перезагрузки ядра.

**2. Чем отличается kernel-space от user-space?**
Kernel-space — привилегированная область, код имеет полный доступ к аппаратуре и памяти. User-space — ограниченная область, где выполняются приложения; доступ к ресурсам через системные вызовы.

**3. Что произойдёт, если в модуле обратиться к NULL указателю?**
Разыменование NULL в kernel-space приведёт к исключению (oops) и, скорее всего, kernel panic — краху всей системы (в VM может быть перезагрузка).

**4. Почему нельзя использовать `printf()` в модуле ядра?**
`printf()` — часть user-space libc; в kernel-space нет стандартной библиотеки. Для вывода используется `printk()`.

**5. Что такое kernel panic и как его избежать?**
Kernel panic — фатальная ошибка ядра, после которой система останавливается. Избежать можно: аккуратно проверять указатели, не использовать FPU, не делать бесконечных блокирующих циклов, проверять границы буферов, использовать `copy_to_user()`/`copy_from_user()`.

**6. Какие функции вызываются при `insmod` и `rmmod`?**
При `insmod` вызывается функция, зарегистрированная через `module_init()`; при `rmmod` — функция, зарегистрированная через `module_exit()`.

**7. Что должна делать функция `module_exit()`?**
Освободить все ресурсы, зарегистрированные в `module_init()` (освободить память, удалить proc/sysfs записи, удалить cdev, отменить регистрации).

**8. Что происходит, если `module_init()` возвращает ошибку?**
Если `module_init()` возвращает отрицательное значение (ошибка), модуль не загружается, `module_exit()` не вызывается. Нужно самостоятельно освободить уже выделенные ресурсы до возврата ошибки.

**9. Можно ли выгрузить модуль, если он используется?**
Нет. `rmmod` выдаст ошибку `Module is in use`. Перед выгрузкой нужно закрыть все дескрипторы и удалить device nodes.

**10. Чем `printk()` отличается от `printf()`?**
`printk()` пишет в буфер ядра (kernel log), имеет уровни важности (KERN_INFO, KERN_ERR и т.д.), используется в kernel-space. `printf()` работает в user-space и выводит в stdout.

**11. Какие уровни логирования существуют в ядре?**
KERN_EMERG, KERN_ALERT, KERN_CRIT, KERN_ERR, KERN_WARNING, KERN_NOTICE, KERN_INFO, KERN_DEBUG.

**12. Как посмотреть логи модуля?**
`dmesg`, `dmesg -w`, `journalctl -k`, файлы `/var/log/kern.log` (на Debian/Ubuntu).

**13. Что означает "tainted kernel"?**
Tainted — ядро помечено флагом, если загружен проприетарный модуль, произошёл серьезный сбой или используется модуль без правильной лицензии.

**14. Чем `kmalloc()` отличается от `malloc()`?**
`kmalloc()` — аллокация в kernel-space (без libc), использует флаги GFP_*; `malloc()` — user-space аллокация из glibc и может использовать swap.

**15. Что такое флаги GFP и зачем они нужны?**
GFP_* (Get Free Pages) — флаги, указывающие контекст аллокации (GFP_KERNEL — может спать, GFP_ATOMIC — нельзя спать и т.д.). Они помогают ядру выбирать стратегию выделения памяти.

**16. Что произойдёт, если не освободить память в `module_exit()`?**
Утечка памяти в ядре: память не будет возвращена до reboot, может привести к исчерпанию ресурсов.

**17. Почему нельзя использовать user-space указатели напрямую в ядре?**
Потому что адресное пространство отличается; прямой доступ может привести к чтению/записи защищённой памяти и kernel panic. Нужно использовать `copy_to_user()`/`copy_from_user()`.

**18. Что такое `/proc` и для чего он используется?**
Procfs — виртуальная файловая система, предоставляющая интерфейс к kernel-данным (информация о процессах, состоянии системы). Используется для экспорта информации и простых настроек.

**19. Что такое `/sys` (sysfs) и чем отличается от procfs?**
Sysfs — виртуальная ФС, аккуратно экспонирующая объекты ядра (kobjects) и их атрибуты; ориентирована на представление устройств и их свойств, в отличие от procfs, которая более общая и иногда нерегламентирована.

**20. Зачем нужны функции `copy_to_user()` и `copy_from_user()`?**
Они безопасно копируют данные между kernel-space и user-space, обрабатывают проверку доступа и предотвращают недопустимые обращения.

**21. Что такое character device и как он работает?**
Character device — блок абстракции устройства, предоставляющий последовательный поток байтов; взаимодействие через `open`, `read`, `write`, `release`, `ioctl` и т.д.

**22. Как передать параметры модулю при загрузке?**
Через `module_param()` и вызов `insmod module.ko param=value`. Параметры доступны также в `/sys/module/<mod>/parameters/`.

**23. Зачем нужен `MODULE_LICENSE()`?**
Чтобы указать лицензию модуля; если не указать совместимой лицензии (GPL), ядро пометит его как tainted и некоторые символы API могут быть недоступны.

**24. Что произойдёт, если не указать лицензию?**
Ядро пометит модуль как "tainted" (нечистое). В некоторых случаях доступ к GPL-only символам будет закрыт.

**25. Какие основные правила безопасного кода в ядре?**
Проверять все возвращаемые значения, обрабатывать ошибки, освобождать ресурсы в exit, не обращаться к user-space указателям напрямую, не использовать FPU, избегать блокирующих операций в непредназначенных контекстах.

**26. Можно ли использовать бесконечный цикл в модуле?**
Можно только в специальных случаях при корректной обработке (например, в задаче kernel thread с подходящей блокировкой); простые бесконечные циклы в init приведут к зависанию системы.

**27. Почему в ядре нет FPU операций?**
Потому что использование FPU требует сохранения/восстановления состояния процессора, что дорого; ядро старается избегать работы с плавающей запятой.

**28. Что делать, если модуль вызвал kernel panic?**
Перезагрузить VM (восстановить snapshot), проанализировать код, добавить проверки указателей и printk, отладить на тестовой VM.

**29. Как узнать, какие модули загружены в системе?**
`lsmod`, `cat /proc/modules`, `modinfo <module.ko>` для информации о модуле.


## Ошибки, встреченные в процессе и их решение

**Ошибка:** `mkdir: cannot create directory '.tmp_xxx': Permission denied` при `make`.
**Причина:** Неверные отступы/формат команд в Makefile (в командах перед `$(MAKE)` стояли пробелы вместо символа TAB), поэтому kernel build system трактовала папку как поддерево исходников ядра и пыталась создать служебные каталоги.
**Исправление:** заменить начальные пробелы на TAB в строках с командами (или использовать предложенную версию Makefile). После исправления `make` успешно выполнился.

## Выводы

* A: Hello World module — реализовано и протестировано.
* B: `/proc`-модуль — реализовано, счётчик чтений, время загрузки в jiffies.
* C: Character device — реализовано, read/write, защита mutex, буфер 1024 байта.

