# Лабораторная работа №3

# Цель работы
Реализовать свою утилиту pstat, которая извлекает и интерпретирует метрики из /proc
Полученные результаты сопоставить с результатми утилит ps, top, pidstat

# Шаги и команды
1. Создан файл для сборки и запуск makefile, в котором находтся основные команды для сборки, запуска и очистки - build, run, clean
2. Создан файл pstat.c, который считывает нужные нам данные из proc

# Вывод команд
-Наша команда pstat: 
```
darya@darya-IdeaPad-3-15ALC6:~/src1$ make run pid=45172
gcc -Wall -Wextra -std=c99 -o bin/pstat src/pstat.c
./bin/pstat 45172
--- Process statistics for PID 45172 ---
PPid: 45151
Threads: 1
State: R
utime: 475 ticks
stime: 0 ticks
CPU time: 4.75 seconds
voluntary_ctxt_switches: 0
nonvoluntary_ctxt_switches: 685
VmRSS: 3184 kB
RSS MiB: 3.11 MiB
RssAnon: N/A
RssFile: N/A
read_bytes: 0 bytes
write_bytes: 0 bytes
```

-Команда ps - команда для просмотра процессов с нужным нам ввыводом полей
```
darya@darya-IdeaPad-3-15ALC6:~/src1$ ps -o ppid,thcount,state,utime,stime,rss -p 45172
   PPID THCNT S  UTIME STIME   RSS
  45151     1 R      - 15:13  3184
```

-Команда pidstat - команда для более детальной статистики
```
darya@darya-IdeaPad-3-15ALC6:~/src1$ pidstat -p 45172 1 1
Linux 5.15.0-139-generic (darya-IdeaPad-3-15ALC6) 	30.09.2025 	_x86_64_(12 CPU)

15:14:54      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
15:14:55     1000     45172   34,00   64,00    0,00    1,00   98,00     1  bash
Average:     1000     45172   34,00   64,00    0,00    1,00   98,00     -  bash
```
-команда top - команда для мониторинга процессов
```
darya@darya-IdeaPad-3-15ALC6:~/src1$ top -b -n 1 -p 45172
top - 15:15:18 up  2:40,  1 user,  load average: 1,93, 2,66, 3,20
Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s):  4,6 us,  8,0 sy,  0,0 ni, 86,9 id,  0,0 wa,  0,0 hi,  0,6 si,  0,0 st
MiB Mem :  13831,7 total,   5888,8 free,   3210,1 used,   4732,8 buff/cache
MiB Swap:   2048,0 total,   2048,0 free,      0,0 used.  11048,4 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  45172 darya     20   0   14244   3184   1416 R 100,0   0,0   1:19.81 bash
```

# Сравнение
State процесса, PPID, Threads совпадает по всем метрикам
Использование памяти также видно, что читается из одного источника, так как все результаты совпадают - 3184
Анонимная и файловая памяти показаны как N/A, то есть файлы либо недоступны, либо у нас их нет
Так как не было ввода-вывода, то для read/write_bytes 0, что логично
Время использования cpu разнится, наверное связано с тем, что top/ps показывают общее время с момента запуска, а pstat читает текущее из proc
Видны многочисленные недобровольные переключения, что логично для активного процесса, который вытесняется планировщиком

# Ответы на вопросы 
1. Где в /proc/<pid>/stat и /proc/<pid>/status отражаются время в ядре/в юзере и состояние процесса?
* В `/proc/<pid>/stat` в поле 14 `utime` (в тиках) — user time, в  поле 15 `stime` — время в ядре, в поле 3 `state`-состояние процесса (например S или R).
* `/proc/<pid>/status` в поле `State`-состояние процесса
2. Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?
* RSS можно получить из /proc/<pid>/status - строка VmRSS или /proc/<pid>/stat - поле 24 (в страницах)
* Отличие в том, что RssAnon - анонимная память (стеки, куча), а RssFile - файловая память (загруженные исполняемые файлы)
* RssAnon показывает "чистую" память процесса, которую нельзя освободить выгрузкой на диск, тогда как RssFile может быть выгружена и загружена обратно.
3. Как оценить IO‑активность по /proc/<pid>/io и чем она отличается от «ожидания IO» в top/pidstat?
*/proc/pid/io показывает объём данных (сколько байт прочитано/записано), а «ожидание IO» в top — время, которое процесс провёл в ожидании этих операций.
4. Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?
* HZ - это частота системного таймера ядра (тиков в секунду), считать можно с помощью sysconf(_SC_CLK_TCK). Чтобы корректно посчитать нужно использовать не константу, а считать hz всегда у системы.
5. Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?
* причины рассинхрона: временная задержка между чтением разных файлов в /proc, разные алгоритмы усреднения, атомарность чтения - файлы в /proc читаются последовательно
* критично при точных измерениях или при попытки сопоставления мгновенных состояний.

# Выводы
Успешно реализовали утилиту pstat, которая корректно извлекает данные из proc. Сравнение с другими утилитами показало, что реализовано корректно, данные совпадают
