# ОТЧЕТ по лабораторной работе 3
**Тема:** /proc, собственные метрики и диагностика  
**Автор:** Соколов Егор Александрович  
**Группа:** 1, подгруппа: 1  
**Дата:** 30 сентября 2025

## Цель работы
Изучить работу с файловой системой `/proc` для извлечения метрик процессов, реализовать собственную утилиту `pstat` и сравнить её показания с системными утилитами (`ps`, `top`, `pidstat`). Освоить базовые диагностические инструменты `strace` и `perf`.

## Описание выполненной работы

### 1. Реализация утилиты pstat

Утилита `pstat` написана на языке C и читает следующие файлы из `/proc/<pid>/`:
- `/proc/<pid>/stat` - основная статистика процесса
- `/proc/<pid>/status` - детальная информация о состоянии
- `/proc/<pid>/io` - статистика ввода-вывода

#### Основные функции:
- `read_stat()` - парсинг файла stat для получения PID, PPID, состояния, времени выполнения
- `read_status()` - извлечение информации о памяти и переключениях контекста
- `read_io()` - чтение статистики ввода-вывода (с обработкой ошибок доступа)
- `format_size()` - форматирование размеров памяти в КиБ/МиБ

### 2. Структура проекта и сборка

```
src/
├── pstat.c      # Исходный код утилиты
├── Makefile     # Автоматизированная сборка
├── bin/         # Исполняемый файл
└── obj/         # Объектные файлы
```

Сборка осуществляется командой `make all`, что создает исполняемый файл в `bin/pstat`.

### 3. Экспериментальная часть

#### Тестирование на процессе bash (PID 326289)

**Вывод pstat:**
```
Process Statistics for PID 326289:
================================
PPid:                      325976
Threads:                   1
State:                     S
User time (ticks):         0
System time (ticks):       0
CPU time (seconds):        0.00
Voluntary ctx switches:    5
Nonvoluntary ctx switches: 0
VmRSS:                     3.38 MiB (3456 kB)
RssAnon:                   384 KiB (384 kB)
RssFile:                   3.00 MiB (3072 kB)
Read bytes:                0
Write bytes:               49152
```

**Сравнение с ps:**
```
PID    PPID S NLWP  UTIME STIME   RSS    VSZ CMD
326289 325976 S   1      - 16:13  3456   8756 /bin/bash ./run.sh
```

**Сравнение с top:**
```
PID USER  PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
326289 surf 20   0    8756   3456   3072 S   0.0   0.0   0:00.01 run.sh
```

**Сравнение с pidstat:**
```
UID    PID    %usr %system  %guest   %wait    %CPU   CPU  Command
1000   326289  0.00    0.00    0.00    0.00    0.00     7  run.sh
```

#### Тестирование на процессе init (PID 1)

**Вывод pstat:**
```
Process Statistics for PID 1:
================================
PPid:                      0
Threads:                   1
State:                     S
User time (ticks):         549
System time (ticks):       837
CPU time (seconds):        13.86
Voluntary ctx switches:    6544
Nonvoluntary ctx switches: 241
VmRSS:                     8.22 MiB (8420 kB)
RssAnon:                   3.62 MiB (3712 kB)
RssFile:                   4.60 MiB (4708 kB)
Read bytes:                0
Write bytes:               0
```

### 4. Диагностика с помощью strace

Анализ системных вызовов утилиты pstat показал:
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 21.17    0.000777         777         1           execve
 17.44    0.000640          91         7           mmap
 11.63    0.000427          61         7           read
 10.25    0.000376          75         5           openat
  8.61    0.000316          52         6           pread64
  8.45    0.000310          51         6           fstat
```

Основные системные вызовы:
- `execve` - запуск программы
- `mmap` - отображение памяти
- `read` - чтение файлов из /proc
- `openat` - открытие файлов
- `pread64` - позиционное чтение

## Ответы на вопросы

### 1. Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?

**В `/proc/<pid>/stat`:**
- Поле 14 (`utime`) - время выполнения в пользовательском режиме в тиках
- Поле 15 (`stime`) - время выполнения в режиме ядра в тиках  
- Поле 3 (`state`) - текущее состояние процесса (R, S, D, Z, T, W, X)

**В `/proc/<pid>/status`:**
- Строка `State:` содержит состояние процесса с расшифровкой

### 2. Как получить RSS и чем отличаются RssAnon и RssFile?

**RSS (Resident Set Size)** - объем физической памяти, фактически используемый процессом:
- `VmRSS` в `/proc/<pid>/status` - общий RSS в килобайтах
- `RssAnon` - анонимная память (стек, куча, данные процесса)
- `RssFile` - память, отображенная из файлов (библиотеки, исполняемые файлы)

Важность: RSS показывает реальное потребление оперативной памяти, в отличие от виртуального размера (VSZ).

### 3. Как оценить IO‑активность по `/proc/<pid>/io`?

Файл `/proc/<pid>/io` содержит счетчики:
- `read_bytes` - количество байт, прочитанных из хранилища
- `write_bytes` - количество байт, записанных в хранилище
- `syscr` - количество системных вызовов чтения
- `syscw` - количество системных вызовов записи

Отличие от "ожидания IO" в top/pidstat: наши счетчики показывают объем данных, а top показывает время ожидания завершения IO операций (iowait).

### 4. Что означает делитель HZ и как корректно посчитать CPU time?

`HZ` - частота системного таймера (обычно 100 Гц в Linux), определяет количество тиков в секунду.

**Формула:** `CPU time (сек) = (utime + stime) / HZ`

В нашей реализации: `cpu_time_sec = (double)(info->utime + info->stime) / HZ;`

### 5. Почему возможны рассинхронизации между `/proc` и выводом ps/top?

Причины рассинхронизации:
- Файлы `/proc` читаются в разное время
- Процессы активно изменяют свое состояние
- Различные методы округления и усреднения
- Кэширование данных в утилитах

Критично при мониторинге быстро изменяющихся процессов или при точных измерениях производительности.

### 6. Что показывает strace -c и как интерпретировать результаты?

`strace -c` показывает статистику системных вызовов:
- `% time` - процент времени, потраченного на данный вызов
- `seconds` - общее время выполнения
- `calls` - количество вызовов
- `errors` - количество ошибок

Для нашей утилиты основное время тратится на `execve` (запуск) и файловые операции (`read`, `openat`).

## Сравнительный анализ

### Соответствие показаний:

| Метрика | pstat | ps | top | Комментарий |
|---------|-------|----|----|-------------|
| PID | 326289 | 326289 | 326289 | ✓ Совпадают |
| PPID | 325976 | 325976 | - | ✓ Совпадают |
| State | S | S | S | ✓ Совпадают |
| RSS | 3456 kB | 3456 | 3456 | ✓ Совпадают |
| Threads | 1 | 1 | - | ✓ Совпадают |

### Различия в представлении:
- `ps` и `top` показывают время в формате MM:SS
- `pstat` показывает время в секундах с дробной частью
- `pstat` предоставляет больше деталей по памяти (RssAnon/RssFile)

## Выводы

1. **Успешность реализации:** Утилита `pstat` корректно читает и интерпретирует данные из `/proc`, показания соответствуют системным утилитам.

2. **Точность измерений:** Прямое чтение из `/proc` дает наиболее актуальные данные, но может быть рассинхронизовано при быстрых изменениях.

3. **Диагностические возможности:** `strace` показал, что основные затраты времени приходятся на файловые операции, что логично для утилиты чтения `/proc`.

4. **Ограничения окружения:** В WSL2 некоторые файлы могут быть недоступны без прав root (например, `/proc/<pid>/io`), `perf` не установлен по умолчанию.

5. **Практическая ценность:** Понимание структуры `/proc` необходимо для системного программирования и мониторинга под Linux.

## Воспроизводимость

**Окружение:**
- ОС: WSL2 Ubuntu (Linux 6.6.87.2-microsoft-standard-WSL2)
- Компилятор: GCC
- Доступные утилиты: ps, top, pidstat, strace

**Команды воспроизведения:**
```bash
cd /home/surf/BSU-DLA-2025/lab3/gr1sub1/SokolovEA
./run.sh  # Полная демонстрация

# Или поэтапно:
cd src/
make all
../bin/pstat $$  # Анализ текущего процесса
```

**Ограничения:**
- Требуются права root для полного доступа к `/proc/<pid>/io`
- `perf` может потребовать дополнительной настройки
- В виртуальных средах некоторые метрики могут отличаться от нативного Linux