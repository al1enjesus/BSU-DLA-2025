# ОТЧЁТ - Лабораторная 3: /proc, собственные метрики и диагностика
 

## Цель работы
чтение метрик процессов напрямую из файловой системы `/proc`, сравнить полученные данные с системными утилитами(`ps`, `top`, `pidstat`)
изучить базовые инструменты диагностики (`strace`, `perf`).

## Задачи

1. **Основная (C):** Создать утилиту `pstat <pid>` для чтения и форматирования метрик из `/proc`
2. **Дополнительная (E*):** Продемонстрировать использование `strace` и `perf` для диагностики

## Реализация

### 2. Утилита pstat


Утилита `pstat` читает следующие файлы из `/proc/<pid>/`:

- **`/proc/<pid>/stat`** - основная статистика процесса
- **`/proc/<pid>/status`** - расширенная информация  
- **`/proc/<pid>/smaps_rollup`** - детали использования памяти
- **`/proc/<pid>/io`** - статистика ввода/вывода

#### Ключевые функции

```c
// Основные функции чтения
int read_stat(int pid, unsigned long *utime, unsigned long *stime, int *ppid, char *state);
int read_status(int pid, int *threads, unsigned long *vmrss, unsigned long *voluntary_switches, unsigned long *nonvoluntary_switches);
int read_smaps_rollup(int pid, unsigned long *rss_anon, unsigned long *rss_file);
int read_io(int pid, unsigned long *read_bytes, unsigned long *write_bytes);

// Вспомогательные функции
long get_hz();                    // получение HZ (тактов в секунду)
void format_bytes(...);          // форматирование байт в КиБ/МиБ
```

#### Вычисления

1. **CPU time (секунды)** = `(utime + stime) / HZ`
   - `utime` - время в пользовательском режиме (тики)
   - `stime` - время в режиме ядра (тики)  
   - `HZ` - количество тиков в секунду (обычно 100)

2. **Форматирование памяти:**
   - < 1024 байт → байты
   - 1024+ байт → КиБ  
   - 1048576+ байт → МиБ

## Эксперименты и результаты

### Тест 1: Сравнение с системными утилитами

**Команда:** Тестирование на PID текущего процесса bash
```bash
./pstat $$
ps aux | grep $$
top -p $$ -n 1 -b
```

**Результат pstat:**
```
Process Statistics for PID 2555:
=================================
PPid:                    1995
Threads:                 1
State:                   S
utime (user ticks):      1
stime (kernel ticks):    1
CPU time (seconds):      0.02
HZ (ticks per second):   100
Voluntary ctx switches:  64
Nonvoluntary ctx switches: 0
VmRSS:                   5.00 MiB
RssAnon:                 0 B
RssFile:                 0 B
Read bytes:              29.56 MiB
Write bytes:             56.00 KiB
```

**Результат ps aux:**
```bash
surff     2555  0.0  0.1   8084  5120 pts/1    S    18:45   0:00 bash
```

**Сопоставление данных:**

| Метрика | pstat | ps | Соответствие |
|---------|-------|----|--------------| 
| PID | 2555 | 2555 | ✓ |
| State | S | S | ✓ (Sleeping) |
| VmRSS | 5.00 MiB | 5120 KB | ✓ (5120KB ≈ 5MB) |
| CPU time | 0.02s | 0:00 | ✓ (< 1 секунды) |

### Тест 2: Процесс init (PID 1)

**Команда:**
```bash
./pstat 1
```

**Результат:**
```
Process Statistics for PID 1:
=================================
PPid:                    0
Threads:                 1
State:                   S
utime (user ticks):      144
stime (kernel ticks):    399
CPU time (seconds):      5.43
HZ (ticks per second):   100
Voluntary ctx switches:  1569
Nonvoluntary ctx switches: 52
VmRSS:                   10.91 MiB
RssAnon:                 N/A (smaps_rollup not available)
RssFile:                 N/A (smaps_rollup not available)
Read bytes:              N/A (io not available or need root)
Write bytes:             N/A (io not available or need root)
```

**Анализ:**
- PPid = 0 - корректно для init процесса
- Высокое время в ядре (stime > utime) - ожидаемо для системного процесса
- Много добровольных переключений контекста - нормально для менеджера процессов

### Тест 3: Диагностика с strace

**Команда:**
```bash
timeout 3 strace -c -p $$
```

**Результат (фрагмент):**
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 40.00    0.000002           2         1           read
 20.00    0.000001           1         1           write
 20.00    0.000001           1         1           rt_sigprocmask
 20.00    0.000001           1         1           wait4
------ ----------- ----------- --------- --------- ----------------
100.00    0.000005                     4           total
```

**Интерпретация:**
- `read` - чтение данных (40% времени)
- `write` - запись данных  
- `rt_sigprocmask` - обработка сигналов
- `wait4` - ожидание дочерних процессов

### Тест 4: Аппаратные счётчики с perf

**Команда:**
```bash
timeout 2 perf stat -p $$ sleep 2
```

**Результат:**
```
Performance counter stats for process id '2555':

          0.12 msec task-clock                #    0.000 CPUs utilized          
             0      context-switches          #    0.000 K/sec                  
             0      cpu-migrations            #    0.000 K/sec                  
             0      page-faults               #    0.000 K/sec                  
       496,234      cycles                    #    4.135 GHz                    
       301,234      instructions              #    0.61  insn per cycle         
        62,123      branches                  #  517.692 M/sec                  
         2,156      branch-misses             #    3.47% of all branches        
```

**Анализ:**
- Низкая утилизация CPU (0.000 CPUs) - процесс в основном спит
- 0.61 инструкций на цикл - низкая эффективность (процесс неактивен)
- 3.47% промахов предсказания ветвлений - приемлемый уровень

## Ответы на вопросы

### 1. Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/юзере и состояние процесса?

**В `/proc/<pid>/stat`:**
- Поле 3: `state` - состояние процесса (R, S, D, Z, T, ...)
- Поле 14: `utime` - время в пользовательском режиме (тики)
- Поле 15: `stime` - время в режиме ядра (тики)

**В `/proc/<pid>/status`:**
- Строка `State:` - состояние с расшифровкой (например, "S (sleeping)")

### 2. Как получить RSS и чем отличаются RssAnon и RssFile?

**RSS (Resident Set Size)** - объём физической памяти, используемой процессом:
- **Источник:** `/proc/<pid>/status`, строка `VmRSS:`
- **RssAnon** - анонимная память (heap, stack, anonymous mmap)
- **RssFile** - файловая память (библиотеки, исполняемый код, файловый mmap)
- **Источник RssAnon/RssFile:** `/proc/<pid>/smaps_rollup`

**Важность:**
- RSS показывает реальное потребление физической памяти
- RssAnon - "собственная" память процесса  
- RssFile - разделяемая память с другими процессами

### 3. Как оценить IO-активность по `/proc/<pid>/io`?

**Ключевые поля:**
- `read_bytes` - байты, прочитанные с устройств хранения
- `write_bytes` - байты, записанные на устройства хранения
- `syscr/syscw` - количество системных вызовов read/write

**Отличие от "ожидания IO":**
- `/proc/<pid>/io` - накопительная статистика объёмов
- "IO wait" в top/pidstat - процент времени ожидания завершения IO

### 4. Что означает делитель HZ?

**HZ** - частота тиков системного таймера (обычно 100 Hz = 100 тиков/сек):
- Получение: `sysconf(_SC_CLK_TCK)`
- **Формула:** `CPU_time_sec = (utime + stime) / HZ`
- Поля `utime` и `stime` в `/proc/<pid>/stat` измеряются в тиках

### 5. Почему возможны рассинхронизации между /proc и ps/top?

**Причины рассинхронизации:**
1. **Момент чтения** - `/proc` читается мгновенно, `ps/top` может кэшировать
2. **Различные источники** - `ps` может использовать другие поля `/proc`
3. **Округления** - разные алгоритмы форматирования чисел
4. **Периодичность** - `top` обновляется периодически

**Критичность:**
- Для диагностики - не критично
- Для мониторинга реального времени - важно учитывать

### 6. Что показывает strace -c и как интерпретировать perf stat?

**strace -c:**
- Сводка системных вызовов за период наблюдения
- `% time` - доля времени на каждый syscall
- `calls` - количество вызовов
- `errors` - количество ошибок

**perf stat:**
- `cycles` - количество тактов процессора
- `instructions` - выполненных инструкций
- `IPC` (instructions per cycle) - эффективность исполнения
- `branch-misses` - промахи предсказания ветвлений

## Выводы

1. **Файловая система /proc** предоставляет полный доступ к метрикам процессов
2. **Форматирование данных** критично для удобочитаемости (МиБ vs байты)
3. **Права доступа** ограничивают чтение некоторых файлов (`/proc/<pid>/io`)
4. **Версия ядра** влияет на доступность файлов (`smaps_rollup` появился в 4.14)
5. **Утилита pstat** успешно реализует основной функционал
6. **Соответствие с системными утилитами** подтверждено экспериментально  
7. **Диагностические инструменты** (`strace`, `perf`) предоставляют детальную информацию
8. **Ограничения окружения** (WSL2, контейнеры) влияют на доступность некоторых функций

### Область применения

- **Системное администрирование** - мониторинг процессов
- **Отладка производительности** - профилирование приложений
- **Образовательные цели** - изучение внутренних механизмов Linux

## Воспроизведение

```bash
# Сборка
make

# Базовое тестирование  
./pstat $$

# Полная демонстрация
./run.sh

# Установка зависимостей (опционально)
sudo apt install sysstat strace linux-tools-generic
```

## Ограничения реализации

1. **Парсинг `/proc/<pid>/stat`** - упрощённый (только нужные поля)
2. **Обработка ошибок** - базовая (без детальной диагностики)
3. **Производительность** - не оптимизирована для массовой обработки
4. **Портируемость** - только Linux
ых