# Лабораторная 3 — /proc, собственные метрики и диагностика

## Цели
- Научиться уверенно извлекать и интерпретировать метрики процесса из `/proc`.
- Провести анализ путем сопоставления показателей `/proc` с утилитами `ps`, `top`, `pidstat`.
- Освоить базовую диагностику приложений: системные вызовы и аппаратные счётчики.


## Задание C. /proc и собственная утилита pstat (обязательно)

### Цель
Напишите утилиту `pstat <pid>`, которая:
- Читает `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io`, `/proc/<pid>/smaps_rollup` (если есть).
- Выводит краткую сводку: `PPid`, `Threads`, `State`, `utime/stime`, `voluntary_ctxt_switches`, `nonvoluntary_ctxt_switches`, `VmRSS`, `RssAnon`, `RssFile`, `read_bytes`, `write_bytes`.
- Умеет форматировать числа (МиБ/КиБ) и считает `RSS MiB` и «CPU time sec = (utime+stime)/HZ».

### Шаги/команды
Замечание! Все команды выполнялись в wsl2.


#### Запуск нашей утилиты pstat <pid> (способ запуска опишу в README.md)

Выполняем в bash: `./pstat $$`, где $$ - это будет PID процесса, который как раз отвечает за bash, при желании можете ввести вместо $$ любой PID  
Вывод:

> pstat: pid=1926 (bash)
> PPid:                       1923  
State (stat):               S  
State (status):             S (sleeping)  
Threads:                    1  
utime (ticks):              7  
stime (ticks):              3  
CPU time sec = (utime+stime)/HZ:0.1000  (HZ=100)  
voluntary_ctxt_switches:    374  
nonvoluntary_ctxt_switches: 2  
VmRSS:                      5428 kB (5.30 MiB)  
RSS (MiB):                  5.301 MiB  
read_bytes:                 4784128  
write_bytes:                61440  

#### Запуск утилиту ps
Выполняем в bash:
`ps -p $$ -o pid,ppid,state,etimes,pcpu,pmem,cmd,time`

Вывод:
```text
PID    PPID  S  ELAPSED  %CPU  %MEM   CMD    TIME
1926   1923  S      552   0.0   0.1   -bash  00:00:00
```

#### Запуск утилиту pidstat
Выполняем в bash:
`pidstat -p $$`

Вывод:
```text
Linux 6.6.87.2-microsoft-standard-WSL2 (DESKTOP-OHCJ5SB)        10/05/25        _x86_64_        (2 CPU)

14:41:44      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
14:41:44     1000      1926    0.00    0.00    0.00    0.00    0.01     1  bash
```

#### Запуск утилиты pidstat
Выполняем в bash:
`top -p $$`

Вывод:
```text
top - 14:45:42 up 39 min,  1 user,  load average: 0.21, 0.06, 0.02
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   3795.7 total,   3190.6 free,    350.0 used,    255.1 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   3305.6 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
   1926 vafilon   20   0   10700   5428   3252 S   0.0   0.1   0:00.11 bash
```

### Сравнение и вывод
Во всех утилитах мы видим одинаковый родительский PID, то есть PPID = 1923.  
Что касается кол-ва потоков, но все утилиты дают эти данные по умолчанию, но в тех, которые дают, значение совпадает.  
CPU time во всех утилитах одинаковое, кроме ps, но это из-за того, что форматы разные, а значение маленькое, поэтому в ps значение округляется до нуля.  
Что касается памяти RSS(RES), то здесь тоже значения совпадают, но в pstat значение дополнительно еще считается в MiB, что удобно при анализе.  
С контекстными переключениями сложнее, так как в других утилитах они по умолчанию не выводятся, поэтому сравнить не удалось.  
IO активность тоже выводится верная, но не для всех процессов, так как не все процессы занимаются чтением/записью.  

Таким образом, утилита pstat собирает корректные данные о метриках из /proc. Дает актуальныее данные, а некоторые даже сразу обрабатывает и выводит в виде, который удобнее для последующего анализа.  

## Вопросы
1. Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?  
В stat есть поле `utime`, которое как раз дает время в юзере, есть поле `stime`, которое дает время в ядре, есть поле `state`, которое хранит состояние процесса.  
В status также есть поле `State`, которое хранит информацию о состоянии процесса.  
2. Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`? Почему они важны?  
Можно получить из /proc/<pid>/status. А нужны они для оценки потребления памяти процессом и нагрузки на систему     
3. Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top/pidstat`?  
`/proc/<pid>/io` - суммарное кол-во байтов, которые читались/писались процессом.  
«ожидания IO» в `top/pidstat` - доля того времени, когда процесс ждет ввода/вывода.  
4. Что означает делитель `HZ` и как корректно посчитать `CPU time sec = (utime+stime)/HZ`?  
`HZ` - частота тиков процессора, берем из `sysconf(_SC_CLK_TCK)`.  
Чтобы корректно посчитаь надо получить все значения метрик, а потом подставить в эту формулу `CPU time sec = (utime+stime)/HZ`.  
5. Почему возможны рассинхронизации между `/proc` и выводом `ps/top`? Когда это критично?  
`ps/top` дает значения в момент запроса, а `/proc` постоянно обновляется, поэтому м могут быть рассинхронизации, особенно если рассматриваются короктие процессы.
6. (Для E*) Что показывает `strace -c` и как интерпретировать `perf stat`?  
`strace -c` дает статистику по системным вызовам(например, кол-во, ошибки, время)  
`perf stat` дает статистику по аппаратным метрикам(например, циклы, инструкции, ветвления)  

## Как использовался ИИ
Использовал ИИ для расшифрования метрик из различных утилит и в качестве помощи про формировании команд в bash при вызове утилит.  

