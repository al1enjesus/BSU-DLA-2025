***

# ОТЧЕТ: Лабораторная работа №3 — /proc, собственные метрики и диагностика

## 1. Цель работы

- Научиться извлекать и интерпретировать метрики процесса напрямую из файловой системы `/proc`.
- Сопоставить показатели, полученные из `/proc`, с данными стандартных утилит `ps`, `top` и `pidstat`.
- Освоить базовые методы диагностики приложений с помощью `strace` для анализа системных вызовов и `perf` для анализа аппаратных счетчиков производительности.

## 2. Шаги и решения

Для выполнения задания была разработана утилита `pstat` на языке Python. Она принимает на вход идентификатор процесса (PID), считывает и анализирует файлы из директории `/proc/<pid>/` (`status`, `stat`, `io`) и выводит сводную информацию в отформатированном виде.

Далее были проведены эксперименты для проверки корректности работы утилиты. В качестве исследуемого процесса был запущен экземпляр `bash` с PID `6357`. Были сняты показания с помощью разработанной утилиты `pstat` и стандартных системных утилит `ps`, `top` и `pidstat` для последующего сравнения.

## 3. Ключевые выводы

Все ключевые метрики, полученные с помощью утилиты `pstat` (`PPID`, `Threads`, `State`, `VmRSS`), полностью совпали с показаниями стандартных системных утилит `ps`, `top` и `pidstat`.

- **VmRSS (общий объем занимаемой физической памяти):** `pstat` показал `3.63 MiB`. `ps` и `top` показали `3720` КиБ, что эквивалентно `3.63 МиБ`. Совпадение полное.
- **PPID, количество потоков и состояние:** Полное совпадение во всех утилитах.
- **Время CPU:** Незначительные расхождения во времени использования CPU объясняются динамической природой метрик и тем, что замеры производились в разные моменты времени. Это является ожидаемым поведением.

Главный вывод заключается в том, что файловая система `/proc` является надежным и точным источником данных о состоянии процессов в системе, а самостоятельно разработанные инструменты могут успешно конкурировать по точности со стандартными утилитами.

## 4. Ответы на вопросы

**1. Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?**
- **Состояние процесса (`State`):** В `/proc/<pid>/status` — в поле `State:`. В `/proc/<pid>/stat` — это третье поле (однобуквенный код).
- **Время CPU (`utime`/`stime`):** В `/proc/<pid>/stat` время в пользовательском режиме (`utime`) — 14-е поле, время в режиме ядра (`stime`) — 15-е поле. Значения указаны в системных тиках.

**2. Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?**
- **Получение RSS:** Из поля `VmRSS` в `/proc/<pid>/status` (в килобайтах) или 24-го поля в `/proc/<pid>/stat` (в страницах).
- **`RssAnon` vs `RssFile`:** `RssAnon` — это анонимная память (куча, стек), не связанная с файлами. `RssFile` — это память, отображенная из файлов (библиотеки, код программы). Разделение важно для диагностики утечек памяти (обычно растет `RssAnon`).

**3. Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top`/`pidstat`?**
- **/proc/<pid>/io:** Показывает счетчики **объема** прочитанных/записанных байт (`read_bytes`, `write_bytes`).
- **Ожидание IO (`iowait` или `%wa`):** Это метрика **CPU**, показывающая, какой процент времени процессор простаивал, ожидая завершения дисковых операций для какой-либо задачи. Процесс может выполнять много I/O, но не вызывать `iowait`, если диски быстрые.

**4. Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?**
- **Делитель `HZ`:** Это частота системного таймера ядра (количество тиков в секунду). Чтобы перевести `utime` и `stime` из тиков в секунды, нужно разделить их на это значение. Получить `HZ` можно командой `getconf CLK_TICK` или системным вызовом `sysconf(_SC_CLK_TICK)`.

**5. Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?**
- **Причины:** Чтение данных из `/proc` не является атомарной операцией. Между чтением одного файла (`stat`) и другого (`status`) состояние процесса может измениться. Утилиты также обновляют данные с разной периодичностью.
- **Критичность:** Обычно некритично для общего мониторинга, но может быть важно для систем автоматического реагирования или биллинга, где требуется высокая точность.

## 5. Как проверяли

Корректность работы самописной утилиты `pstat` проверялась путем прямого сравнения ее вывода с выводом эталонных системных утилит, которые используют те же источники данных в `/proc`:
1.  Был запущен тестовый процесс и определен его PID (`6357`).
2.  Были сняты метрики этого процесса с помощью `pstat`.
3.  Параллельно были сняты метрики того же процесса с помощью команд `ps -p 6357 -o ...`, `top -p 6357` и `pidstat -p 6357 -urd`.
4.  Проводилось сопоставление ключевых полей: `PPID`, `Threads`, `State`, `RSS` и `TIME`.

Полное совпадение значений `RSS` (с учетом перевода КиБ в МиБ) и других статических полей подтвердило, что утилита `pstat` корректно считывает и интерпретирует данные из файловой системы `/proc`.

## 6. Как использовали AI

Искусственный интеллект (в лице large language model) использовался на нескольких этапах выполнения лабораторной работы:

1.  **Написание кода:** AI сгенерировал первоначальный Python-скрипт для утилиты `pstat` на основе технических требований из задания (считывание определенных файлов, парсинг полей, форматирование вывода).
2.  **Отладка и консультация:** AI помог диагностировать ошибку "Процесс с PID ... не найден", объяснив, что PID является динамическим, и подсказал команды (`pgrep`, `&`) для получения актуального идентификатора процесса.
3.  **Структурирование отчета:** AI помог сгенерировать полный отчет в формате Markdown на основе предоставленных скриншотов с результатами экспериментов, структурировав его в соответствии с требованиями (цель, выводы, ответы на вопросы и т.д.).
4.  **Финальное редактирование:** AI вносил правки в готовый отчет по запросу, добавляя и удаляя разделы для полного соответствия заданию.
