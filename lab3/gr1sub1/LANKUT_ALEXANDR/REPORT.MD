# Лабораторная работа 3

## Окружение
- ОС: Ubuntu 20.04 в WSL2

## Цель работы
Разработать и реализовать утилиту для мониторинга процессов через файловую систему `/proc`, провести сравнительный анализ с существующими системными утилитами.

### Задание C:

Файловая система `/proc` предоставляет интерфейс к структурам данных ядра Linux в виде файловой системы. Для каждого процесса создается директория `/proc/<pid>`, содержащая различные файлы с информацией о процессе:
- `/proc/<pid>/stat` - основная статистика процесса
- `/proc/<pid>/status` - информация о процессе в человекочитаемом формате
- `/proc/<pid>/io` - статистика ввода-вывода
- `/proc/<pid>/smaps_rollup` - детальная информация об использовании памяти

### 1. Эксперименты и сравнительный анализ

#### 1.1. Тестирование на процессе с интенсивной CPU нагрузкой

```bash
# Создаем нагрузку на CPU
yes > /dev/null & 
CPU_PID=$!
sleep 1

# Сравниваем показания различных утилит
ps -o pid,ppid,nlwp,state,time,rss -p $CPU_PID
./pstat $CPU_PID
pidstat -p $CPU_PID 1 1

kill $CPU_PID
```

Вывод pstat:
```
Process 12345 information:
---------------------------
Parent PID: 8865
Thread count: 1
State: R (running)
CPU Time: 0.98 sec (user: 98, system: 0)
Context switches: voluntary=4, nonvoluntary=127
Memory usage (VmRSS): 3.05 MiB
Anonymous memory (RssAnon): 1.51 MiB
File cache (RssFile): 1.54 MiB
Read: 0 B
Written: 48.00 KiB
---------------------------
```

Вывод ps:
```
  PID  PPID NLWP S   TIME     RSS
12345  8865    1 R   0:00   3116
```

Вывод pidstat:
```
# Time        UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
1697372901   1000    12345    98.0    2.0    0.00    0.00   100.0     0   yes
```

#### 1.2. Тестирование на процессе с активным использованием памяти

```python
python3 -c "x = ' ' * 100000000" &
MEM_PID=$!
sleep 1

ps -o pid,ppid,nlwp,state,time,rss -p $MEM_PID
./pstat $MEM_PID
top -p $MEM_PID -b -n 1

kill $MEM_PID
```

Вывод top:
```
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  12346 root      20   0  104096  96568    888 S   0.0   4.8   0:00.01 python3
```

## Вывод

1. Время CPU:
   - pstat показывает время с точностью до сотых секунды
   - ps округляет до минут:секунд
   - pidstat показывает процентное использование
   - Базовые значения согласуются при пересчете

2. Использование памяти:
   - RSS в ps/top измеряется в килобайтах
   - pstat использует автоматическое форматирование (B/KiB/MiB)
   - Значения согласуются с погрешностью округления

3. Контекстные переключения:
   - Только pstat и pidstat показывают эту метрику
   - Значения согласуются, но могут различаться из-за времени снятия показаний

## Ответы на вопросы

1 **Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?**

В файле `/proc/<pid>/stat` эта информация находится в следующих полях:
- Состояние процесса: поле 3 (однобуквенный код)
  - R: running (выполняется)
  - S: sleeping (спит)
  - D: disk sleep (ожидает ввода-вывода)
  - Z: zombie (зомби)
  - T: stopped (остановлен)
- Время в пользовательском режиме (utime): поле 14
- Время в режиме ядра (stime): поле 15

В файле `/proc/<pid>/status` эта же информация представлена в более читаемом формате:
- State: текстовое описание состояния
- Utime/Stime: времена в тиках процессора

2 **Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`? Почему они важны?**

RSS (Resident Set Size) можно получить из:
- `/proc/<pid>/status` поле VmRSS
- Либо суммируя RssAnon + RssFile + RssShm

RssAnon и RssFile отражают разные типы памяти:
- RssAnon: анонимная память, выделенная процессом (куча, стек)
- RssFile: страницы памяти, отображенные из файлов (код программы, разделяемые библиотеки)

Это разделение важно, потому что:
- Позволяет понять характер использования памяти процессом
- RssFile может быть разделена между процессами
- RssAnon уникальна для каждого процесса
- Помогает в оптимизации использования памяти

3 **Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top/pidstat`?**

В `/proc/<pid>/io` мы видим кумулятивные счетчики:
- read_bytes: общее количество прочитанных байт
- write_bytes: общее количество записанных байт

В top/pidstat показывается %iowait - процент времени, когда процесс ждал завершения операций ввода-вывода.

4 **Что означает делитель `HZ` и как корректно посчитать `CPU time sec = (utime+stime)/HZ`?**

HZ - это системная константа, определяющая количество тиков процессора в секунду. Для корректного расчета:
- Получаем HZ через sysconf(_SC_CLK_TCK)
- Складываем время в пользовательском режиме (utime) и режиме ядра (stime)
- Делим сумму на HZ для получения времени в секундах

5 **Почему возможны рассинхронизации между `/proc` и выводом `ps/top`? Когда это критично?**

Рассинхронизации возможны потому, что:
- `/proc` предоставляет мгновенный снимок состояния процесса
- ps/top могут читать данные с задержкой
- Между чтениями разных файлов в /proc состояние может измениться
- Утилиты могут кэшировать данные

Это критично в случаях:
- При профилировании производительности
- При отладке проблем синхронизации
- При мониторинге быстро меняющихся процессов
- Когда требуется точная корреляция между разными метриками
