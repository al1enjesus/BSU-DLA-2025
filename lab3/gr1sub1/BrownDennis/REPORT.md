# Отчёт по лабораторной работе №3

Дэннис Браун Франко

Группа 1

## Цель работы

Написать утилиту `pstat` на C++ для извлечения и отображения ключевых метрик процесса из системы `/proc`. Сравнить её показания с системными утилитами `ps`, `top`, `pidstat`. Изучить структуру и значение данных в `/proc` для диагностики и мониторинга.

## Шаги и команды

### 1. Исходный код утилиты `pstat`

Утилита написана на C++ и считывает данные из файлов `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io` и `/proc/<pid>/smaps_rollup`.

_Полный код находится в файле `src/pstat.cpp`._

### 2. Makefile для сборки

Для компиляции программы был создан следующий `Makefile`:

```makefile
MAKEFILE_DIR := $(dir $(abspath $(lastword $(MAKEFILE_LIST))))
DURATION ?= 5

.PHONY: run
run: build
	@$(MAKEFILE_DIR)bin/pstat $(pid)

.PHONY: build
build:
	@mkdir -p $(MAKEFILE_DIR)bin
	@g++ $(MAKEFILE_DIR)src/pstat.cpp -o $(MAKEFILE_DIR)bin/pstat

.PHONY: test
test: build
	@echo "Starting CPU consumer (dd) in background..."; \
	dd if=/dev/zero of=/dev/null & \
	pid=$$!; \
	echo "Started dd with PID=$$pid"; \
	echo "Sleeping for $(DURATION) seconds..."; \
	sleep $(DURATION); \
	echo; \
	echo "==== running $(MAKEFILE_DIR)bin/pstat $$pid ===="; \
	"$(MAKEFILE_DIR)bin/pstat" $$pid || true; \
	echo; \
	echo "==== ps -o ppid,thcount,s,utime,stime,rss -p $$pid ===="; \
	ps -o ppid,thcount,s,utime,stime,rss -p $$pid || true; \
	echo; \
	echo "==== pidstat -p $$pid 1 1 ===="; \
	pidstat -p $$pid 1 1 || true; \
	echo; \
	echo "==== top -b -n 1 -p $$pid ===="; \
	top -b -n 1 -p $$pid || true; \
	echo; \
	echo "Killing $$pid"; \
	kill $$pid 2>/dev/null || true; \
	echo "Done."

.PHONY: clean
clean:
	rm -rf $(MAKEFILE_DIR)bin
```

### 3. Сборка и запуск

Сборка и запуск проекта выполняется командой `make run`.

```bash
make run pid=some_pid
```

### 4. Эксперимент и сравнение

Запустим процесс, создающий нагрузку на CPU, и проанализируем его с помощью реальных команд.

```bash
make test
```

## Фрагменты выводов

#### Вывод `pstat`

```
--- pstat for PID: 43379 ---
PPid:                         43364
Threads:                 	  1
State:                        R
utime/stime (ticks):          156 / 394
CPU time (sec):               5.50
voluntary_ctxt_switches:      0
nonvoluntary_ctxt_switches:	  384
VmRSS:                   	  2104 kB
RSS MiB:                      2.05 MiB
RssAnon:                      N/A
RssFile:                      N/A
read_bytes:                   0 B
write_bytes:                  0 B
```

#### Вывод `ps`

```
   PPID THCNT S  UTIME STIME   RSS
  43364     1 R      - 16:30  2104
```

#### Вывод `pidstat`

```
04:30:11 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
04:30:12 PM  1000     43379   28.00   71.00    0.00    1.00   99.00     3  dd
```

#### Вывод `top`

```
top - 16:30:12 up 49 min,  1 user,  load average: 5.13, 3.98, 2.46
Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s): 62.8 us, 19.0 sy,  0.0 ni, 18.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  15385.5 total,   6032.6 free,   5972.8 used,   3921.9 buff/cache
MiB Swap:      0.0 total,      0.0 free,      0.0 used.   9412.7 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  43379 Dennis     20   0    5676   2104   1976 R 100.0   0.0   0:06.72 dd
```

**Сравнение:**

- **State:** Все утилиты корректно показывают состояние `R` (Running).
- **CPU Time:** `pstat` насчитал `5.50` секунд процессорного времени. `top` показывает `0:06.72`, что близко. `pidstat` показывает, что процесс утилизирует почти 100% одного ядра (`%CPU 99.00`). Интересно, что `ps` не смог отобразить `UTIME`, вероятно, из-за короткого времени жизни процесса на момент вызова.
- **VmRSS/RES/RSS:** `pstat` показывает `VmRSS: 2104 kB`. Это значение точно совпадает с `RSS` в `ps` (2104) и `RES` в `top` (2104). Это подтверждает, что все они читают один и тот же источник.
- **RssAnon/RssFile:** `pstat` показывает `N/A`, так как файл `/proc/<pid>/smaps_rollup` оказался недоступен в момент чтения. Это демонстрирует реальное ограничение, с которым можно столкнуться.
- **Контекстные переключения:** `pstat` сообщает о `384` недобровольных переключениях, что логично для процесса, который постоянно потребляет CPU и вытесняется планировщиком.

## Ответы на вопросы

1.  **Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?**

    - **Время:** В `/proc/<pid>/stat` поля 14 (`utime` - user time) и 15 (`stime` - kernel time) хранят время в тиках системных часов. В `/proc/<pid>/status` этих данных нет.
    - **Состояние:** В `/proc/<pid>/stat` третье поле (`state`) содержит однобуквенный код (`R`, `S`, `D`, `Z` и т.д.). В `/proc/<pid>/status` есть поле `State:`, где состояние указано в более понятном формате (e.g., `S (sleeping)`).

2.  **Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`? Почему они важны?**

    - `RSS` (Resident Set Size) — это общий объём памяти, который процесс занимает в ОЗУ. Его можно получить из поля `VmRSS` в `/proc/<pid>/status`.
    - `RssAnon` — это анонимная память, не связанная с файлами (например, память, выделенная через `malloc`, стеки потоков). Это уникальная для процесса память.
    - `RssFile` — это память, отображённая из файлов на диске (например, код программы, разделяемые библиотеки).
    - Эти метрики важны для анализа потребления памяти. Высокий `RssAnon` может указывать на утечки памяти. `RssFile` показывает, сколько памяти разделяется между процессами, использующими одни и те же библиотеки.

3.  **Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top/pidstat`?**

    - `/proc/<pid>/io` предоставляет кумулятивные счётчики байт, прочитанных и записанных процессом (`read_bytes`, `write_bytes`). Это фактический объём данных, прошедших через системные вызовы `read`/`write`.
    - «Ожидание IO» (`%wait` или `wa` в `top`/`pidstat`) — это процессорное время, потраченное на ожидание завершения операций ввода-вывода (например, от диска). Процесс в это время находится в состоянии `D` (uninterruptible sleep) и не потребляет CPU. Таким образом, `/proc/<pid>/io` показывает _объём_ I/O, а `%wait` — _время простоя_ CPU из-за I/O.

4.  **Что означает делитель `HZ` и как корректно посчитать `CPU time sec = (utime+stime)/HZ`?**

    - `HZ` — это частота системного таймера (тиков в секунду). В ядре Linux это константа, определяющая, как часто планировщик переключает задачи. Значения `utime` и `stime` измеряются в этих тиках.
    - Чтобы получить процессорное время в секундах, нужно суммировать тики (`utime + stime`) и разделить на количество тиков в секунду (`HZ`). Значение `HZ` можно получить в user-space с помощью `sysconf(_SC_CLK_TCK)`.

5.  **Почему возможны рассинхронизации между `/proc` и выводом `ps/top`? Когда это критично?**
    - Рассинхронизация возникает из-за того, что чтение нескольких файлов из `/proc` не является атомарной операцией. Пока утилита читает один файл (e.g., `status`), состояние процесса может измениться, и данные в другом файле (e.g., `stat`) уже будут другими. `ps` и `top` также сталкиваются с этой проблемой, но могут использовать более сложные механизмы или просто обновлять данные с некоторой периодичностью.
    - Это критично при попытке получить мгновенный, консистентный срез состояния процесса. Например, если вы пытаетесь сопоставить потребление CPU с конкретным состоянием или количеством потоков в один и тот же момент времени. Для долгоживущих средних показателей это менее важно.

## Выводы

В ходе работы была успешно разработана утилита `pstat`, которая напрямую извлекает данные из `/proc`. Сравнение с `ps`, `top` и `pidstat` показало, что системные утилиты являются высокоуровневыми "интерпретаторами" тех же самых сырых данных из `/proc`.

Работа с `/proc` напрямую даёт гранулярный доступ к метрикам (например, к контекстным переключениям или деталям RSS), но требует аккуратной обработки и понимания их смысла (например, пересчёт тиков в секунды). Созданная утилита полностью справляется с поставленной задачей.

## Как воспроизводить и на какой ОС

1.  **ОС:** Любой дистрибутив Linux (протестировано на Ubuntu 22.04).
2.  **Зависимости:** Компилятор `g++` и `make`.
3.  **Сборка:** Перейдите в директорию `gr1sub1/BrownDenis/` и выполните команду `make build`.
4.  **Запуск:** `make run pid=<PID>`, где `<PID>` — идентификатор интересующего процесса.
