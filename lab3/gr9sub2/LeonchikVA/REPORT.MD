
# Отчёт по лабораторной работе №3

## Цель работы

Написать утилиту `pstat` на C для извлечения и отображения ключевых метрик процесса из системы `/proc`. Сравнить её показания с системными утилитами `ps`, `top`, `pidstat`. Изучить структуру и значение данных в `/proc` для диагностики и мониторинга.

## Шаги и команды

### 1. `pstat`

_Код находится в файле `src/pstat.c`._

### 2. Makefile

```bash
make build           # сборка
make run pid=<PID>   # запуск pstat на конкретном PID
make test DURATION=5 # запуск тестового процесса dd на 5 секунд и сравнение с системными утилитами
```

## Эксперимент

### 3. Запуск теста

Команда:

```bash
make test DURATION=5
```

**Вывод `pstat`:**

```
pstat for PID=243457 (dd)
----------------------------
PPid: 243456
Threads: 1
State (stat char): R
State (status): R (running)

CPU times (ticks): utime=183, stime=317
HZ = 100 ticks/sec
CPU time total: ticks=500 => 5.000000 sec

Context switches: voluntary=2, nonvoluntary=42

Memory: VmRSS: 1912 kB (1.87 MiB)
RssAnon: N/A
RssFile: N/A

IO: read_bytes=73728 (72.00 KiB), write_bytes=0 (0.00 B)
```

**Вывод `ps`:**

```
   PPID THCNT S  UTIME STIME   RSS
 243456     1 R      - 00:58  1912
```

**Вывод `pidstat`:**

```
12:58:30 AM  1000    243457   37.00   63.00    0.00    0.00  100.00     4  dd
```

**Вывод `top`:**

```
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
243457 fancurs+  20   0    5676   1912   1912 R 100.0   0.0   0:06.24 dd
```

---

## Сопоставление полей `pstat` с `ps/top/pidstat`

| Метрика                    | pstat     | ps        | pidstat      | top     | Комментарий                                         |
| -------------------------- | --------- | --------- | ------------ | ------- | --------------------------------------------------- |
| PPid                       | 243456    | 243456    | -            | -       | Совпадает                                           |
| Threads                    | 1         | 1         | -            | -       | Совпадает                                           |
| State                      | R         | R         | R            | R       | Все утилиты показывают R                            |
| utime/stime (ticks)        | 183 / 317 | - / 00:58 | %usr/%system | TIME+   | Разная форма, но нагрузка CPU одинаковая            |
| CPU time total (сек)       | 5.0       | -         | 100% CPU     | 0:06.24 | pstat считает точно, top показывает формат hh:mm:ss |
| VmRSS (MiB)                | 1.87      | 1912 kB   | -            | 1912 kB | Совпадает                                           |
| RssAnon/RssFile            | N/A       | -         | -            | -       | smaps_rollup недоступен                             |
| read_bytes                 | 73728 B   | -         | -            | -       | pidstat -d можно использовать                       |
| write_bytes                | 0 B       | -         | -            | -       | -                                                   |
| voluntary_ctxt_switches    | 2         | -         | -            | -       | ps/top не показывают                                |
| nonvoluntary_ctxt_switches | 42        | -         | -            | -       | ps/top не показывают                                |

**Комментарии по расхождениям:**

* Некоторые поля (`voluntary_ctxt_switches`, `nonvoluntary_ctxt_switches`, `RssAnon`, `RssFile`) доступны только через `/proc`.
* CPU time в ticks (`pstat`) пересчитан в секунды, а `top` показывает hh:mm:ss.
* RSS совпадает у всех утилит, подтверждая, что они берут данные из одного источника.


## Форматирование чисел и вычисления

* **RSS MiB:** VmRSS = 1912 kB → 1912 / 1024 ≈ 1.87 MiB
* **CPU time sec:** utime=183 + stime=317 = 500 ticks, HZ=100 → CPU time = 500 / 100 = 5.0 sec

> Эти преобразования делают данные более читаемыми для пользователя.

## Ответы на вопросы

1. **Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?**

   * Время: `/proc/<pid>/stat` поля 14 (utime) и 15 (stime) в тиках.
   * Состояние: `/proc/<pid>/stat` третье поле (`state`), `/proc/<pid>/status` поле `State:`.

2. **Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`?**

   * `RSS` — общий объём памяти в ОЗУ, поле `VmRSS`.
   * `RssAnon` — анонимная память (malloc, стек).
   * `RssFile` — отображённая память из файлов/библиотек.

3. **Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в top/pidstat?**

   * `/proc/<pid>/io` — фактический объём прочитанных/записанных байт.
   * `%wait` в top/pidstat — время простоя CPU при ожидании завершения IO.

4. **Что означает делитель HZ и как корректно посчитать CPU time sec?**

   * `HZ` — частота системного таймера (тиков в секунду).
   * CPU time sec = `(utime + stime) / HZ`.

5. **Почему возможны рассинхронизации между `/proc` и выводом ps/top?**

   * Файлы `/proc` читаются неатомарно; состояние процесса может меняться между чтениями.


## Выводы

* Утилита `pstat` корректно извлекает и форматирует ключевые метрики процесса из `/proc`.
* Сравнение с ps/top/pidstat показало, что системные утилиты берут те же данные, но в других форматах.
* Работа с `/proc` даёт доступ к деталям (контекстные переключения, RssAnon/RssFile), недоступным в стандартных утилитах.

---

## Как воспроизводить и на какой ОС

1. **ОС:** Любой дистрибутив Linux (тестировано на Ubuntu 22.04).
2. **Зависимости:** Компилятор `gcc`, `make`.
3. **Сборка:**

```bash
make build
```

4. **Запуск pstat на конкретном PID:**

```bash
make run pid=<PID>
```

5. **Запуск теста с CPU-нагрузкой и сравнением с системными утилитами:**

```bash
make test DURATION=5
```

## Использование ИИ
* ИИ использовался для форматирования отчета, помощи в написании кода на C```
