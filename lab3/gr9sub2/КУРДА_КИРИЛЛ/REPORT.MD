Отчет по Лабораторной работе №3
/proc, собственные метрики и диагностика

Окружение: WSL2

1. ЦЕЛЬ РАБОТЫ
Целью данной лабораторной работы является:

Изучение файловой системы /proc в Linux и извлечение метрик процессов напрямую из неё
Создание собственной утилиты pstat для анализа процессов
Сопоставление данных из /proc с системными утилитами (ps, top, pidstat)
Освоение базовой диагностики приложений с помощью strace


2. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ
2.1 Файловая система /proc
/proc — это виртуальная файловая система в Linux, которая предоставляет интерфейс к внутренним структурам ядра. Она не хранит реальные файлы на диске, а генерирует их содержимое динамически при обращении.

Для каждого процесса в системе создается директория /proc/[PID]/, содержащая информацию о процессе:

/proc/[PID]/stat — базовая статистика процесса в одной строке
/proc/[PID]/status — расширенная информация в читаемом формате
/proc/[PID]/io — статистика ввода-вывода
/proc/[PID]/cmdline — командная строка запуска процесса
/proc/[PID]/comm — имя команды
2.2 Ключевые метрики процессов
CPU время:

utime — время выполнения в пользовательском режиме (в тиках)
stime — время выполнения в режиме ядра (в тиках)
Для перевода в секунды используется константа HZ (обычно 100 тиков/сек)
Память:

VmRSS (Resident Set Size) — физическая память, используемая процессом
RssAnon — анонимная память (heap, stack)
RssFile — память, отображенная из файлов (код программы, библиотеки)
Переключения контекста:

voluntary_ctxt_switches — добровольные (процесс сам отдал CPU)
nonvoluntary_ctxt_switches — принудительные (планировщик забрал CPU)

3. РЕАЛИЗАЦИЯ

Разработана утилита pstat.py на Python, которая:

Парсит файлы /proc:

def parse_proc_stat(pid):
    with open(f'/proc/{pid}/stat', 'r') as f:
        stat = f.read().strip()
    # Извлечение полей после имени процесса в скобках
    end_paren = stat.rfind(')')
    fields = stat[end_paren + 2:].split()
	
Форматирует вывод в читаемый вид:

def format_bytes(bytes_val, unit='B'):
    for unit_name in ['', 'Ki', 'Mi', 'Gi', 'Ti']:
        if abs(bytes_val) < 1024.0:
            return f"{bytes_val:.2f} {unit_name}{unit}"
        bytes_val /= 1024.0
		
Вычисляет производные метрики:

hz = get_hz()  # Получаем HZ через os.sysconf
cpu_time = (stat['utime'] + stat['stime']) / hz
rss_mb = status['VmRSS'] / (1024 * 1024)

4. ЭКСПЕРИМЕНТЫ И РЕЗУЛЬТАТЫ

===================================================
Проверка окружения
===================================================

✓ Обнаружен WSL2
✓ Python3 установлен: Python 3.12.3
✓ Файловая система /proc доступна

Дополнительные утилиты:
  ✓ ps установлен
  ✓ top установлен
  ✓ pidstat установлен
  ✓ strace установлен
  ⚠ perf не установлен (опционально)

===================================================
Подготовка файлов
===================================================

✓ pstat.py найден в src/

===================================================
Демонстрация базового функционала pstat
===================================================

1. Анализ процесса init (PID 1)

============================================================
Process Statistics for PID: 1
============================================================
Command: systemd
Cmdline: /sbin/init

--- Базовая информация ---
Parent PID: 0
State: S (Sleeping)
Threads: 1

--- CPU время ---
User time: 0.16 sec
System time: 0.22 sec
Total CPU time: 0.38 sec
(HZ = 100 ticks/sec)

--- Память ---
VmRSS: 12.57 MiB (12.57 MiB)

2. Анализ текущего shell (PID 712)

============================================================
Process Statistics for PID: 712
============================================================
Command: bash
Cmdline: -bash

--- Базовая информация ---
Parent PID: 334
State: S (Sleeping)
Threads: 1

--- CPU время ---
User time: 0.01 sec
System time: 0.01 sec
Total CPU time: 0.02 sec
(HZ = 100 ticks/sec)

--- Память ---
VmRSS: 4.54 MiB (4.54 MiB)
RssAnon: 2.34 MiB
RssFile: 2.20 MiB

--- Переключения контекста ---
Voluntary: 917
Non-voluntary: 1

--- I/O статистика ---
Read bytes: 2.57 MiB
Write bytes: 412.00 KiB
Read chars: 6.45 MiB
Write chars: 60.64 KiB

============================================================


3. Создание и анализ тестового процесса
Запускаем sleep 100...

============================================================
Process Statistics for PID: 755
============================================================
Command: sleep
Cmdline: sleep 100

--- Базовая информация ---
Parent PID: 712
State: S (Sleeping)
Threads: 1

--- CPU время ---
User time: 0.00 sec
System time: 0.00 sec
Total CPU time: 0.00 sec
(HZ = 100 ticks/sec)

--- Память ---
VmRSS: 1.05 MiB (1.05 MiB)
RssAnon: 88.00 KiB
RssFile: 988.00 KiB

--- Переключения контекста ---
Voluntary: 2
Non-voluntary: 0

--- I/O статистика ---
Read bytes: 0.00 B
Write bytes: 0.00 B
Read chars: 6.92 KiB
Write chars: 0.00 B

============================================================


===================================================
Демонстрация с различными нагрузками
===================================================

1. Процесс с CPU нагрузкой
Анализ процесса с CPU нагрузкой (PID 759):
State: R (Running)
Total CPU time: 1.02 sec

2. Процесс с памятью
Allocated 50 MB, PID: 764
Анализ процесса с выделенной памятью (PID 764):
VmRSS: 59.69 MiB (59.69 MiB)
RssAnon: 53.63 MiB
RssFile: 6.06 MiB

===================================================
Сравнение pstat с системными утилитами
===================================================

pstat:
State: S (Sleeping)
Total CPU time: 0.01 sec
VmRSS: 9.78 MiB (9.78 MiB)

ps aux:
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
kirill_+     768  1.8  0.1  15412 10016 pts/0    S+   22:04   0:00 python3 -c import time; time.sleep(10)

pidstat:
Linux 5.15.167.4-microsoft-standard-WSL2 (DESKTOP-VGP8IQ4)      10/02/25        _x86_64_        (16 CPU)

22:04:18      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
22:04:20     1000       768    0.00    0.00    0.00    0.00    0.00     9  python3
Average:     1000       768    0.00    0.00    0.00    0.00    0.00     -  python3

===================================================
Расширенная диагностика (strace/perf)
===================================================

Анализ системных вызовов с strace
Processed 0 files
Processed 10 files
Processed 20 files
Processed 30 files
Processed 40 files
Трассировка процесса с I/O (PID 777):
strace: Process 777 attached
Processed 50 files
Processed 60 files
Processed 70 files
Processed 80 files
Processed 90 files
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 28.11    0.000497           9        51           openat
 17.76    0.000314           5        56           write
 13.97    0.000247           4        52           clock_nanosleep
 13.74    0.000243           2       102           lseek
  9.67    0.000171           3        51           fstat
  8.82    0.000156           3        51        51 ioctl
  7.01    0.000124           2        51           close
  0.57    0.000010          10         1           brk
  0.34    0.000006           6         1           munmap
------ ----------- ----------- --------- --------- ----------------
100.00    0.001768           4       416        51 total

Проверка perf:
perf не установлен или недоступен в WSL2

Вывод: Данные из /proc полностью соответствуют системным утилитам. Небольшие расхождения объясняются:

Разными моментами времени снятия метрик
Разными единицами измерения (MiB vs KB)
Разными способами расчета CPU% (мгновенное vs среднее)


5. ОТВЕТЫ НА КОНТРОЛЬНЫЕ ВОПРОСЫ
Вопрос 1: Где в /proc/[pid]/stat и /proc/[pid]/status отражаются время в ядре/в юзере и состояние процесса?
Ответ:

В /proc/[pid]/stat:
Поле 3 (после имени процесса) — состояние (R/S/D/Z/T)
Поле 14 — utime (время в пользовательском режиме)
Поле 15 — stime (время в режиме ядра)
В /proc/[pid]/status:
Строка State: — состояние в читаемом виде
Времена CPU не представлены в status напрямую


Вопрос 2: Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?
Ответ:

RSS (Resident Set Size) получается из /proc/[pid]/status в строке VmRSS:
RssAnon — анонимная память (heap, stack, mmap без файла). Это "чистое" потребление RAM
RssFile — память, отображенная из файлов (исполняемый код, библиотеки, mmap файлов)
Важность: RSS = RssAnon + RssFile + RssShmem. RssAnon показывает реальное потребление памяти программой, RssFile может быть разделена между процессами

Вопрос 3: Как оценить IO-активность по /proc/[pid]/io и чем она отличается от «ожидания IO» в top/pidstat?
Ответ:

/proc/[pid]/io содержит счетчики:
read_bytes/write_bytes — реально прочитано/записано с диска
rchar/wchar — всего символов через read()/write() syscalls
Отличие от iowait:
/proc/[pid]/io — накопительные счетчики операций
iowait в top/pidstat — процент времени в состоянии D (ожидание I/O)
Процесс может иметь большие счетчики I/O, но малый iowait (если I/O быстрый)


Вопрос 4: Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?
Ответ:

HZ — частота таймера ядра (тиков в секунду), обычно 100 или 250
Времена в /proc/[pid]/stat указаны в тиках (jiffies)
Получение HZ: os.sysconf(os.sysconf_names['SC_CLK_TCK'])
Формула: CPU_time_seconds = (utime_jiffies + stime_jiffies) / HZ
В нашей системе HZ=100, поэтому 100 тиков = 1 секунда

Вопрос 5: Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?
Ответ:

Причины рассинхронизации:
Разное время снятия метрик (несколько мс разницы)
Кэширование данных в утилитах
Разные методы усреднения (мгновенное vs среднее)
Округление при форматировании
Критичность:
Для мониторинга — некритично (погрешность <1%)
Для профилирования — может быть важно (используйте perf)
Для биллинга — критично (нужны накопительные счетчики)


ОТЧЕТ по Лабораторной работе №3
/proc, собственные метрики и диагностика
Студент: Курда Кирилл

Группа: 9, подгруппа 2

Дата выполнения: 25.10.2024

Окружение: WSL2 (Windows Subsystem for Linux 2), Ubuntu 24.04 LTS

1. ЦЕЛЬ РАБОТЫ
Целью данной лабораторной работы является:

Изучение файловой системы /proc в Linux и извлечение метрик процессов напрямую из неё
Создание собственной утилиты pstat для анализа процессов
Сопоставление данных из /proc с системными утилитами (ps, top, pidstat)
Освоение базовой диагностики приложений с помощью strace
2. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ
2.1 Файловая система /proc
/proc — это виртуальная файловая система в Linux, которая предоставляет интерфейс к внутренним структурам ядра. Она не хранит реальные файлы на диске, а генерирует их содержимое динамически при обращении.

Для каждого процесса в системе создается директория /proc/[PID]/, содержащая информацию о процессе:

/proc/[PID]/stat — базовая статистика процесса в одной строке
/proc/[PID]/status — расширенная информация в читаемом формате
/proc/[PID]/io — статистика ввода-вывода
/proc/[PID]/cmdline — командная строка запуска процесса
/proc/[PID]/comm — имя команды
2.2 Ключевые метрики процессов
CPU время:

utime — время выполнения в пользовательском режиме (в тиках)
stime — время выполнения в режиме ядра (в тиках)
Для перевода в секунды используется константа HZ (обычно 100 тиков/сек)
Память:

VmRSS (Resident Set Size) — физическая память, используемая процессом
RssAnon — анонимная память (heap, stack)
RssFile — память, отображенная из файлов (код программы, библиотеки)
Переключения контекста:

voluntary_ctxt_switches — добровольные (процесс сам отдал CPU)
nonvoluntary_ctxt_switches — принудительные (планировщик забрал CPU)
3. РЕАЛИЗАЦИЯ
3.1 Структура проекта
bash
Копировать код
lab3/gr9sub2/КУРДА_КИРИЛЛ/
├── src/
│   └── pstat.py      # Основная утилита для анализа процессов
├── run.sh            # Скрипт демонстрации и тестирования
├── README.md         # Инструкции по запуску
└── REPORT.MD         # Данный отчет
3.2 Утилита pstat
Разработана утилита pstat.py на Python, которая:

Парсит файлы /proc:

python
Выполнить код
Копировать код
def parse_proc_stat(pid):
    with open(f'/proc/{pid}/stat', 'r') as f:
        stat = f.read().strip()
    # Извлечение полей после имени процесса в скобках
    end_paren = stat.rfind(')')
    fields = stat[end_paren + 2:].split()
Форматирует вывод в читаемый вид:

python
Выполнить код
Копировать код
def format_bytes(bytes_val, unit='B'):
    for unit_name in ['', 'Ki', 'Mi', 'Gi', 'Ti']:
        if abs(bytes_val) < 1024.0:
            return f"{bytes_val:.2f} {unit_name}{unit}"
        bytes_val /= 1024.0
Вычисляет производные метрики:

python
Выполнить код
Копировать код
hz = get_hz()  # Получаем HZ через os.sysconf
cpu_time = (stat['utime'] + stat['stime']) / hz
rss_mb = status['VmRSS'] / (1024 * 1024)
4. ЭКСПЕРИМЕНТЫ И РЕЗУЛЬТАТЫ
4.1 Базовая демонстрация
Анализ процесса init (PID 1):

yaml
Копировать код
Command: systemd
State: S (Sleeping)
Threads: 1
CPU time: 0.38 sec (User: 0.16, System: 0.22)
VmRSS: 12.57 MiB
Анализ процесса sleep:

yaml
Копировать код
Command: sleep
State: S (Sleeping)
CPU time: 0.00 sec
VmRSS: 1.05 MiB
RssAnon: 88.00 KiB (stack/heap)
RssFile: 988.00 KiB (код и библиотеки)
4.2 Тестирование с нагрузками
CPU-интенсивный процесс:

python
Выполнить код
Копировать код
# Создан процесс с циклом вычислений
State: R (Running)
Total CPU time: 1.02 sec после 1 секунды работы
Memory-интенсивный процесс (выделено 50 МБ):

makefile
Копировать код
VmRSS: 59.69 MiB
RssAnon: 53.63 MiB (выделенные 50 МБ + служебные)
RssFile: 6.06 MiB (код Python и библиотеки)
4.3 Сравнение с системными утилитами
Метрика	pstat	ps aux	pidstat	Комментарий
PID	768	768	768	Полное совпадение
CPU%	Total: 0.01s	1.8%	0.00%	ps показывает среднее с момента запуска
Memory	9.78 MiB	RSS: 10016 KB	-	Небольшая разница из-за момента снятия
State	S (Sleeping)	STAT: S+	-	Совпадает, + означает foreground
Вывод: Данные из /proc полностью соответствуют системным утилитам. Небольшие расхождения объясняются:

Разными моментами времени снятия метрик
Разными единицами измерения (MiB vs KB)
Разными способами расчета CPU% (мгновенное vs среднее)
4.4 Диагностика с strace
Анализ системных вызовов процесса с I/O операциями:

perl
Копировать код
% time     calls    syscall
------ --------- ----------------
 28.11        51    openat       # Открытие файлов
 17.76        56    write        # Запись данных
 13.97        52    clock_nanosleep # Задержки
 13.74       102    lseek        # Позиционирование в файле
  9.67        51    fstat        # Получение информации о файле
Интерпретация:

Процесс активно работает с файлами (28% времени на открытие)
Использует задержки между операциями (14% на sleep)
Типичный паттерн для I/O-интенсивного приложения
5. ОТВЕТЫ НА КОНТРОЛЬНЫЕ ВОПРОСЫ
Вопрос 1: Где в /proc/[pid]/stat и /proc/[pid]/status отражаются время в ядре/в юзере и состояние процесса?
Ответ:

В /proc/[pid]/stat:
Поле 3 (после имени процесса) — состояние (R/S/D/Z/T)
Поле 14 — utime (время в пользовательском режиме)
Поле 15 — stime (время в режиме ядра)
В /proc/[pid]/status:
Строка State: — состояние в читаемом виде
Времена CPU не представлены в status напрямую


Вопрос 2: Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?
Ответ:

RSS (Resident Set Size) получается из /proc/[pid]/status в строке VmRSS:
RssAnon — анонимная память (heap, stack, mmap без файла). Это "чистое" потребление RAM
RssFile — память, отображенная из файлов (исполняемый код, библиотеки, mmap файлов)
Важность: RSS = RssAnon + RssFile + RssShmem. RssAnon показывает реальное потребление памяти программой, RssFile может быть разделена между процессами


Вопрос 3: Как оценить IO-активность по /proc/[pid]/io и чем она отличается от «ожидания IO» в top/pidstat?
Ответ:

/proc/[pid]/io содержит счетчики:
read_bytes/write_bytes — реально прочитано/записано с диска
rchar/wchar — всего символов через read()/write() syscalls
Отличие от iowait:
/proc/[pid]/io — накопительные счетчики операций
iowait в top/pidstat — процент времени в состоянии D (ожидание I/O)
Процесс может иметь большие счетчики I/O, но малый iowait (если I/O быстрый)


Вопрос 4: Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?
Ответ:

HZ — частота таймера ядра (тиков в секунду), обычно 100 или 250
Времена в /proc/[pid]/stat указаны в тиках (jiffies)
Получение HZ: os.sysconf(os.sysconf_names['SC_CLK_TCK'])
Формула: CPU_time_seconds = (utime_jiffies + stime_jiffies) / HZ
В нашей системе HZ=100, поэтому 100 тиков = 1 секунда


Вопрос 5: Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?
Ответ:

Причины рассинхронизации:
Разное время снятия метрик (несколько мс разницы)
Кэширование данных в утилитах
Разные методы усреднения (мгновенное vs среднее)
Округление при форматировании
Критичность:
Для мониторинга — некритично (погрешность <1%)
Для профилирования — может быть важно (используйте perf)
Для биллинга — критично (нужны накопительные счетчики)


Вопрос 6: Что показывает strace -c и как интерпретировать perf stat?
Ответ:

strace -c — статистика системных вызовов:
% time — доля времени на каждый тип syscall
calls — количество вызовов
errors — количество ошибок
Помогает найти узкие места в I/O и системных операциях
perf stat (недоступен в WSL2):
cycles — такты процессора
instructions — выполненные инструкции
IPC (instructions per cycle) — эффективность использования CPU
branches/branch-misses — статистика переходов



6. ВЫВОДЫ
Успешно реализована утилита pstat, которая извлекает и форматирует метрики процессов напрямую из /proc

Подтверждена корректность данных путем сравнения с системными утилитами (ps, pidstat). Расхождения минимальны и объяснимы

Изучена структура /proc:

/proc/[pid]/stat содержит базовые метрики в компактном формате
/proc/[pid]/status предоставляет расширенную информацию в читаемом виде
/proc/[pid]/io позволяет отслеживать I/O активность
Освоена диагностика с strace: продемонстрирован анализ системных вызовов I/O-интенсивного процесса

Ограничения WSL2:

perf недоступен из-за отсутствия прямого доступа к аппаратным счетчикам
Некоторые файлы /proc могут иметь ограниченную функциональность