# Отчёт по лабораторной 3 — /proc, собственные метрики и диагностика

**Окружение:** WSL2, Ubuntu 24.04.


## Цели
- Уверенно извлекать и интерпретировать метрики процесса из `/proc`.
- Сопоставлять показатели `/proc` с утилитами `ps`, `top`, `pidstat`.
- Освоить базовую диагностику приложений: системные вызовы и аппаратные счётчики.


## Файлы и запуск
- `src/pstat.py` — утилита, читающая `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io`, `/proc/<pid>/smaps_rollup`.
- `run.sh` — вспомогательный скрипт.

Запуск (пример):
```bash
./src/pstat.py <pid>
# или
./run.sh <pid>
```


## Эксперимент — план и команды (как воспроизвести)

1. **Подготовка** — запустить нагрузочный процесс (пример):
```bash
# CPU-утяжелитель (пример)
# Установите stress-ng, если нужно: sudo apt install stress-ng
stress-ng --cpu 1 --timeout 30s &
PID=$!
```

2. **Собрать метрики pstat**:
```bash
./src/pstat.py $PID
```

3. **Сравнить с ps / top / pidstat**:
```bash
ps -p $PID -o pid,ppid,comm,stime,time,pcpu,rss,vsz
top -b -n 1 -p $PID | sed -n '1,20p'
pidstat -p $PID 1 1
```

4. **Системные вызовы и диагоз**:
```bash
# краткая статистика по системным вызовам
sudo strace -c -p $PID -t -o strace.out
```


## Фрагменты вывода

Ниже — фрагменты вывода, полученные при запуске `stress-ng --cpu 1 --timeout 300s & PID=$!` в WSL2.

```
$ ./run.sh 27917
PID: 27917
PPid: 18541
Threads: 1
State: S
utime: 6 ticks
stime: 12 ticks
CPU time sec: 0.18 sec (HZ=100)
voluntary_ctxt_switches: 525
nonvoluntary_ctxt_switches: 0
VmRSS: 60560 KiB (59.141 MiB)
RssAnon: N/A
RssFile: N/A
read_bytes: 67129344 bytes (64.020 MiB)
write_bytes: 0 bytes (0 B)
```

`ps`:

```
    PID    PPID COMMAND         STIME     TIME %CPU   RSS    VSZ
  27917   18541 stress-ng       22:53 00:00:00  0.4 60560 251132
```

`top`:

```
top - 22:53:52 up  2:12,  1 user,  load average: 0.64, 0.19, 0.10
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s): 77.5 us,  0.0 sy,  0.0 ni, 22.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st 
MiB Mem :   3836.9 total,   2185.2 free,   1557.1 used,    335.2 buff/cache     
MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   2279.8 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  27917 testial   20   0  251132  60560  51496 S   0.0   1.5   0:00.18 stress-+

Linux 5.15.167.4-microsoft-standard-WSL2 (Lenovo)       10/02/25        _x86_64_        (4 CPU)
```

`pidstat`:

```
22:53:52      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
22:53:53     1001     27917    0.00    0.00    0.00    0.00    0.00     3  stress-ng
Average:     1001     27917    0.00    0.00    0.00    0.00    0.00     -  stress-ng
```


## Сопоставление полей `pstat` и `ps`/`top`/`pidstat`

- **utime/stime** (`/proc/*/stat` fields 14/15) → `ps`/`top` поле `TIME` и `pidstat` значение CPU time (но `TIME` часто форматируется в [[dd-]hh:]mm:ss и агрегируется с момента старта).
- **VmRSS** (`/proc/*/status`) → `ps`/`top` `RSS` (в килобайтах). Нужно учесть, что `top` / `ps` иногда показывают значение в KiB или в страницах (зависит от версии и опций).
- **RssAnon / RssFile** (`/proc/*/smaps_rollup`) — разбивка RSS на анонимные и файлобекдед: `ps`/`top` не дают такой детализации.
- **read_bytes / write_bytes** (`/proc/*/io`) — абсолютные счётчики байт, прочитанных/записанных процессом; `pidstat -d` может показывать похожие числа, но `pidstat` даёт статистику по интервалу (разница в значениях зависит от момента выборки).
- **Context switches** (`voluntary_ctxt_switches` и `nonvoluntary_ctxt_switches`) — в `top` можно увидеть частные показатели состояния, но явной колонки для переключений там обычно нет; `pidstat -w` показывает переключения контекста по интервалу.


## Ответы на вопросы

### 1) Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?
- В `/proc/<pid>/stat` поля **utime** (поле 14) и **stime** (поле 15) — количество тактов процессора (clock ticks), проведённых в пользовательском и ядровом режиме соответственно. Поле `state` (поле 3) содержит код состояния процесса (`R`, `S`, `D`, `Z` и т.д.).
- В `/proc/<pid>/status` есть текстовые строки `State: ...` (с тем же символом и расшифровкой) и дополнительные удобные поля для человека.

### 2) Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`? Почему они важны?
- `RSS` (Resident Set Size) можно получить из `/proc/<pid>/status` (поле `VmRSS`) или частично — из `/proc/<pid>/stat` (поле `rss`, в страницах). `VmRSS` даёт значение в kB, удобное для чтения.
- `RssAnon` — количество резидентных страниц, не связанных с файлом (heap/stack/anon mappings). `RssFile` — резидентные страницы, связанные с файловыми отображениями (shared libs, mmap с файлами). Эти метрики важны для понимания: сколько памяти можно потенциально освободить (файловые страницы могут быть перекрыты/удалены) и сколько памяти приватно занято процессом (анон).

### 3) Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top/pidstat`?
- `/proc/<pid>/io` содержит абсолютные счётчики: `read_bytes`, `write_bytes`, `syscr`/`syscw` и т.д. Эти числа показывают сколько байт было прочитано/записано, инициированных процессом.
- `top`/`pidstat` часто показывают **время ожидания IO** или **IO за интервал** (например, `pidstat -d`), либо агрегаты, связанные с загрузкой диска. `iowait` в `top` — системный показатель, показывающий, сколько CPU тратится на ожидание операций ввода-вывода на всей системе, а не только этим процессом.

### 4) Что означает делитель `HZ` и как корректно посчитать `CPU time sec = (utime+stime)/HZ`?
- `HZ` — число тиков в секунду (clock ticks per second). Значение платформозависимое, чаще 100 или 250 или 1000; на современных Linux обычно 100. Чтобы корректно посчитать секунды, нужно использовать текущее значение HZ:
```python
import os
hz = os.sysconf('SC_CLK_TCK')
seconds = (utime + stime) / hz
```
Это конвертирует такты в секунды.

### 5) Почему возможны рассинхронизации между `/proc` и выводом `ps/top`? Когда это критично?
- Причины рассинхронизации:
  - **Время выборки** — `/proc` показывает моментальный снимок в момент чтения; `ps`/`top` могут проводить агрегации/вычисления за интервал или опрашивать несколько файлов с небольшой задержкой.
  - **Преобразования/агрегация** — `ps`/`top` форматируют значения (например, `TIME` в часы/минуты) или вычисляют проценты ( `%CPU` ) за заданный интервал.
  - **Права доступа** — некоторые поля могут быть скрыты или доступны только root (например, подробные smaps), что приводит к неполным данным у пользователя.
  - **Кэширование/делай/лаковые обновления** — в больших системах распределённые сборщики/демоны мониторят и агрегируют с собственной логикой.
- Когда критично: при отладке проблем с памятью/IO/CPU для точной диагностики — расхождения влияют на выводы. Для трассировки и постфактного анализа всегда фиксируйте временные метки и используйте одно и то же средство (или снимайте /proc в одно и то же мгновение) для корректного сравнения.


## Выводы
- `/proc` даёт самую «низкоуровневую» и точную информацию на момент чтения; утилита `pstat` просто собирает и форматирует её.
- `ps`/`top`/`pidstat` удобны для обзора и агрегации, но могут показывать другие представления (интервальные/процентные), поэтому сопоставление требует внимательности к моментам выборки и единицам измерения.
- Для финальной диагностики можно сочетать: `/proc` (точность), `strace` (системные вызовы) и `perf` (аппаратные счётчики).
