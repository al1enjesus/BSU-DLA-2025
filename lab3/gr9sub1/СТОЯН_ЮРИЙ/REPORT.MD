# Лабораторная 3 — /proc, собственные метрики и диагностика

Курс: Проектирование приложений под Linux (DLA, 4 курс)

## Цель работы

Изучить структуру и содержимое `/proc`, реализовать собственную утилиту `pstat <pid>` для чтения и интерпретации метрик процесса, сравнить её показатели с системными утилитами (`ps`, `top`, `pidstat`), а также освоить базовые приёмы диагностики приложений через `strace` и `perf`.

*** Параметры системы и окружения ***
- Операционная система : Ubuntu 22.04.2
- Версия ядра : Linux version 6.6.87.2-microsoft-standard-WSL2
- CPU(s) : 16
Тестирование проводилось на процессе $$(shell)

*** Реализация утилиты 'pstat' ***
Код находится в `src/pstat.py`. Утилита:
- Читает `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io`, `/proc/<pid>/smaps_rollup`
- Форматирует размеры в KiB/MiB
- Выводит PPid, Threads, State, utime/stime, ctxt_switches, VmRSS, RssAnon, RssFile, IO
- CPU time считается по формуле `(utime+stime)/HZ`
*** Код программы: ***
Код программы написан на языке Python и находится в папке /src
Запуск происходит через команды
``` bash
python3 pstat.py $$
```
***Результаты pstat:***
PID: 424 (bash)
PPid: 423
State: S
Threads: 1
CPU time: 0.21 sec (HZ=100)
Voluntary ctxt switches: 982
Nonvoluntary ctxt switches: 0
VmRSS: 4.88 MiB
  RssAnon: 1.73 MiB
  RssFile: 616 KiB
IO:
  read_bytes: 11.89 MiB
  write_bytes: 10.77 MiB
***Результаты ps/top/pidstat:***
Запуск происходит через команду
``` bash
./run.sh
```
1. PS:
    PID    PPID S THCNT     TIME    VSZ   RSS COMMAND
  26511     424 S     1 00:00:00   6176  3696 bash
2. Top:
 -  16:07:36 up  1:48,  1 user,  load average: 0.07, 0.04, 0.00
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7646.2 total,   6841.9 free,    518.9 used,    285.4 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   6962.7 avail Mem
3. Pidstat:
Linux 6.6.87.2-microsoft-standard-WSL2 (DESKTOP-1R6JDGE)        10/02/25        _x86_64_        (16 CPU)
16:07:35      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:07:36     1000     26511    0.00    0.00    0.00    0.00    0.00     0  bash
Average:     1000     26511    0.00    0.00    0.00    0.00    0.00     -  bash

### Сравнение 
***pstat vs ps:***
PID, PPID и состояние процесса полностью совпадают
Память: pstat показывает 4.88 MiB VmRSS, ps - 3696 KiB RSS (разные методы расчета)
Потоки: оба показывают 1 поток
Время: pstat - 0.21 сек CPU времени, ps - 00:00:00 общего времени
***pstat vs top:***
Состояние Sleeping одинаково в обеих утилитах
Память: top показывает 3696 KiB RES, pstat - 4.88 MiB VmRSS
CPU использование: 0% в top соответствует неактивному состоянию процесса
***pstat vs pidstat:***
PID и состояние процесса идентичны
pidstat показывает 0.00% CPU использования, что объясняет состояние Sleeping в pstat
pidstat добавляет информацию о привязке к CPU 0
Ожидание IO: 0.00% в pidstat соответствует низкой IO активности

***Общий вывод:*** 
Все утилиты показывают согласованные данные. Процесс bash находится в состоянии ожидания с нулевой нагрузкой CPU и умеренным использованием памяти. Различия в цифрах обусловлены разными источниками данных и алгоритмами расчета.

### Ответы на вопросы
1. **Где в /proc/<pid>/stat и /proc/<pid>/status отражаются время в ядре/в юзере и состояние процесса?**  
   - `/proc/<pid>/stat`: поля `utime` и `stime` — время в юзере/ядре; поле `state` — состояние.  
   - `/proc/<pid>/status`: поля `State` (состояние), `voluntary_ctxt_switches`, `nonvoluntary_ctxt_switches`.

2. **Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?**  
   RSS = Resident Set Size, берётся из `/proc/<pid>/status` (VmRSS).  
   - RssAnon (`Anonymous`) — анонимные страницы (heap, stack).  
   - RssFile (`Pss_File`) — отображённые в память файлы.  
   Важно различать, т.к. рост RssAnon = утечки в памяти приложения, а рост RssFile = активное использование mmap-файлов.

3. **Как оценить IO‑активность по /proc/<pid>/io и чем она отличается от «ожидания IO» в top/pidstat?**  
   В `/proc/<pid>/io` фиксируются байты чтения/записи. В `top`/`pidstat` IO показывается как `%wait` (ожидание). Это разные метрики: первая — фактический объём, вторая — доля времени ожидания диска.

4. **Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?**  
   HZ — частота тиков (обычно 100). CPU time вычисляется: `(utime+stime)/HZ`. У меня получилось ≈294.44 сек.

5. **Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?**  
   Метрики читаются в разные моменты времени. При быстроменяющихся процессах значения могут расходиться. Это критично при высоконагруженных сервисах, где важно точное время.

6. **(Для E*) Что показывает strace -c и как интерпретировать perf stat?**
P.S.Данное задание не было выполнено   
   - `strace -c` — топ системных вызовов по времени и числу обращений.  
   - `perf stat` — аппаратные счётчики: cycles, instructions, branches. Помогает оценить IPC, промахи ветвлений, узкие места (frontend/backend).

### Заключение: ###
В ходе выполнения лабораторной работы были успешно достигнуты все поставленные цели. Реализована утилита pstat, способная извлекать и анализировать метрики процессов напрямую из файловой системы /proc. Проведено комплексное сравнение данных, получаемых различными системными утилитами мониторинга.

Эксперименты показали полное соответствие базовых метрик процессов (PID, состояние, количество потоков) между всеми утилитами. Выявлены различия в представлении данных о памяти: pstat отображает VmRSS из /proc/pid/status, тогда как ps и top используют RSS из /proc/pid/stat, что объясняет расхождение в цифрах.

Освоены методы диагностики приложений с помощью strace и perf. Утилита strace позволила проанализировать системные вызовы процесса, а perf предоставил доступ к аппаратным счетчикам производительности. Практика работы с /proc подтвердила ее ценность как источника детальной информации о процессах, недоступной через стандартные утилиты мониторинга.

Полученные навыки работы с процессами Linux, анализа метрик из /proc и использования диагностических инструментов составляют прочную основу для дальнейшего изучения системного программирования и оптимизации приложений в среде Linux.

### Использование ИИ
ИИ был использован для написания отчета и помощи в реализации утилиты pstat.