\# Отчёт по лабораторной работе: Утилита `pstat`



\## Цель работы

Разработать системную утилиту на языке C для получения информации о процессах Linux через файловую систему `/proc`, аналогичную стандартным утилитам `ps`, `top` и `pidstat`.



\## Задание C: Реализация утилиты `pstat`



\### Описание реализации



Утилита `pstat` считывает и обрабатывает информацию о процессе из следующих файлов `/proc`:



1\. \*\*`/proc/<pid>/stat`\*\* - базовая информация о процессе

2\. \*\*`/proc/<pid>/status`\*\* - расширенная информация о статусе

3\. \*\*`/proc/<pid>/io`\*\* - статистика ввода-вывода



\### Архитектура программы



\#### Основные структуры данных:



```c

// Данные из /proc/<pid>/stat

typedef struct {

&nbsp;   int pid;                    // PID процесса

&nbsp;   char comm\[256];             // Имя команды

&nbsp;   char state;                 // Состояние процесса

&nbsp;   int ppid;                   // PID родительского процесса

&nbsp;   unsigned long utime;        // Время в режиме пользователя (тики)

&nbsp;   unsigned long stime;        // Время в режиме ядра (тики)

&nbsp;   long num\_threads;           // Количество потоков

} proc\_stat\_t;



// Данные из /proc/<pid>/status

typedef struct {

&nbsp;   unsigned long vm\_rss;                      // Резидентная память

&nbsp;   unsigned long rss\_anon;                    // Анонимная память

&nbsp;   unsigned long rss\_file;                    // Файловая память

&nbsp;   unsigned long voluntary\_ctxt\_switches;     // Добровольные переключения контекста

&nbsp;   unsigned long nonvoluntary\_ctxt\_switches;  // Принудительные переключения контекста

} proc\_status\_t;



// Данные из /proc/<pid>/io

typedef struct {

&nbsp;   unsigned long read\_bytes;   // Прочитано байт

&nbsp;   unsigned long write\_bytes;  // Записано байт

} proc\_io\_t;

```



\#### Ключевые функции:



\- `read\_proc\_file()` - безопасное чтение файлов из `/proc`

\- `parse\_proc\_stat()` - парсинг `/proc/<pid>/stat` с обработкой всех полей

\- `parse\_proc\_status()` - извлечение метрик памяти и переключений контекста

\- `parse\_proc\_io()` - получение статистики ввода-вывода

\- `format\_size()` - форматирование размеров в человекочитаемый вид (KiB/MiB)



\### Результаты тестирования



Тестирование проводилось на процессе `bash` (PID 16501) в среде WSL2.



\#### Сравнительная таблица метрик:



| Метрика | `/proc` | `pstat` | Совпадение |

|---------|---------|---------|------------|

| \*\*PPid\*\* | 406 | 406 | ✓ |

| \*\*State\*\* | S | S | ✓ |

| \*\*Threads\*\* | 1 | 1 | ✓ |

| \*\*utime\*\* | 0 тиков | 0 тиков | ✓ |

| \*\*stime\*\* | 0 тиков | 0 тиков | ✓ |

| \*\*CPU time\*\* | 0.00 сек | 0.00 сек | ✓ |

| \*\*VmRSS\*\* | 3584 kB | 3.50 MiB | ✓ |

| \*\*RssAnon\*\* | 384 kB | 384 KiB | ✓ |

| \*\*RssFile\*\* | 3200 kB | 3.12 MiB | ✓ |

| \*\*read\_bytes\*\* | 0 | 0 KiB | ✓ |

| \*\*write\_bytes\*\* | 0 | 0 KiB | ✓ |



\#### Проверка корректности вычислений:



\*\*CPU time:\*\*

\- Формула: `(utime + stime) / HZ`

\- Расчет: `(0 + 0) / 100 = 0.00` сек

\- Результат: ✓ Корректно



\*\*Форматирование размеров:\*\*

\- 3584 kB → 3.50 MiB ✓

\- 3200 kB → 3.12 MiB ✓

\- 384 kB → 384 KiB ✓



\### Сравнение с системными утилитами



\#### `ps` (Process Status):

```

PID: 16501, PPID: 406, State: S, RSS: 3584 kB

```

\*\*Вывод:\*\* Все основные метрики совпадают.



\#### `top`:

```

VIRT: 4916 kB, RES: 3584 kB, SHR: 3200 kB

%CPU: 0.0%, %MEM: 0.0%

```

\*\*Вывод:\*\* Показатели памяти идентичны.



\#### `pidstat`:

```

%usr: 0.00%, %system: 0.00%, %CPU: 0.00%

```

\*\*Вывод:\*\* Нулевая загрузка CPU подтверждена.



\### Особенности реализации



1\. \*\*Парсинг `/proc/<pid>/stat`\*\*: Корректная обработка имени процесса в скобках, токенизация строки по пробелам



2\. \*\*Конвертация единиц измерения\*\*: 

&nbsp;  - Тики → секунды с использованием `HZ=100`

&nbsp;  - Килобайты → MiB/KiB для читаемости



3\. \*\*Обработка ошибок\*\*: Graceful degradation при отсутствии доступа к `/proc/<pid>/io` (требует root)



4\. \*\*Форматирование вывода\*\*: Выравнивание полей для улучшения читаемости



---



\## Ответы на контрольные вопросы



\### 1. Что такое файловая система `/proc`?



\*\*`/proc`\*\* — это виртуальная (псевдо) файловая система в Linux, которая не существует на физическом диске, а создаётся ядром в оперативной памяти во время работы системы. Она предоставляет интерфейс для доступа к информации о процессах и системе через файловый API.



\*\*Основные характеристики:\*\*

\- Содержимое генерируется динамически при чтении

\- Размер файлов обычно показывается как 0 байт

\- Предоставляет информацию в текстовом формате

\- Позволяет не только читать, но и изменять параметры ядра (например, через `/proc/sys`)



\*\*Структура:\*\*

\- `/proc/<pid>/` — директории для каждого процесса

\- `/proc/cpuinfo` — информация о процессоре

\- `/proc/meminfo` — информация о памяти

\- `/proc/sys/` — параметры конфигурации ядра



\### 2. Какие файлы в `/proc/<pid>/` содержат информацию о процессе?



\*\*Основные файлы:\*\*



| Файл | Описание |

|------|----------|

| \*\*`stat`\*\* | Основная статистика процесса (PID, состояние, время CPU, память) |

| \*\*`status`\*\* | Детальная информация в человекочитаемом формате |

| \*\*`cmdline`\*\* | Командная строка запуска процесса (аргументы разделены `\\0`) |

| \*\*`environ`\*\* | Переменные окружения процесса |

| \*\*`maps`\*\* | Карта памяти процесса (адреса, разрешения, файлы) |

| \*\*`fd/`\*\* | Директория с символическими ссылками на открытые файловые дескрипторы |

| \*\*`io`\*\* | Статистика ввода-вывода (требует привилегий) |

| \*\*`limits`\*\* | Ограничения ресурсов (ulimit) |

| \*\*`cgroup`\*\* | Информация о cgroups |

| \*\*`exe`\*\* | Символическая ссылка на исполняемый файл |

| \*\*`cwd`\*\* | Символическая ссылка на текущую рабочую директорию |



\### 3. Как интерпретировать содержимое `/proc/<pid>/stat`?



Файл `/proc/<pid>/stat` содержит \*\*одну строку\*\* с числовыми полями, разделёнными пробелами.



\*\*Формат (основные поля):\*\*

```

pid (comm) state ppid pgrp session tty\_nr tpgid flags ... utime stime ... num\_threads ...

1   2      3     4    5    6       7      8     9      14    15          20

```



\*\*Ключевые поля:\*\*

\- \*\*1. pid\*\* — идентификатор процесса

\- \*\*2. comm\*\* — имя команды в скобках, например `(bash)`

\- \*\*3. state\*\* — состояние: `R` (running), `S` (sleeping), `D` (disk sleep), `Z` (zombie), `T` (stopped)

\- \*\*4. ppid\*\* — PID родительского процесса

\- \*\*14. utime\*\* — время в режиме пользователя (в тиках)

\- \*\*15. stime\*\* — время в режиме ядра (в тиках)

\- \*\*20. num\_threads\*\* — количество потоков



\*\*Особенности парсинга:\*\*

\- Поле `comm` может содержать пробелы и скобки

\- Необходимо корректно обрабатывать имя, заключённое в скобки

\- Все временные значения в тиках (обычно 1 тик = 1/100 секунды)



\*\*Пример из теста:\*\*

```

16501 (bash) S 406 ... 0 0 ... 1

```

\- PID: 16501

\- Команда: bash

\- Состояние: S (sleeping)

\- PPID: 406

\- utime: 0, stime: 0

\- Потоков: 1



\### 4. Что означают поля `utime` и `stime`? Как их преобразовать в секунды?



\*\*`utime` (user time)\*\* — количество тактов CPU, потраченных процессом в \*\*режиме пользователя\*\* (выполнение кода приложения).



\*\*`stime` (system time)\*\* — количество тактов CPU, потраченных в \*\*режиме ядра\*\* (системные вызовы, операции ввода-вывода).



\*\*Преобразование в секунды:\*\*



Значения даны в \*\*тиках (clock ticks)\*\*. Для преобразования используется константа `HZ` — частота системного таймера.



```c

\#define HZ 100  // стандартное значение для большинства систем



double cpu\_time\_seconds = (utime + stime) / (double)HZ;

```



\*\*Определение HZ:\*\*

\- Стандартные значения: 100, 250, 300, 1000 Hz

\- Можно получить программно через `sysconf(\_SC\_CLK\_TCK)`

\- Обычно HZ = 100 (100 тиков в секунду)



\*\*Пример из теста:\*\*

```c

utime = 0, stime = 0

CPU time = (0 + 0) / 100 = 0.00 сек

```



\*\*Практическое применение:\*\*

\- Мониторинг загрузки процесса

\- Вычисление %CPU: `100 \* (utime + stime) / (uptime \* HZ)`

\- Анализ производительности (больше stime → больше системных вызовов)



\### 5. Какие метрики памяти доступны в `/proc/<pid>/status`?



Файл `/proc/<pid>/status` предоставляет детальную информацию о памяти процесса:



\*\*Виртуальная память:\*\*

\- \*\*`VmPeak`\*\* — пиковый размер виртуальной памяти

\- \*\*`VmSize`\*\* — текущий размер виртуальной памяти

\- \*\*`VmLck`\*\* — заблокированная память (не может быть выгружена в swap)

\- \*\*`VmPin`\*\* — закреплённая память

\- \*\*`VmHWM`\*\* — пиковый размер резидентной памяти

\- \*\*`VmRSS`\*\* — \*\*резидентная память\*\* (физическая RAM)



\*\*Компоненты RSS:\*\*

\- \*\*`RssAnon`\*\* — анонимная память (heap, stack, не связанная с файлами)

\- \*\*`RssFile`\*\* — файловая память (mmap файлов, shared libraries)

\- \*\*`RssShmem`\*\* — разделяемая память



\*\*Другие метрики:\*\*

\- \*\*`VmData`\*\* — размер сегмента данных (heap)

\- \*\*`VmStk`\*\* — размер стека

\- \*\*`VmExe`\*\* — размер кода программы

\- \*\*`VmLib`\*\* — размер подключённых библиотек

\- \*\*`VmSwap`\*\* — объём в swap



\*\*Пример из теста:\*\*

```

VmRSS:    3584 kB  (резидентная память)

RssAnon:   384 kB  (heap/stack)

RssFile:  3200 kB  (загруженные библиотеки/код)

```



\*\*Важное соотношение:\*\*

```

VmRSS = RssAnon + RssFile + RssShmem

3584 = 384 + 3200 + 0 ✓

```



\### 6. Для чего нужны переключения контекста (context switches)?



\*\*Context switch\*\* — это процесс сохранения состояния текущего процесса и загрузки состояния другого процесса планировщиком ядра.



\*\*Два типа:\*\*



\*\*1. Voluntary (добровольные)\*\* — процесс сам отдаёт CPU:

\- Ожидание I/O операции (чтение с диска, сети)

\- Вызов `sleep()`, `wait()`

\- Ожидание блокировки (mutex, semaphore)

\- Процесс заблокирован и не может продолжить выполнение



\*\*2. Nonvoluntary (принудительные)\*\* — планировщик принудительно прерывает процесс:

\- Истёк квант времени (time slice)

\- Появился процесс с более высоким приоритетом

\- Процесс активно использует CPU и монополизирует ресурсы



\*\*Метрики в `/proc/<pid>/status`:\*\*

```

voluntary\_ctxt\_switches:    3    (процесс добровольно ждал)

nonvoluntary\_ctxt\_switches: 0    (не был прерван планировщиком)

```



\*\*Интерпретация:\*\*

\- \*\*Высокие voluntary\*\* → процесс I/O-bound (много ждёт)

\- \*\*Высокие nonvoluntary\*\* → процесс CPU-bound (активные вычисления)

\- \*\*Низкие оба\*\* → процесс малоактивен (как bash в тесте)



\*\*Накладные расходы:\*\*

\- Context switch занимает ~1-10 мкс

\- Сбрасывается кэш TLB (Translation Lookaside Buffer)

\- Много переключений снижает производительность



---



\## Выводы



1\. Утилита `pstat` \*\*корректно\*\* извлекает информацию из файловой системы `/proc`

2\. Все метрики \*\*идентичны\*\* данным системных утилит (`ps`, `top`, `pidstat`)

3\. Вычисление CPU time и форматирование размеров работает \*\*точно\*\*

4\. Программа демонстрирует понимание структуры `/proc` и системных вызовов Linux

5\. Файловая система `/proc` предоставляет мощный и удобный интерфейс для мониторинга процессов без необходимости использования специальных системных вызовов



\*\*Задание выполнено полностью. Утилита работает корректно и соответствует требованиям.\*\*

