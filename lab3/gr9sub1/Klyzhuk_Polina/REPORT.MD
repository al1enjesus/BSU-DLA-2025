# Отчёт по лабораторной работе 3 — /proc, собственные метрики и диагностика

## Цель
- Научиться извлекать метрики процесса напрямую из файлов `/proc/<pid>`.
- Реализовать собственную утилиту `pstat <pid>` и сравнить её показания с системными утилитами (`ps`, `top`, `pidstat`).
- Освоить базовые средства диагностики приложений (`strace`, `perf`).
- Разобраться в ключевых метриках процессов: CPU time, RSS, IO-активность, контекстные переключения.

---

## Теоретическое обоснование
В Linux каждая программа представлена процессом. Для мониторинга процессов существует виртуальная файловая система `/proc`.  
- `/proc/<pid>/stat` содержит базовые числовые метрики процесса: идентификаторы, состояние, CPU-время в тиках (`utime`, `stime`), приоритет и др.  
- `/proc/<pid>/status` даёт более удобный для чтения формат с памятью (VmRSS, RssAnon, RssFile) и переключениями контекста.  
- `/proc/<pid>/io` отражает реальный объём операций чтения/записи.  
- `/proc/<pid>/smaps_rollup` позволяет агрегированно оценить использование памяти.  

Эти данные используют системные утилиты (`ps`, `top`, `pidstat`), но их можно прочитать и напрямую.  

---

## Задание С

### 1. Реализация утилиты

Создала файл `pstat.c` и Makefile (код приведён в `src/`).
Собрала утилиту:

```bash
make
```

### 2. Запуск эксперимента

Нашла PID процесса `bash`:

```bash
pidof bash
# -> 4361
```

Запустила утилиту:

```bash
./pstat 4361
```

Вывод:

```
Process 4361 ((bash))
  PPid: 4353
  State: S
  Threads: 1
  CPU time: 0.17 sec (utime+stime)
  Context switches: voluntary=70, nonvoluntary=1
  Memory:
    VmRSS: 6.33 MiB
    RssAnon: 2.25 MiB
    RssFile: 4.08 MiB
  IO:
    read_bytes: 29384704
    write_bytes: 20480
```

### 3. Сравнение с системными утилитами

```bash
ps -o pid,ppid,stat,time,rss,comm -p 4361
```

```
   PID  PPID STAT     TIME   RSS COMMAND
  4361  4353 S     00:00:00  6480 bash
```

```bash
top -p 4361 -b -n 1
```

```
  PID USER  PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
 4361 user  20   0   10984   6480   4148 S  0.0  0.1   0:00.17 bash
```

```bash
pidstat -p 4361 1
```

(фрагмент с CPU временем и IO, совпадает с нашими данными).

---

## Ответы на вопросы

1. **Время в ядре/в юзере и состояние процесса**

   * `/proc/<pid>/stat`: 14-е поле `utime` (ticks в user mode), 15-е поле `stime` (ticks в kernel mode), 3-е поле `state`.
   * `/proc/<pid>/status`: строка `State:` — расшифровка состояния (Sleeping, Running и т.д.).

2. **RSS, RssAnon и RssFile**

   * `VmRSS` — фактический объём памяти, занимаемой процессом в ОЗУ.
   * `RssAnon` — анонимные страницы (куча, стэк, динамические данные).
   * `RssFile` — страницы, отображённые из файлов (код программы, mmap-библиотеки).
     Важно различать: если RssAnon растёт, это означает рост данных/кучи, а RssFile больше связано с загруженными библиотеками.

3. **IO-активность**

   * `/proc/<pid>/io`: `read_bytes` и `write_bytes` показывают реальный объём операций ввода/вывода.
   * В `top/pidstat` метрика `iowait` отражает не количество байт, а время, которое процесс простаивал, ожидая завершения операций. Это разные показатели.

4. **HZ и CPU time**

   * `HZ` — число тиков (jiffies) в секунду, обычно 100 или 250/1000 в зависимости от ядра.
   * Чтобы получить секунды: `(utime + stime) / HZ`. В моём случае это 0.17 сек.

5. **Рассинхронизации**

   * `/proc` читается в момент запроса, а `ps/top` могут обновляться с задержкой, усреднять данные или показывать срез времени.
   * Критично при анализе очень коротких процессов (они могут завершиться, пока смотришь).

---

## Выводы

* Утилита `pstat` корректно отображает данные из `/proc`.
* Значения совпадают с `ps`, `top`, `pidstat` (различия — из-за разных моментов съёмки).
* Метрики памяти дают понимание, какие страницы реально заняты в RAM.
* IO метрики `/proc` показывают байты, а в `top`/`pidstat` — время ожидания, что важно различать.
* Делитель `HZ` нужен для перевода тиков в секунды, без него CPU время будет некорректным.
* Рассинхронизация становится важной при короткоживущих или интенсивных процессах.
* Дополнительно с помощью `strace` и `perf` можно диагностировать системные вызовы и производительность на уровне CPU.

---

## Ограничения окружения

Работа выполнялась в виртуальной машине (Ubuntu в VirtualBox). Это значит:

* показания IO и CPU могут отличаться от «чистого» железа, т.к. часть операций виртуализирована;
* HZ может зависеть от конфигурации ядра гостевой ОС;
* `perf` и некоторые аппаратные счётчики могут быть недоступны без поддержки хоста.
