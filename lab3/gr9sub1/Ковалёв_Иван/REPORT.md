# Лабораторная 3 — /proc, собственные метрики и диагностика

## Цели
Уверенно извлекать и интерпретировать метрики процесса из `/proc`.
Сопоставлять показатели `/proc` с утилитами `ps`, `top`, `pidstat`.
Освоить базовую диагностику приложений: системные вызовы и аппаратные счётчики.

### C) /proc и собственная утилита pstat (обязательно)
Написать утилиту `pstat <pid>`, которая:
- Читает `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io`, `/proc/<pid>/smaps_rollup` (если есть).
- Выводит краткую сводку: `PPid`, `Threads`, `State`, `utime/stime`, `voluntary_ctxt_switches`, `nonvoluntary_ctxt_switches`, `VmRSS`, `RssAnon`, `RssFile`, `read_bytes`, `write_bytes`.
- Умеет форматировать числа (МиБ/КиБ) и считает `RSS MiB` и «CPU time sec = (utime+stime)/HZ».

#### Краткая теория
/proc/<pid>/stat — один строковый файл со множеством полей, разделённых пробелами. Важно: поле comm (имя программы) берётся в скобках (...) и может содержать пробелы, поэтому при парсинге нельзя просто split(' ') от начала — нужно найти последнюю круглую скобку ) и брать поля после неё.

Номера полей (упомянуто самые важные):
поле 1 — pid
поле 2 — comm (в скобках)
поле 3 — state (символ)
поле 14 — utime (в тиках, jiffies) — время в пользовательском пространстве
поле 15 — stime (в тиках) — время, проведённое в ядре для этого процесса

Как считать CPU time sec:
CPU time sec = (utime + stime) / HZ, где HZ — число тиков в секунду (так называемый CLK_TCK). Программа должна получить HZ портируемо через sysconf(_SC_CLK_TCK). Это корректно для всех современных Linux-платформ.

/proc/<pid>/status — VmRSS и context switches
/proc/<pid>/status — читаемый человекочитаемый файл: строки Key: value. Полезные поля:
VmRSS: — Resident Set Size (RSS) в килобайтах (kB в выводе — это фактически KiB).
Threads: — число потоков в процессе.
PPid: — родительский PID.
State: — состояние (буква + текст).
voluntary_ctxt_switches — число добровольных переключений контекста (процесс уступил CPU, ждя чего-то).
nonvoluntary_ctxt_switches — число вынужденных переключений (принудительно вытеснен планировщиком).

Фоновый процесс:
```
yes > /dev/null &
[1] 5315
```

Вывод pstat:
```
pstat snapshot for pid: 5315
----------------------------------------
PPid: 3867
Threads: 1
State: R (running)

utime (jiffies): 151810
stime (jiffies): 434852
CLK_TCK (HZ): 100
CPU time sec = (utime+stime)/HZ = (586662)/100 = 5866.620000 s

voluntary_ctxt_switches: 2
nonvoluntary_ctxt_switches: 78778

VmRSS (raw): 1944 kB
RSS = 1.90 MiB
RssAnon: N/A (no smaps_rollup or field missing)
RssFile: N/A (no smaps_rollup or field missing)

read_bytes (from /proc/5315/io): 36864 (36.00 KiB)
write_bytes (from /proc/5315/io): 0 (0 B)
----------------------------------------
```

Вывод ps:
```
PID    PPID S ELAPSED     TIME   RSS COMMAND
5315    3867 R    5867 01:37:46  1944 yes
```

Вывод top:
```
top - 00:58:50 up  1:48,  1 user,  load average: 1,18, 1,27, 1,32
Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s):  3,3 us,  5,7 sy,  0,0 ni, 91,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st 
MiB Mem :  13827,2 total,   6436,8 free,   4550,3 used,   2763,7 buff/cache     
MiB Swap:   4096,0 total,   4096,0 free,      0,0 used.   9276,9 avail Mem 

PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
5315 vanya     20   0    8312   1944   1944 R 100,0   0,0  97:46.84 yes
```

Вывод pidstat_io:
```
Linux 6.14.0-32-generic (vanya-Legion-5-15ACH6) 	02.10.2025 	_x86_64_	(12 CPU)

00:58:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
00:58:52     1000      5315      0,00      0,00      0,00       0  yes
Average:     1000      5315      0,00      0,00      0,00       0  yes
```

pidstat_u:
```
Linux 6.14.0-32-generic (vanya-Legion-5-15ACH6) 	02.10.2025 	_x86_64_	(12 CPU)

00:58:50      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
00:58:51     1000      5315   25,00   74,00    0,00    0,00   99,00    10  yes
Average:     1000      5315   25,00   74,00    0,00    0,00   99,00     -  yes
```

Утилиты показали одинаковое состояние процесса yes - Running.
RSS/RES/VmRSS совпадает у pstat, ps, top (1944). 
К файлу /proc/<pid>/smaps_rollup доступ не получили во время снимка, поэтому N/A.

## Вопросы
1. Где в `/proc/<pid>/stat` и `/proc/<pid>/status` отражаются время в ядре/в юзере и состояние процесса?
Время в пользователе и в ядре хранится в /proc/<pid>/stat в полях:
utime — поле 14 (время в пользовательском пространстве, в jiffies);
stime — поле 15 (время в ядре, в jiffies).
В stat состояние — поле 3 (символ R/S/D/...).
2. Как получить `RSS` и чем отличаются `RssAnon` и `RssFile`? Почему они важны?
RSS (Resident Set Size) — объём физической памяти (физические страницы), занимаемых процессом.
Поле VmRSS: в /proc/<pid>/status (в kB).
Альтернативно: /proc/<pid>/statm (поле resident).
RssAnon и RssFile дают разбиение RSS по типам страниц (обычно из /proc/<pid>/smaps или /proc/<pid>/smaps_rollup):
RssAnon — часть RSS, занимаемая анонимной памятью (heap, стек, mmap без backing file): эти страницы — «настоящая» оперативная память процесса; их нельзя восстановить с диска.
RssFile — часть RSS, занимаемая file-backed страницами (код программы, mmap файлов, файловый кеш): такие страницы потенциально могут быть выгружены и восстановлены с диска.
Важно, потому что VmRSS показывает общий физический footprint процесса.
Разделение на RssAnon/RssFile помогает понять, насколько память «жёстко используется» (анонимная) и насколько можно снизить давление на RAM выгрузкой file-backed страниц. Это важно при отладке OOM, оценке влияния на кэш файловой системы и при оптимизации потребления памяти.
3. Как оценить IO‑активность по `/proc/<pid>/io` и чем она отличается от «ожидания IO» в `top/pidstat`?
В /proc/<pid>/io есть несколько полей; ключевые: rchar — байты, возвращённые процессу при чтениях (включает выдачу из page cache); wchar — байты, записанные через write (с точки зрения syscalls); read_bytes — байты, физически считанные с блочного устройства (disk read) — то есть реальные чтения с диска; write_bytes — байты, физически записанные на диск.
Как оценивать:
Для накопленных величин — читать /proc/<pid>/io дважды и смотреть приращение read_bytes/write_bytes за интервал; деля на время интервала, получим kB/s.
Отличие от «ожидания IO» в top/pidstat:
/proc/.../io — это счётчики объёма I/O (количество байт, операции).
top/pidstat показывают время ожидания I/O (например, iowait в %CPU у top или задержки/время ожидания у pidstat) — это временные метрики: сколько времени процесс тратит в состоянии ожидания на I/O (блокировки), а не сколько байт он прочитал/записал.
Следствие: процесс может иметь много read_bytes (интенсивный I/O), но небольшое время ожидания (если IO неблокирующий или данные из кэша). И наоборот — если много синхронных блокирующих операций, время ожидания будет высоко даже при небольших байтах.
4. Что означает делитель `HZ` и как корректно посчитать `CPU time sec = (utime+stime)/HZ`?
HZ (или CLK_TCK) — число тиков (jiffies) в секунду, единица, в которой utime/stime в /proc/<pid>/stat измеряются. На разных системах значение может быть разным (часто 100 или 1000, но не гарантировано). У меня 100 (я проверил с помощью getconf CLK_TCK).
Программно получать значение HZ, привести оба значения TIME и HZ к секундам.
5. Почему возможны рассинхронизации между `/proc` и выводом `ps/top`? Когда это критично?
Время снимка: pstat (или cat /proc/...) и ps/top/pidstat читают данные в разное время; даже миллисекунды задержки дают отличия в динамичных метриках (CPU, IO).
Разные методы и интервалы вычисления: top и pidstat часто показывают производные (процент CPU за интервал), ps показывает накопленное поле TIME в формате hh:mm:ss. Интервалы усреднения различаются.
Разные источники/агрегации: ps/top используют те же /proc файлы, но могут дополнительно агрегировать по потокам или форматировать вывод по-своему.
Права доступа и консистентность: чтение нескольких /proc/<pid>/* файлов не атомарно — один файл мог обновиться между чтениями.
Кэширующие эффекты и page reclaim: RSS/IO могут меняться между вызовами.
Это критично при анализе очень короткоживущих процессов — один инструмент может «упустить» процесс.
При попытке корреляции событий (например, приращение read_bytes и одновременное изменение RSS) — требуется синхронный снимок; асинхронность может ввести ложные выводы.
Для точного профилирования/бенчмарков, где требуются микросекундные точности — использовать стоит инструменты с контролируемыми интервалами (perf, strace -tt, pidstat с фиксированным интервалом) и снимать /proc в одном атомарном шаге.

