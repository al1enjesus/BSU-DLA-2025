 # Лабораторная работа №3 - работа с информацией о процессах в системе. Создание утилиты pstat.

 ## Цели
- Уверенно извлекать и интерпретировать метрики процесса из /proc.
- Сопоставлять показатели /proc с утилитами ps, top, pidstat.
- Освоить базовую диагностику приложений: системные вызовы и аппаратные счётчики.
- Создание утилиты для сбора информации о процессах - pstat

## Реализация pstat
Инструкция по развертыванию и использованию утилиты - README.MD

Получив \<pid\> в качестве аргумента, утилита собирает данные о процессе с соответствующим PID по следующим файлам:

#### /proc/\<pid>/stat
Содержит в себе множество характеристик в виде массива.
Из него утилита забирает:
- ppid  (поле 4) - pid процесса
- state (поле 3) - состояние процесса
- utime (поле 14, индекс 13) - процессорное время процесса в тиках
- stime (поле 15, индекс 14) - процессорное время в kernel-режиме

#### /proc/\<pid>/status
Содержит в себе информацию о процессе в более понятном человеку формате.
Из нее утилита забирает 
- Threads - кол-во задействованных потоков
- VmRSS - 
- voluntary_ctxt_switches - "добровольные" изменения контекста
- nonvoluntary_ctxt_switches - принудительные изменения контекста

#### /proc/\<pid>/io
Статистика ввода/вывода
- read_bytes - байт прочитано
- write_bytes - байт записано

#### /proc/\<pid>/smaps_rollup
Статисктика процесса по памяти
- RssAnon - анонимная память
- RssFile - отображённые файлы
- RssShmem - разделяемая память

Если файлов по pid нет, утилита интерпретирует это как то, что процесса не существует и уведомит об этом пользователя. Опциональным остается файл smaps_rollup.

Если доступ к файлам процесса запрещен, утилита об этом уведомит и предложит сменить пользователя или использовать sudo.

## Эксперименты
#### Базовый вывод pstat:
```
pstat $$

PID: 41308
PPid: 39645
State: S
Threads: 1
utime: 15 ticks
stime: 18 ticks
CPU time: 0.33 sec
voluntary_ctxt_switches: 1974
nonvoluntary_ctxt_switches: 25
VmRSS: 5260 kB
read_bytes: 28094464
write_bytes: 10997760
```

#### Вывод ps:
```
ps -p $$ -o pid,ppid,stat,thcount,time,rss

    PID    PPID STAT THCNT     TIME   RSS
  41308   39645 Ss       1 00:00:00  5260

```


#### Вывод top:
```
top -p $$

top - 22:52:48 up 15 days,  5:05,  7 users,  load average: 29.92, 30.14, 29.99
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s): 12.3 us,  0.4 sy,  0.8 ni, 86.3 id,  0.1 wa,  0.0 hi,  0.2 si,  0.0 st 
MiB Mem :  15599.1 total,   8770.1 free,   5231.1 used,   3473.7 buff/cache     
MiB Swap:  17159.0 total,  14543.3 free,   2615.7 used.  10367.9 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                                               
  41308 kapusha   20   0   10944   5260   3304 S   0.0   0.0   0:00.33 bash
  ```

  #### Вывод pidstat:
  ```
  pidstat -p $$

  10:57:17 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
10:57:17 PM  1000     41308    0.00    0.00    0.00    0.00    0.00     8  bash
```


### Анализ вывода
- VmRSS выводится в Kb - 5260 - и совпадает со значением в остальных утилитах.
- Процессорное время рассчитано верно. Можно увидеть, что и в pstat и top TIME = 0:00.33. Более того, тики также верны, (15 + 18) / 100 = 0.33 (скорее всего Hz = 100)
- Все статистики совпали.


## Ответы на вопросы
Вопросы и ответы
**Где в /proc/<pid>/stat и /proc/<pid>/status отражаются время в ядре/в юзере и состояние процесса?**

Время выполнения процесса отражается в файле /proc/<pid>/stat в полях utime и stime, где первое значение соответствует времени, проведённому в пространстве пользователя, а второе — в режиме ядра. Эти значения измеряются в тиках системного таймера (jiffies). Состояние процесса задаётся отдельным полем state в этом же файле и отображается одной буквой: например, R для работающего процесса или S для ожидающего. В файле /proc/<pid>/status эти данные представлены в более удобочитаемом виде: параметр State указывает состояние словами, а суммарное время не отражается напрямую, хотя косвенно его можно оценить через информацию о потоках.

**Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?**

Значение Resident Set Size (RSS) можно найти в /proc/<pid>/status как VmRSS, а также в агрегированном файле /proc/<pid>/smaps_rollup, где данные разбиваются на RssAnon, RssFile и RssShmem. RSS показывает фактический объём памяти, который процесс удерживает в оперативной памяти. Разница между RssAnon и RssFile заключается в том, что первая метрика отражает анонимные страницы, которые не отображаются на файлы и существуют только в памяти, а вторая — страницы, связанные с отображением файлов (например, библиотек). Эта разница важна, так как от неё зависит, насколько процесс нагружает систему по памяти и какова вероятность вытеснения его данных в swap: анонимные страницы должны быть сохранены в swap, а файловые можно восстановить из исходных файлов.

**Как оценить IO-активность по /proc/<pid>/io и чем она отличается от «ожидания IO» в top/pidstat?**

Файл /proc/<pid>/io содержит счётчики, показывающие фактический объём данных, который процесс прочитал или записал, например read_bytes и write_bytes. Эти значения позволяют судить о том, сколько операций ввода-вывода реально было выполнено. В отличие от этого, такие утилиты как top или pidstat могут показывать время ожидания ввода-вывода, которое отражает, сколько времени процесс был заблокирован в ожидании завершения операции. Разница заключается в том, что счётчики в /proc/<pid>/io отражают факт работы с данными, а метрики в top и pidstat показывают задержку выполнения из-за IO.

**Что означает делитель HZ и как корректно посчитать CPU time sec = (utime+stime)/HZ?**

Значение HZ определяет частоту системных тиков и указывает, сколько раз в секунду ядро обновляет счётчики времени. В Linux этот параметр можно получить через os.sysconf("SC_CLK_TCK"). Для перевода пользовательского и системного времени процесса из тиков в секунды необходимо сложить utime и stime, а затем разделить на HZ. Например, если процесс имеет 50 тиков суммарного времени, а значение HZ равно 100, то его общее процессорное время составит 0.5 секунды. Это корректный способ привести низкоуровневые данные ядра к привычным величинам времени.

**Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?**

Рассинхронизация возникает потому, что файлы в /proc отражают состояние процесса в момент их чтения, а утилиты ps и top делают собственные выборки, часто с задержкой в секунду или больше. Из-за этого значения CPU времени, количества потоков или RSS могут отличаться между разными источниками, особенно если процесс активно работает или потребляет ресурсы. Такая неточность обычно некритична для диагностики, но может быть проблемой в высоконагруженных системах, где требуется точный мониторинг и анализ производительности в реальном времени.


