Лабораторная работа 3 - Отчёт
Студент: Сазончик Иван

Цель работы
Разработать утилиту pstat для извлечения и анализа метрик процессов из виртуальной файловой системы /proc, сравнить полученные данные с системными утилитами ps, top, pidstat.

Теоретическая часть
Виртуальная файловая система /proc
/proc - специальная файловая система в Linux, предоставляющая интерфейс для доступа к данным ядра и информации о процессах в реальном времени. Файлы в /proc существуют только в оперативной памяти.

Ключевые файлы для мониторинга процессов:
/proc/<pid>/stat - основная статистика процесса

/proc/<pid>/status - та же информация в читаемом формате

/proc/<pid>/io - статистика ввода-вывода

/proc/<pid>/smaps_rollup - детальная информация о памяти

Выполнение работы
1. Разработка утилиты pstat
Создана утилита на Python, которая читает и анализирует данные из /proc.
2. Запуск и тестирование
Запуск утилиты:

bash
cd САЗОНЧИК_ИВАН
chmod +x run.sh
./run.sh
Тестирование процесса systemd (PID: 1)
Команда:

bash
./run.sh 1

Вывод pstat:
Process 1 information:
==================================================
PPid:                          0
Threads:                       1
State:                         S (Sleeping)
utime/stime:                   1957/396 ticks
CPU time sec:                  23.53 s
voluntary_ctxt_switches:       32583
nonvoluntary_ctxt_switches:    229
VmRSS:                         12288 KB
RSS MiB:                       12.00 MiB
RssAnon:                       0 KiB
RssFile:                       0 KiB

Сравнение с ps:
    PID    PPID S  UTIME STIME   RSS NLWP COMMAND
      1       0 S      - 13:58 12288    1 systemd

Сравнение с top:
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
      1 root      20   0  167096  12288   8192 S   0.0   0.2   0:23.53 systemd

Сравнительный анализ результатов pstat, ps и top
1. Основные метрики - полное совпадение
PPid (Parent Process ID):

pstat: 0

ps: 0

top: не отображается
 Совпадение - все утилиты показывают, что process 1 не имеет родителя

Threads (количество потоков):

pstat: 1

ps: NLWP=1

top: не отображается напрямую
 Совпадение - systemd использует один поток выполнения

State (состояние процесса):

pstat: S (Sleeping)

ps: S

top: S
 Полное совпадение - все утилиты показывают состояние "Sleeping"

2. Память - идентичные значения
VmRSS/RSS (используемая память):

pstat: 12288 KB / 12.00 MiB

ps: RSS=12288

top: RES=12288
 Точное совпадение - все утилиты показывают идентичное потребление памяти

Форматирование pstat:

Автоматическое преобразование 12288 KB → 12.00 MiB ✓

Корректное округление до двух знаков после запятой ✓

3. Время CPU - корректные вычисления
Исходные данные:

pstat: utime=1957, stime=396 тиков

Вычисление CPU time:

pstat: (1957 + 396) / 100 = 23.53 s

top: TIME+=0:23.53
Точное совпадение - вычисления pstat полностью соответствуют top

Формат отображения:

pstat: 23.53 s (секунды)

top: 0:23.53 (минуты:секунды)

ps: 13:58 (более агрегированный формат)

4. Контекстные переключения - уникальные данные pstat
Только в pstat:

voluntary_ctxt_switches: 32583

nonvoluntary_ctxt_switches: 229
 Уникальная информация - эти метрики недоступны в ps/top

5. Детальная информация о памяти - ограничения WSL2
RssAnon/RssFile в pstat:

RssAnon: 0 KiB

RssFile: 0 KiB
 Ограничение окружения - вероятно, smaps_rollup недоступен в WSL2

Выводы
 Сильные стороны pstat:
Полнота данных - предоставляет метрики, недоступные в ps/top (контекстные переключения)

Точность вычислений - CPU time полностью совпадает с системными утилитами

Удобное форматирование - автоматическое преобразование единиц измерения

Единый интерфейс - все данные в одном выводе

 Корректность реализации:
Чтение /proc - все основные метрики извлекаются корректно

Вычисления - CPU time sec = (utime+stime)/HZ работает точно

Форматирование - RSS MiB и другие преобразования правильные

Совместимость - данные полностью согласуются с системными утилитами

 Ограничения:
WSL2 - некоторые файлы /proc недоступны (smaps_rollup)

Системные процессы - ограниченный доступ к IO статистике

Итог: утилита pstat успешно выполняет поставленные задачи:
 Корректно читает данные из /proc

 Точно вычисляет производные метрики

 Правильно форматирует числа

 Полностью согласуется с системными утилитами

 Предоставляет дополнительную информацию недоступную в ps/top

Тестирование процесса run.sh (PID: 26094)

Вывод pstat:
Process 26094 information:
==================================================
PPid:                          400
Threads:                       1
State:                         S (Sleeping)
utime/stime:                   0/1 ticks
CPU time sec:                  0.01 s
voluntary_ctxt_switches:       456
nonvoluntary_ctxt_switches:    0
VmRSS:                         3840 KB
RSS MiB:                       3.75 MiB
RssAnon:                       624 KiB
RssFile:                       0 KiB
read_bytes:                    0.00 B
write_bytes:                   0.00 B

Сравнение с ps:
    PID    PPID S  UTIME STIME   RSS NLWP COMMAND
  26094     400 S      - 14:43  3840    1 run.sh

Сравнение с top:
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  26094 simba     20   0    5048   3840   3328 S   0.0   0.0   0:00.01 run.sh

3. Анализ результатов форматирования
Для процесса systemd (PID: 1):

RSS MiB: 12288 KB → 12.00 MiB 

CPU time sec: (1957 + 396) / 100 = 23.53s 

Состояние: S (Sleeping) 

Для процесса run.sh (PID: 26094):

RSS MiB: 3840 KB → 3.75 MiB 

CPU time sec: (0 + 1) / 100 = 0.01s 

Байты: 0.00 B (автоматическое форматирование) 

Ответы на вопросы
1. Где в /proc/<pid>/stat и /proc/<pid>/status отражаются время в ядре/в юзере и состояние процесса?
В /proc/<pid>/stat:

Поле 3: состояние процесса (S - Sleeping в наших примерах)

Поле 14: utime - время в пользовательском режиме (1957 тиков для PID 1)

Поле 15: stime - время в системном режиме (396 тиков для PID 1)

В наших результатах:

PID 1: utime/stime: 1957/396 ticks → состояние S (Sleeping)

PID 26094: utime/stime: 0/1 ticks → состояние S (Sleeping)

Код из утилиты:

python
# В parse_proc_stat
data.update({
    'state': fields[2],      # поле 3 - состояние
    'utime': int(fields[13]), # поле 14 - utime  
    'stime': int(fields[14]), # поле 15 - stime
})
2. Как получить RSS и чем отличаются RssAnon и RssFile? Почему они важны?
RSS (Resident Set Size) - физическая память процесса в ОЗУ:

PID 1: VmRSS: 12288 KB, RSS MiB: 12.00 MiB

PID 26094: VmRSS: 3840 KB, RSS MiB: 3.75 MiB

RssAnon и RssFile в наших результатах:

PID 1: RssAnon: 0 KiB, RssFile: 0 KiB - возможно ограничения WSL2

PID 26094: RssAnon: 624 KiB, RssFile: 0 KiB

Важность различия:

RssAnon - анонимная память (стеки, куча), нельзя выгрузить кроме свопа

RssFile - память из файлов (библиотеки), может быть выгружена и загружена обратно

В примере PID 26094 использует преимущественно анонимную память (624 KiB)

3. Как оценить IO‑активность по /proc/<pid>/io и чем она отличается от «ожидания IO» в top/pidstat?
По /proc/<pid>/io в наших результатах:

PID 26094: read_bytes: 0.00 B, write_bytes: 0.00 B

Показывает кумулятивные счётчики за всё время работы

В top в наших результатах:

Показывает текущее состояние: S (Sleeping) и %CPU: 0.0

"Ожидание IO" не отображается явно, но состояние S может указывать на ожидание

Различие: /proc/io даёт общий объём данных, а top показывает текущую активность и состояние блокировки.

4. Что означает делитель HZ и как корректно посчитать CPU time sec?
HZ - частота тиков ядра (100 в нашей системе).

Корректный расчёт в наших результатах:

python
HZ = 100
# PID 1: (1957 + 396) / 100 = 23.53s 
# PID 26094: (0 + 1) / 100 = 0.01s 
Сравнение с top:

PID 1: TIME+: 0:23.53 - полное совпадение

PID 26094: TIME+: 0:00.01 - полное совпадение

5. Почему возможны рассинхронизации между /proc и выводом ps/top? Когда это критично?
В наших результатах расхождений не обнаружено:

RSS память: pstat и ps/top показывают идентичные значения (12288 KB / 3840 KB)

Состояние процессов: все утилиты показывают S (Sleeping)

Время CPU: вычисления pstat совпадают с TIME+ в top

Возможные причины рассинхронизации в других случаях:

Время измерения - pstat мгновенный снимок, top усредняет

Обработка данных - разные алгоритмы округления

Кэширование - системные утилиты могут кэшировать данные

Ограничения окружения WSL2
Обнаруженные ограничения в результатах:
Отсутствие данных smaps_rollup:

PID 1: RssAnon: 0 KiB, RssFile: 0 KiB - явно некорректные данные

PID 26094: RssFile: 0 KiB - вероятно ограничение WSL2

Ограниченные данные IO:

Только для пользовательских процессов (PID 26094)

Системные процессы (PID 1) - данные IO недоступны

Альтернативы в WSL2:
Для детального анализа памяти - использовать /proc/<pid>/smaps вместо smaps_rollup

Для IO статистики - полагаться на pidstat когда доступен

Основные метрики - PPid, Threads, State, VmRSS работают корректно

Выводы
Утилита pstat успешно разработана - корректно извлекает и форматирует все основные метрики

Полное совпадение с системными утилитами - RSS память, состояние процессов и время CPU идентичны

Форматирование работает корректно:

Автоматическое преобразование KB → MiB

Точное вычисление CPU time с HZ=100

Читаемое отображение размеров памяти

WSL2 ограничения подтверждены:

smaps_rollup предоставляет неполные данные

IO статистика недоступна для системных процессов

Основной функционал работает - ключевые метрики процессов доступны и точны

Использование AI:
Исскуственный интелект использовался для разъяснения работы команд
А также точечно в целях ускорения написания программного кода

Воспроизводимость
Для воспроизведения результатов:

Клонировать репозиторий

Перейти в САЗОНЧИК_ИВАН/

Выполнить: chmod +x run.sh && ./run.sh

Для тестирования конкретного процесса: ./run.sh <pid>

Окружение тестирования:

WSL2 с Ubuntu

Python 3.10+

Ядро Linux 5.15.0-91-generic