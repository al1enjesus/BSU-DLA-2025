# Лабораторная 4 — Системные вызовы

## Выбор программ
Номер в списке группы: 24  
Расчёт группы программ: 24 % 4 = 0  
Программы для анализа: ls, cat, grep  
Мои задания: A (LD_PRELOAD), B (Benchmark)

## Среда выполнения
- ОС: WSL2 (Ubuntu 24.04)
- Ядро: 6.6.87.2-microsoft-standard-WSL2
- Процессор: Intel(R) Core(TM) i3-10110U CPU @ 2.10GHz
- Компилятор: gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки
Реализована библиотека `libsyscall_spy.so`, перехватывающая функции: `open`, `openat`, `opendir`, `read`, `readdir`, `write`, `close`, `closedir` (а также безопасный вывод логов через оригинальный `write` чтобы избежать рекурсии).

Библиотека компилируется командой:

```console
make libsyscall_spy.so
```

### Эксперимент 1: ls
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so ls -la /etc/apt >> logs/ls.out 2>&1 || true
```

**Полный вывод (первые 30-50 строк):**
```
Running: LD_PRELOAD=./libsyscall_spy.so ls -la /etc/apt
[SPY] opendir("/etc/apt") = 0x5a1fb2cf5b90
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: sources.list.d
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: ..
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: trusted.gpg
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: sources.list
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: keyrings
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: trusted.gpg.d
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: apt.conf.d
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: auth.conf.d
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: preferences.d
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: .
[SPY] readdir(0x5a1fb2cf5b90) -> d_name: NULL
[SPY] closedir(0x5a1fb2cf5b90) = 0
total 40
drwxr-xr-x  8 root root 4096 Oct 16 23:06 .
drwxr-xr-x 97 root root 4096 Oct 17 05:52 ..
drwxr-xr-x  2 root root 4096 Aug  5 19:57 apt.conf.d
drwxr-xr-x  2 root root 4096 Mar 31  2024 auth.conf.d
drwxr-xr-x  2 root root 4096 Mar 31  2024 keyrings
drwxr-xr-x  2 root root 4096 Aug  5 19:57 preferences.d
-rw-r--r--  1 root root  270 Oct 16 23:06 sources.list
drwxr-xr-x  2 root root 4096 Oct 16 23:06 sources.list.d
-rw-r--r--  1 root root  640 Oct 16 23:06 trusted.gpg
drwxr-xr-x  2 root root 4096 Oct 16 23:06 trusted.gpg.d
```

**Анализ:**
- Сколько всего вызовов: 13
- Какие файлы открывались: `/etc/apt`
- Неожиданности: программа `ls` вызывает системные функции `opendir` и `readdir` вместо обычных `open` и `read`

### Эксперимент 2: cat
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so cat /etc/hosts >> logs/cat.out 2>&1 || true
```

**Полный вывод (первые 30-50 строк):**
```
Running: LD_PRELOAD=./libsyscall_spy.so cat /etc/hosts
[SPY] open("/etc/hosts", flags=0x0) = 3
[SPY] read(fd=3, buf=0x7a319f4a0000, count=131072) = 409
# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateHosts = false
127.0.0.1	localhost
127.0.1.1	Lenovo.localdomain	Lenovo

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
[SPY] write(fd=1, buf=0x7a319f4a0000, count=409) = 409
[SPY] read(fd=3, buf=0x7a319f4a0000, count=131072) = 0
[SPY] close(fd=3) = 0
```

**Анализ:**
- Сколько всего вызовов: 5
- Какие файлы открывались: `/etc/hosts`
- Поведение типично: один `open`, несколько `read` (пока не EOF), один `write` на `stdout`

### Эксперимент 3: grep
**Команда:**
```bash
{ LD_PRELOAD=./libsyscall_spy.so grep -R '^#' /etc/apt 2>&1 || true; } | head -n 1000 >> logs/grep.out 2>&1
```

**Полный вывод (первые 30-50 строк):**
```
Running: LD_PRELOAD=./libsyscall_spy.so grep -R '^#' /etc/apt | head -n 1000
[SPY] open("/proc/self/maps", flags=0x0) = 3
[SPY] read(fd=3, buf=0x789e99cd4000, count=8192) = 3942
[SPY] read(fd=3, buf=0x789e99cd4f66, count=4250) = 1054
[SPY] read(fd=3, buf=0x789e99cd2000, count=16384) = 3942
[SPY] read(fd=3, buf=0x789e99cd2f66, count=12442) = 1054
[SPY] read(fd=3, buf=0x789e99cd3384, count=11388) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt", flags=0x100) = 3
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt", flags=0x90900) = 3
[SPY] readdir(0x5beb094b84c0) -> d_name: sources.list.d
[SPY] readdir(0x5beb094b84c0) -> d_name: ..
[SPY] readdir(0x5beb094b84c0) -> d_name: trusted.gpg
[SPY] readdir(0x5beb094b84c0) -> d_name: sources.list
[SPY] readdir(0x5beb094b84c0) -> d_name: keyrings
[SPY] readdir(0x5beb094b84c0) -> d_name: trusted.gpg.d
[SPY] readdir(0x5beb094b84c0) -> d_name: apt.conf.d
[SPY] readdir(0x5beb094b84c0) -> d_name: auth.conf.d
[SPY] readdir(0x5beb094b84c0) -> d_name: preferences.d
[SPY] readdir(0x5beb094b84c0) -> d_name: .
[SPY] readdir(0x5beb094b84c0) -> d_name: NULL
[SPY] closedir(0x5beb094b84c0) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/sources.list.d", flags=0x90900) = 3
[SPY] readdir(0x5beb094b84c0) -> d_name: ..
[SPY] readdir(0x5beb094b84c0) -> d_name: ubuntu.sources
[SPY] readdir(0x5beb094b84c0) -> d_name: archive_uri-https_packages_microsoft_com_ubuntu_24_04_prod-noble.list
[SPY] readdir(0x5beb094b84c0) -> d_name: .
[SPY] readdir(0x5beb094b84c0) -> d_name: NULL
[SPY] closedir(0x5beb094b84c0) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/sources.list.d/ubuntu.sources", flags=0x100) = 3
[SPY] read(fd=3, buf=0x5beb0949f000, count=98304) = 2552
[SPY] read(fd=3, buf=0x5beb0949f9f8, count=98304) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/sources.list.d/archive_uri-https_packages_microsoft_com_ubuntu_24_04_prod-noble.list", flags=0x100) = 3
[SPY] read(fd=3, buf=0x5beb0949f000, count=98304) = 134
[SPY] read(fd=3, buf=0x5beb0949f086, count=98304) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/trusted.gpg", flags=0x100) = 3
[SPY] read(fd=3, buf=0x5beb0949f000, count=98304) = 640
[SPY] read(fd=3, buf=0x5beb0949f280, count=98304) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/sources.list", flags=0x100) = 3
[SPY] read(fd=3, buf=0x5beb0949f000, count=98304) = 270
[SPY] read(fd=3, buf=0x5beb0949f10e, count=98304) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/apt/keyrings", flags=0x90900) = 3
[SPY] readdir(0x5beb094c1070) -> d_name: ..
[SPY] readdir(0x5beb094c1070) -> d_name: .
[SPY] readdir(0x5beb094c1070) -> d_name: NULL
```

**Анализ:**
- Сколько всего вызовов: 139
- Какие файлы открывались: `/proc/self/maps`, файлы в `/etc/apt` и её поддиректориях
- Неожиданности:
    * `open("/proc/self/maps")` и чтение этой псевдо-файловой информации (часто используется библиотеками для определения картировок адресного пространства, SSE/ASLR-информации и т.д.).

    * `openat(AT_FDCWD, "/etc", ...)`, множественные `readdir` строки — `grep` рекурсивно обходит `/etc` и читает каталоги.

    * `grep` вызывает много `openat`/`readdir`/`read` на каталогах и файлах — это объясняет большое количество файловых вызовов.

### Сравнительная таблица
| Программа | Вызовов open/openat | Вызовов read | Вызовов write | Вызовов close |
|-----------|---------------------|--------------|---------------|---------------|
| ls        | 1                   | 11           | 0             | 1             |
| cat       | 1                   | 2            | 1             | 1             |
| grep      | 27                  | 84           | 0             | 27            |

**Выводы:**
- Больше всего системных вызовов делает программа `grep`.
- Почему?

    > Потому что `grep` был запущен с флагом `-R` (рекурсивный поиск). Из-за этого `grep` обходит все поддиректории и файлы по указанному пути, совершая множество вызовов `openat`, `readdir`, `read` и `close` для каждого элемента. Это чисто файловая операция, но в большом масштабе.

- Какие неочевидные файлы открываются?

    > `grep` открывает `/proc/self/maps`. Это не обычный файл, а псевдофайл из системы `/proc/`, который содержит информацию о распределении памяти текущего процесса. Вероятно, это делает не сам `grep`, а одна из стандартных библиотек, которую он использует.

### Проверка на статически слинкованной программе
**Команда:**
```bash
# Создаём статическую программу
make hello_static
LD_PRELOAD=./libsyscall_spy.so ./hello_static >> logs/hello_static.out 2>&1 || true
```

**Результат:**
```
Running static hello (should NOT be intercepted)
hello static
```

**Объяснение:** `LD_PRELOAD` действует на динамически линкованные программы: динамический загрузчик (`ld-linux.so`) разрешает символы, и предварительно загруженные библиотеки могут переопределить символы. В статически слинкованных бинарниках все нужные функции встроены внутрь исполняемого файла на этапе линковки; динамический загрузчик не резолвит внешние `.so` при старте, поэтому `LD_PRELOAD` не может подменить символы — перехват не сработает.

---

## Задание B: Benchmark системных вызовов

### Исходный код
Бенчмарк `benchmark` использует `rdtscp` (`__rdtscp`) и подсчитывает суммарные такты за 1e6 итераций для каждой операции: `dummy()` (userspace), `getpid()` (быстрый syscall), `gettimeofday()` (vDSO), `open+close` (/tmp file).

Из `perf_stat.out` (полный `perf stat` для `./benchmark`) получены суммарные показатели:
```bash
cycles = 6_613_883_888
time elapsed = 1.821417660 seconds
```

Отсюда оценённая частота TSC (cycles / elapsed) = **~3,631,173,695 Hz (≈3.6312 GHz)**. Следовательно 1 такт ≈ **0.2754 ns** (1e9 / 3.498352822e9 ≈ 0.2754 ns/cycle). Я использую эту оценку, чтобы переводить циклы → наносекунды.

### Таблица результатов (1 миллион итераций)

| Операция                  | Среднее время (ns) | Циклов CPU | Во ск. раз медленнее userspace |
|---------------------------|--------------------|------------|--------------------------------|
| dummy() userspace         | 8.61               | 31269046   | 1x (baseline)                  |
| getpid()                  | 90.63              | 329088888  | 10x                            |
| open("/tmp/test")+close() | 1241.71            | 4508738151 | 144x                           |
| gettimeofday() vDSO       | 19.07              | 69254710   | 2x                             |

**Команды для воспроизведения:**
```bash
make benchmark
./benchmark 2>> logs/benchmark.out >> logs/benchmark.out || true
```

**Вывод программы (полностью):**
```
Running benchmark...
dummy: total_cycles=31269046 avg_cycles=31.27
getpid: total_cycles=329088888 avg_cycles=329.09
gettimeofday: total_cycles=69254710 avg_cycles=69.25
open+close: total_cycles=4508738151 avg_cycles=4508.74
Iterations: 1000000
```

### Дополнительный замер: влияние кэша страниц
**Эксперимент:** сравнить `open()` на файле в кэше vs без кэша

```bash
# Сброс кэша (требует root)
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null

# Первый запуск (холодный кэш)
./open_bench > logs/open_bench_cold.out 2>&1 || true

# Второй запуск (горячий кэш)
./open_bench > logs/open_bench_warm.out 2>&1 || true
```

**Результаты:**
- Холодный кэш: 2252 ns
- Горячий кэш: 1315 ns
- Разница: 1.7x

### Проверка через perf stat
```bash
perf stat -e cycles,instructions,context-switches,page-faults -o logs/perf_stat.out ./benchmark || true
```

**Вывод:**
```
# started on Fri Oct 17 06:11:39 2025


 Performance counter stats for './benchmark':

        6613883888      cycles                                                                
        9635522089      instructions                     #    1.46  insn per cycle            
                 5      context-switches                                                      
                63      page-faults                                                           

       1.821417660 seconds time elapsed

       0.213959000 seconds user
       1.618827000 seconds sys
```

**Анализ:**
- Сколько context switches на миллион итераций?

    > Всего 5 context switches за весь запуск `benchmark` — это мало, показывает, что большая часть времени тратится в ядре в контексте того же процесса (не вызвано многими переключениями контекста).

- Сколько page faults?

    > 63 page-faults — небольшое количество, возможно связанные с аллокацией/доступом к новым страницам.

- IPC (instructions per cycle) — высокий или низкий?

    > IPC = 1.46 — невысокое значение, ожидаемо для интенсивных syscall/вводо-выводных сценариев (syscalls частично блокируют pipeline, переключение в ядро вызывает много инструкций ядра).

**Выводы:**
- Почему системный вызов в 50-100 раз медленнее userspace функции?

    > Из-за переключения контекста между пространством пользователя и ядром. Это дорогая операция, включающая смену уровня привилегий и сохранение состояния процесса.

- Что такое vDSO и почему `gettimeofday()` быстрее обычного syscall?

    > vDSO — это механизм, который позволяет выполнять некоторые системные вызовы (например, `gettimeofday()`) прямо в пространстве пользователя, избегая дорогостоящего переключения в ядро.

- Какие факторы влияют на время выполнения `open()`? (файловая система, кэш, права)

    > 1. **Кэш файловой системы**: Тест показал, что `open()` работает в 1.7 раза быстрее с "горячим" кэшем.
    > 2. **Работа с диском**: В отличие от `getpid()`, `open()` взаимодействует с файловой системой, что требует поиска файла и проверки прав доступа — это медленные операции.

---


## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?
Системный вызов — это механизм, с помощью которого программа в user mode запрашивает услуги ядра (kernel mode): доступ к файловой системе, сети, создание процессов и т.п. Отличие от обычной функции: syscall требует переключения привилегий (user → kernel), проверки со стороны ядра (права доступа), возможного взаимодействия с аппаратурой и т. п. Обычная функция в userspace выполняется полностью в контексте процесса и не требует перехода в ring 0.

### 2. Почему системный вызов медленнее обычной функции?
Переход в kernel mode требует сохранения регистров, переключения привилегий, выполнения кода ядра и возвращения в userspace — это добавляет сотни — тысячи тактов. Измерения показывают, что простейшая userspace функция `dummy()` потребляет ≈31.27 cycles, тогда как `getpid()` — ≈329.1 cycles; `open+close()` — ≈4509 cycles. Дополнительно, файловые syscalls могут включать поиск по файловой системе, проверки прав, операции с кешами и потенциальный I/O.

### 3. Как работает `LD_PRELOAD` и в каких случаях он НЕ работает?
`LD_PRELOAD` задаёт список библиотек, которые динамический загрузчик (`ld-linux.so`) загружает раньше остальных, что позволяет переопределять символы (функции) в `libc` и других библиотеках. Это работает только для динамически линкованных программ. Он не работает для статически слинкованных бинарников (в которых функции встроены при линковке), а также часто игнорируется при запуске setuid/setgid программ и при использовании `sudo` (механизмы безопасности блокируют подстановку).

### 4. Что такое vDSO и зачем он нужен?
vDSO — это небольшой участок кода, предоставляемый ядром в адресное пространство процесса (виртуальный shared object). Его цель — реализовать некоторые системно-ориентированные функции (например, `gettimeofday`, `clock_gettime`) без необходимости перехода в kernel mode, что значительно ускоряет их выполнение. Поэтому в тесте вызов `gettimeofday` всего в 2 раза медленнее пустой функции.

### 5. Почему `open()` медленнее `getpid()` на несколько порядков?
`getpid()` читает кэшированную информацию (PID) — очень дешёвая операция. `open()` включает разрешение пути, проверку прав, взаимодействие с dentry/inode кэшами и, при холодном кэше, возможный доступ к диску/файловой системе. В наших замерах `open+close()` ≈4509 cycles vs `getpid()` ≈329.1 cycles (примерно ~14× медленнее). При холодном кэше `open()` может быть ещё дороже (в нашем эксперименте холодный средний ≈8178 cycles).

---

## Общие выводы

- Что нового узнали о работе syscalls?

    > Для оптимизации важно избегать большого числа мелких syscalls в горячих циклах — лучше буферизовать операции.

- Какие инструменты показались наиболее полезными?

    > * `LD_PRELOAD` — очень удобный инструмент для наблюдения за системными вызовами без изменения кода программ. Он помогает быстро увидеть, какие файлы/каталоги читаются программой и какие системные вызовы выполняются.
    > * `perf` даёт количественные метрики (cycles, instructions, context switches, page faults) — незаменим для интерпретации и проверки гипотез о том, где тратится время.

- Какие трудности возникли?

    > Возникли трудности с определением, какие именно системные вызовы используют разные программы. Например, не сразу было очевидно, что `ls` для работы с директориями вызывает `opendir` и `readdir`, а не `open`. Также были сложности с установкой и настройкой `perf` в окружении WSL2.

- Как понимание границы userspace↔kernel поможет в дальнейшем изучении Linux?

    > Это понимание — ключ к трем важным областям:
    > 1. **Оптимизация производительности**: Зная, что пересечение границы — дорогая операция, можно писать более быстрый код, минимизируя системные вызовы.
    > 2. **Отладка и анализ**: Позволяет эффективно использовать инструменты вроде `perf` для анализа поведения программ и поиска проблем.
    > 3. **Безопасность**: Дает понимание, как ОС изолирует процессы и защищает ядро от пользовательских приложений, что является основой безопасности в Linux.

---

## Воспроизводимость

### Команды для полного воспроизведения

```bash
# Сборка
cd lab4/gr9sub1/СОКОВ_ВЛАДИСЛАВ
make all

# Задание A и Задание B
chmod +x run.sh
./run.sh
```

### Окружение
#### Список установленных пакетов:

```bash
sudo apt update && sudo apt install -y build-essential gcc gdb strace ltrace linux-tools-common linux-tools-generic
```

#### Особенности среды WSL2:
Для среды WSL2 есть возможность установить версию `perf` из пакета `linux-tools-generic`. После этого сможем запускать `perf`, используя путь установки по умолчанию `/usr/lib/linux-tools/<linux-version>-generic/perf`.  
Шаблон `<linux-version>` означает версию установленного пакета.

Для удобства мы можем заменить `/usr/bin/perf` актуальным `perf` из библиотеки `linux-tools-generic`, чтобы запускать программу по ключевому имени `perf`:

```bash
mv /usr/bin/perf /usr/bin/perf.bk && ln -s /usr/lib/linux-tools/<linux-version>-generic/perf /usr/bin/perf
```