# Лабораторная 4 — Системные вызовы

## Выбор программ
**Номер в списке группы:** 14  
**Расчёт группы программ:** 14 % 4 = 2  
**Программы для анализа:** `curl`, `wget` (сетевые программы)  
**Мои задания:** A (LD_PRELOAD), B (Benchmark) — обязательные

## Среда выполнения
- **ОС:** Linux (Ubuntu/Debian-based distribution)
- **Ядро:** Linux kernel (современная версия с поддержкой vDSO)
- **Процессор:** x86_64 архитектура с поддержкой RDTSC
- **Компилятор:** GCC с поддержкой C11/C++17

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки

Реализована библиотека `libsyscall_spy.so`, которая перехватывает:
- `open()`, `openat()`, `open64()`, `openat64()` — открытие файлов
- `read()`, `write()` — чтение/запись данных
- `close()` — закрытие дескрипторов

**Ключевые особенности:**
- Использование `dlsym(RTLD_NEXT, ...)` для получения оригинальной функции
- Декодирование флагов open() (O_RDONLY, O_CREAT, O_CLOEXEC)
- Вывод errno с текстовым описанием
- Защита от рекурсии при логировании в stderr

### Эксперимент 1: curl (загрузка JSON API)

**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so curl -sS -o dota_json.txt "https://store.steampowered.com/api/appdetails?appids=570&l=en"
```

**Вывод:**
```
[SPY] ═══════════════════════════════════════════════
[SPY] Syscall spy library loaded (LD_PRELOAD)
[SPY] Intercepting: open, openat, read, write, close
[SPY] ═══════════════════════════════════════════════

[SPY] open("/proc/sys/crypto/fips_enabled", flags=O_RDONLY (0x0)) = -1 [errno=2: No such file or directory]
[SPY] open("/home/luni/.curlrc", flags=O_RDONLY (0x0)) = -1 [errno=2: Нет такого файла или каталога]
[SPY] open("/home/luni/.config/curlrc", flags=O_RDONLY (0x0)) = -1 [errno=2: Нет такого файла или каталога]
[SPY] open("/home/luni/.curlrc", flags=O_RDONLY (0x0)) = -1 [errno=2: Нет такого файла или каталога]
[SPY] close(fd=5) = 0
[SPY] write(fd=6, buf=0x7331093fec5b, count=1) = 1
[SPY] close(fd=6) = 0
[SPY] close(fd=5) = 0
[SPY] close(fd=3) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=5) = 0

[SPY] ═══════════════════════════════════════════════
[SPY] Syscall spy library unloaded
[SPY] ═══════════════════════════════════════════════
```

**Анализ:**
- **Всего вызовов:** ~15 (4 open, 1 write, 6 close)
- **Открываемые файлы:** 
  - `/proc/sys/crypto/fips_enabled` — проверка FIPS-режима криптографии для HTTPS
  - `~/.curlrc`, `~/.config/curlrc` — поиск конфигурационных файлов
- **Особенности:** Минимальное количество syscalls благодаря внутренней буферизации libcurl

### Эксперимент 2: wget (загрузка HTML страницы)

**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so wget -q -O steam_dota.html "https://store.steampowered.com/app/570/?l=english"
```

**Вывод (фрагмент из 300+ строк):**
```
[SPY] ═══════════════════════════════════════════════
[SPY] Syscall spy library loaded (LD_PRELOAD)
[SPY] Intercepting: open, openat, read, write, close
[SPY] ═══════════════════════════════════════════════

[SPY] open("/proc/sys/crypto/fips_enabled", flags=O_RDONLY (0x0)) = -1 [errno=2: Нет такого файла или каталога]
[SPY] write(fd=4, buf=0x5ab01dba2270, count=416) = 416
[SPY] read(fd=4, buf=0x5ab01db99043, count=5) = -1 [errno=11: Ресурс временно недоступен]
[SPY] read(fd=4, buf=0x5ab01db99043, count=5) = 5
[SPY] read(fd=4, buf=0x5ab01db99048, count=122) = 122
[SPY] read(fd=4, buf=0x5ab01db99043, count=5) = 5
[SPY] read(fd=4, buf=0x5ab01db99048, count=2474) = 2474
[SPY] read(fd=4, buf=0x5ab01db99043, count=5) = 5
[SPY] read(fd=4, buf=0x5ab01db99048, count=16401) = 2795
[SPY] read(fd=4, buf=0x5ab01db99b33, count=13606) = -1 [errno=11: Ресурс временно недоступен]
[SPY] read(fd=4, buf=0x5ab01db99b33, count=13606) = 1400
[SPY] read(fd=4, buf=0x5ab01db9a0ab, count=12206) = -1 [errno=11: Ресурс временно недоступен]
[SPY] read(fd=4, buf=0x5ab01db9a0ab, count=12206) = 1400
[SPY] read(fd=4, buf=0x5ab01db9a623, count=10806) = 1400
[SPY] read(fd=4, buf=0x5ab01db9ab9b, count=9406) = -1 [errno=11: Ресурс временно недоступен]
[SPY] read(fd=4, buf=0x5ab01db9ab9b, count=9406) = 1400
...
[продолжается ~300 строк с аналогичным паттерном]
...
[SPY] read(fd=4, buf=0x5ab01db99048, count=29) = 29

[SPY] ═══════════════════════════════════════════════
[SPY] Syscall spy library unloaded
[SPY] ═══════════════════════════════════════════════
```

**Анализ:**
- **Всего вызовов:** 300+ (преимущественно read)
- **Паттерн:** Чередование маленьких read(5 байт) и больших read(1400-16401 байт)
- **Особенности:** Частые EAGAIN (errno=11) из-за неблокирующего режима сокета, порционное чтение по ~1400 байт (TCP MSS)

### Сравнительная таблица

| Программа | Вызовов open/openat | Вызовов read | Вызовов write | Вызовов close |
|-----------|---------------------|--------------|---------------|---------------|
| **curl**  | 4                   | ~5           | 1             | 6             |
| **wget**  | 1                   | 300+         | 2             | 0 (видимых)   |

**Выводы:**
- **wget делает в ~60 раз больше системных вызовов** из-за неблокирующего I/O и мелкогранулярного чтения для контроля прогресса
- **curl оптимизирован** — использует внутреннюю буферизацию libcurl, минимум syscalls
- **Неожиданные файлы:** `/proc/sys/crypto/fips_enabled` открывается для проверки FIPS-режима при HTTPS соединениях
- **EAGAIN — норма** для неблокирующих сокетов, не ошибка

### Эксперимент со статической программой

**Создание:**
```bash
cat > hello_static.c << 'EOF'
#include <stdio.h>
int main() {
    FILE *f = fopen("/tmp/test.txt", "w");
    if (f) {
        fprintf(f, "Hello from static binary\n");
        fclose(f);
    }
    printf("Done\n");
    return 0;
}
EOF

gcc -static -o hello_static hello_static.c
```

**Проверка:**
```bash
ldd hello_static
	не является динамическим исполняемым файлом

file hello_static
hello_static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=c5ba5586e58ed35d0140ca62c9ef21b31ac15ed6, for GNU/Linux 3.2.0, not stripped
```

**Запуск с LD_PRELOAD:**
```bash
LD_PRELOAD=./libsyscall_spy.so ./hello_static
Done
```

**Результат:** Перехват НЕ работает, библиотека не загрузилась.

**Объяснение:**
Статическая программа встраивает все функции библиотек в исполняемый файл при компиляции. Отсутствует динамический линкер и таблицы PLT/GOT, необходимые для работы `LD_PRELOAD`. Разрешение символов происходит на этапе компиляции, нет механизма для подмены функций в runtime.

---

## Задание B: Benchmark системных вызовов

### Исходный код

Реализован бенчмарк с использованием:
- **RDTSC** (`__rdtsc()`) для измерения циклов CPU
- **`clock_gettime(CLOCK_MONOTONIC)`** для времени в наносекундах
- **Статистический анализ:** среднее, медиана, мин/макс, стандартное отклонение
- **Batch-измерения** для уменьшения влияния шума

### Таблица результатов (1 миллион итераций)

#### Холодный кэш (после `drop_caches`):

| Операция                  | Среднее (ns) | Медиана (ns) | Min (ns) | Циклов | Замедление |
|---------------------------|--------------|--------------|----------|--------|------------|
| dummy() [userspace]       | 6.03         | 2.40         | 2.40     | 6      | 1.0x       |
| getpid()                  | 481.62       | 478.77       | 477.08   | 1447   | 79.9x      |
| open()+close()            | 2399.82      | 2401.51      | 2337.58  | 7187   | 398.0x     |
| gettimeofday() [vDSO]     | 16.48        | 16.40        | 16.39    | 49     | 2.7x       |

#### Горячий кэш (обычный запуск):

| Операция                  | Среднее (ns) | Медиана (ns) | Min (ns) | Циклов | Замедление |
|---------------------------|--------------|--------------|----------|--------|------------|
| dummy() [userspace]       | 3.04         | 2.34         | 2.34     | 7      | 1.0x       |
| getpid()                  | 477.06       | 477.05       | 464.69   | 1430   | 157.0x     |
| open()+close()            | 2245.33      | 2251.83      | 2191.00  | 6761   | 738.9x     |
| gettimeofday() [vDSO]     | 16.97        | 16.39        | 15.99    | 48     | 5.6x       |

### Влияние кэша

| Операция       | Холодный (ns) | Горячий (ns) | Разница | Ускорение |
|----------------|---------------|--------------|---------|-----------|
| open()+close() | 2399.82       | 2245.33      | 154.49  | 1.07x     |
| getpid()       | 481.62        | 477.06       | 4.56    | 1.01x     |
| gettimeofday() | 16.48         | 16.97        | -0.49   | ~1.0x     |

**Выводы:** Кэш ускоряет `open()` на 7% за счёт кэширования метаданных FS (inode, dentry). На `getpid()` и `gettimeofday()` влияние минимально.

### Проверка через perf stat

```bash
sudo perf stat -e cycles,instructions,context-switches,page-faults ./benchmark
```

**Вывод:**
```
 Performance counter stats for './benchmark':
         3,459,162      cycles                                                                
         3,755,574      instructions              #    1.09  insn per cycle            
                 0      context-switches                                                      
               127      page-faults                                                           
       0.001594825 seconds time elapsed
```

**Анализ:**
- **0 context switches** — программа выполнилась атомарно
- **127 page faults** — только при инициализации, во время бенчмарка нет
- **IPC = 1.09** — эффективное использование CPU конвейера
- **Sys time = 1.638 мс** — всё время в ядре из-за syscalls

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

**Системный вызов** — это контролируемый способ для программы в user space запросить сервис у ядра операционной системы (kernel space). В отличие от обычной функции:
- Выполняется в режиме ядра (Ring 0), а не пользователя (Ring 3)
- Требует переключения контекста процессора (context switch)
- Имеет накладные расходы на проверку прав и валидацию аргументов
- Обеспечивает изоляцию и безопасность — программы не могут напрямую обращаться к оборудованию

### 2. Почему системный вызов медленнее обычной функции?

Из наших замеров: `getpid()` в **80 раз медленнее** `dummy()` (481 ns vs 6 ns).

**Причины:**
1. **Context switch:** Сохранение/восстановление всех регистров CPU (~100-150 циклов)
2. **Переключение привилегий:** Переход Ring 3 → Ring 0 (~20-30 циклов)
3. **Проверки безопасности:** Валидация аргументов, проверка прав доступа (~50-100 циклов)
4. **Переключение стека:** С userspace на kernel stack (~20 циклов)
5. **Возврат в userspace:** Обратные операции (~100-150 циклов)

**Итого:** ~400-500 циклов накладных расходов на каждый syscall, что соответствует нашим 1447 циклам для `getpid()`.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

**Как работает:**
1. Динамический линкер загружает библиотеки из `LD_PRELOAD` **перед** системными
2. При разрешении символов используется **первая найденная** версия функции
3. Наша функция вызывает оригинальную через `dlsym(RTLD_NEXT, "имя")`

**Не работает в случаях:**
- **Статические программы** — нет динамического линкера, функции встроены в бинарник
- **setuid/setgid программы** — игнорируется из соображений безопасности
- **Прямые syscall через `syscall()`** — обходят libc, напрямую в ядро

### 4. Что такое vDSO и зачем он нужен?

**vDSO (virtual Dynamic Shared Object)** — специальная область памяти, которую ядро отображает в адресное пространство каждого процесса. Содержит реализации **часто используемых syscalls без перехода в kernel mode**.

Из наших замеров: `gettimeofday()` всего в **2.7 раза медленнее** userspace функции (16 ns vs 6 ns), тогда как обычный syscall в 80 раз.

**Зачем нужен:**
- Избегает дорогостоящего context switch для простых операций
- Функции типа `gettimeofday()`, `clock_gettime()`, `getcpu()` читают данные из разделяемой памяти
- Ядро обновляет эти данные, программа читает их напрямую без syscall

### 5. Почему open() медленнее getpid() на несколько порядков?

Из замеров: `open()+close()` = 2400 ns vs `getpid()` = 481 ns = **в 5 раз медленнее**.

**getpid() делает:**
```c
return current->pid;  // Одно чтение из памяти, ~10 циклов
```

**open() делает:**
1. **Парсинг пути:** Обход dentry cache, разрешение символических ссылок
2. **Проверка прав:** Сравнение UID/GID с правами файла, проверка ACL
3. **Работа с FS:** Чтение inode, обновление времени доступа (atime)
4. **Выделение дескриптора:** Поиск свободного fd в таблице процесса
5. **Блокировки:** Захват spinlocks для синхронизации доступа к структурам ядра
6. **Возможный доступ к диску:** При cache miss (наш эксперимент показал 7% разницы)

**Влияние кэша:** Холодный кэш: 2400 ns, горячий: 2245 ns — экономия 154 ns (7%) благодаря dentry/inode cache.

---

## Общие выводы

1. **Системные вызовы дороги:** Даже простой `getpid()` в 80 раз медленнее обычной функции из-за context switch.

2. **Буферизация критична:** Разница curl (15 syscalls) vs wget (300+ syscalls) показывает важность минимизации вызовов.

3. **vDSO — важная оптимизация:** `gettimeofday()` всего в 3 раза медленнее userspace благодаря работе без kernel mode.

4. **Кэш имеет значение:** 7% ускорение `open()` в горячем кэше демонстрирует эффективность page cache.

5. **LD_PRELOAD — мощный инструмент отладки:** Позволяет анализировать поведение программ без изменения кода, но работает только с динамическими бинарниками.

---

## Воспроизводимость

```bash
# Сборка
cd src/
gcc -shared -fPIC -o libsyscall_spy.so syscall_spy.c -ldl
g++ -O2 -o benchmark benchmark.cpp

# Задание A
LD_PRELOAD=./libsyscall_spy.so curl -sS -o dota_json.txt "https://store.steampowered.com/api/appdetails?appids=570&l=en"
LD_PRELOAD=./libsyscall_spy.so wget -q -O steam_dota.html "https://store.steampowered.com/app/570/?l=english"

# Задание B
sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches' && ./benchmark
./benchmark
sudo perf stat -e cycles,instructions,context-switches,page-faults ./benchmark
```
