# Лабораторная работа #4: Системные вызовы: граница между программой и ядром
### Садовский Антон, 9-я группа, 22-й в списке, Вариант 2

# Лабораторная 4 — Системные вызовы

## Выбор программ
Номер в списке группы: 2
Расчёт группы программ: 22 % 4 = 2
Программы для анализа: curl, wget (сетевые)
Мои задания: A (LD_PRELOAD), B (Benchmark) — обязательные

## Среда выполнения
- ОС: Linux Debian 12
- Ядро: 6.1.0-32-amd64
- Процессор: 12th Gen Intel(R) Core(TM) i5-1240P
- Компилятор: gcc (Debian 12.2.0-14+deb12u1) 12.2.0

---

## Задание A: LD_PRELOAD перехват`

### Код библиотеки
- Есть расшифровка флагов open()
- Перехват open/openat/close/write/read/send/recv
- Код документирован, основан на примере из описания задачи.
- Все взаимодействие происходит через src/A/demo.sh (Сборка, установка переменной, запуск динамического сценария). Инструкция в /src/A/README.md


### Запуск экспериментов
**Команда:**
```bash
./src/A/demo.sh -t <target=curl | wget | all> -u <urls list>
```

demo.sh выполняет следующее:
1. Собирает libsyscall_spy.so
2. Устанавливает LD_PRELOAD (предварительно сохраняя предыдущее значение)
3. Запускает тесты для таргет-команды и заданного списка адресов, перенаправляя вывод в нужный лог файл. По умолчанию используется дефолтный список из 9 адресов.
4. Вырезает в полученном логе детали файловой структуры пользователя, ip-адреса, детали cookie. необходимо, т.к. работаем с сетевым взаимодействием
5. Сохраняет редактированный файл logs/A/logs/syscall_sade.txt
6. Устанавливает обратно LD_PRELOAD значение

Список адресов, к которым обращаемся по умолчанию:
```
DEFAULT_URLS=(
  "https://example.com/"
  "https://example.org/"
  "https://www.wikipedia.org/"
  "https://www.kernel.org/"
  "https://www.github.com/"
  "https://www.stackoverflow.com/"
  "https://www.google.com/"
  "https://www.yandex.com/"
  "https://nginx.org/"
)
```

### Эксперимент 1 (wget):
Полученная статистика для wget:
```
System call          | Count
---------------------+-----------
open/openat          | 19        
read                 | 1031      
write                | 10        
close                | 33        
recv                 | 3896      
send                 | 0         
---------------------+-----------
TOTAL                | 4989   
```

Тут может возникнуть вопрос, почему send вызовов 0. В моем понимании, такое может быть, если запрос wget был произвелен с помощью записи в сокет, а не напрямую через send. Либо же wget использует для отправления пакетов интерфейс, который был определен до подгрузки LD_PRELOAD.

Другие особенности:
1. wget работает со временными файлами
```
[SPY] open("/tmp/tmp.86mOOZ91wL", flags=0x0) = 3 (OK)
[SPY] read(fd=3, count=131072) = 1343
[SPY] write(fd=1, count=1343) = 1343
[SPY] read(fd=3, count=131072) = 0
[SPY] close(fd=3) = 0
...
[demo] Executing: wget 'https://www.google.com/' -O /dev/null
[SPY] open("/tmp/tmp.KFE2uMi2n7", flags=O_RDWR|O_CREAT|0xc2) = 3 (OK)
[SPY] close(fd=3) = 0
...
```

Временные файлы нужны для проведения промежуточных операций, кэширования.


### Эксперимент 2 (curl):
Полученная статистика для curl
```
System call          | Count
---------------------+-----------
open/openat          | 37        
read                 | 1223      
write                | 10        
close                | 165       
recv                 | 3420      
send                 | 136       
---------------------+-----------
TOTAL                | 4991  
```

Во время эксперимента нашлось несколько особенностей:
1. обращение к файлу ~/.curlrc
```
[SPY] open("~/user/.curlrc", flags=0x0) = 3 (OK)
```
.curlrc - это файл, который хранит в себе аргументы командной строки для выполнения curl запросов и в целом для конфигурации curl'а. Пользователь настраивает его сам, по умолчанию после установки утилиты его не было, и SPY возвращал данные об ошибке во время попытки его открыть. Для того .чтобы его использование было видно, был создан файл ~/.curlrc с содержимым:
```
# ~/.curlrc
# Этот файл читается при запуске curl и вызывает несколько системных read().

# 1. Включаем подробный вывод (curl сам вызывает read() из этого файла)
verbose

# 2. Указываем user-agent
user-agent = "curl-demo-agent/1.0"

# 3. Используем shell-команду для подстановки данных из файла (для демонстрации read)
#    Здесь .curlrc будет пытаться прочитать содержимое из файла demo_token.txt.
#    Даже если файл не существует — вызов open/read появится в логе LD_PRELOAD.
header = "X-Demo-Token: $(cat ~/demo_token.txt 2>/dev/null || echo 'no-token')"

# 4. Добавляем произвольный заголовок, чтобы видно было активность при работе
header = "X-Lab4-Demo: syscall-spy"
```

А также простой ~/demo_token.txt с содержимым:
```
secret123
```

2. curl работает с временными файлами
```
[demo] Executing: curl -L 'https://example.org/' -o /dev/null
[SPY] open("/tmp/tmp.Npp32XdMGp", flags=O_RDWR|O_CREAT|0xc2) = 3 (OK)
[SPY] close(fd=3) = 0
...
[SPY] open("/tmp/tmp.LQMsuoDpxv", flags=0x0) = 3 (OK)
[SPY] read(fd=3, count=131072) = 4468
[SPY] write(fd=1, count=4468) = 4468
[SPY] read(fd=3, count=131072) = 0
...
[SPY] open("/tmp/tmp.Npp32XdMGp", flags=0x0) = 3 (OK)
[SPY] read(fd=3, count=131072) = 4391
[SPY] write(fd=1, count=4391) = 4391
[SPY] read(fd=3, count=131072) = 0
[SPY] close(fd=3) = 0
...
```

Временные файлы нужны для проведения промежуточных операций, кэширования.



### Общие выводы
Кол-во read'ов и recv'ов обусловлено спецификой эксперимента. Мы получаем данные с помощью recv и считываем их с помощью read.

В свою очередь кол-во write/send операций обусловлено тем же. Нам нужно только отправить запрос на адрес.

Данная тенденция у отслеживается как в wget, так и в curl, что ожидаемо.

### Эксперимент 3: Static
Если собрать некоторый демо-файл в статике, например запись "Hello, World!"  (Пример программы указан в hello_world_f_static.c) в файл с использованием open->write->close, то подменить в символы в данном файле просто не выйдет.

Подменить реализацию syscall не выйдет, т.к. не отработает сам динамический линковщик. При сборке в статике, все, что нужно для запуска на заданной архитектуре процессора уже собрано в исполняемый файл. Т.е. все зависимости, библиотеки уже будут содержаться в собранном виде в исполняемом файле.

При исполнении такого файла нет этапа динамической загрузки, который бы читал LD_PRELOAD и подменял символы.Исполняемый файл не имеет PT_INTERP (нет динамического интерпретатора), значит ld-linux.so не запускается и не выполняет загрузку внешних .so.

Вызовы к функциям libc в статическом бинарнике чаще всего становятся прямыми вызовами в код, который встроен в сам исполняемый файл (или в виде локальных адресов), поэтому никакая внешняя разделяемая библиотека не может «подменить» эти символы в рантайме.

### Особенности реализации задания A:
- Интерфейс переведен под demo скрипт с CLI.
- В demo.sh обрабатывается прерывание работы скрипта и восстановление LD_PRELOAD при аварийном выходе с помощью ```trap restore_ld_preload EXIT INT TERM```
- Логфайлы отдельные для каждого таргета. 
- Чувствительная информация редактируется (заменяется на \<redacted>).
- Код подробно документирован

## Задание B: сколько стоит системный вызов?

### Реализация
- Для измерения были выбраны 5 userspace вызовов и 10 kernelspace вызовов.
- Каждый вызов был произведен 1000000 раз для составления адекватной статистики.
- Для измерения использована функция __rdtsc()
- Все взаимодействие с решением задания собрано в src/B/demo.sh
```bash
./demo.sh
```

### Таблицы для сравнения затраченных ресурсов на вызов в разных сценариях.
Результаты без дропа кэша (1000000 итераций):
```
| Function           | Type       | Avg cycles |
|--------------------|------------|------------|
| dummy()            | userspace  |      13.22 |
| empty_func()       | userspace  |      15.62 |
| increment()        | userspace  |      12.70 |
| arithmetic()       | userspace  |      14.57 |
| small_loop()       | userspace  |      13.27 |
| getpid()           | syscall    |     154.39 |
| gettimeofday()     | syscall    |      31.37 |
| time()             | syscall    |      12.58 |
| clock_gettime()    | syscall    |      32.46 |
| open+close()       | syscall    |    2082.60 |
| stat()             | syscall    |     788.89 |
| write(0B)          | syscall    |     263.31 |
| read(0B)           | syscall    |    2449.61 |
| usleep(0)          | syscall    |  125096.32 |
| getcwd()           | syscall    |     470.07 |
|--------------------|------------|------------|

```

Результаты после дропа кэша (1000000 итераций):
```
| Function           | Type       | Avg cycles |
|--------------------|------------|------------|
| dummy()            | userspace  |      16.68 |
| empty_func()       | userspace  |      12.87 |
| increment()        | userspace  |      13.85 |
| arithmetic()       | userspace  |      12.88 |
| small_loop()       | userspace  |      12.72 |
| getpid()           | syscall    |     154.43 |
| gettimeofday()     | syscall    |      31.43 |
| time()             | syscall    |      12.55 |
| clock_gettime()    | syscall    |      32.56 |
| open+close()       | syscall    |    2012.93 |
| stat()             | syscall    |     717.31 |
| write(0B)          | syscall    |     229.50 |
| read(0B)           | syscall    |    2279.43 |
| usleep(0)          | syscall    |  125194.00 |
| getcwd()           | syscall    |     404.87 |
|--------------------|------------|------------|
```

Как и ожидается, ничего не поменялось из-за большого количества обращений. Мы берем 1000000 обращений, что очень много и смысла запуска "на холодную" нет, и.к. кэш просто накопится в процессе, а вот если взять, скажем, 25 и дропнуть кэш, будут изменения:


Для 25 итераций на холодную:
```
| Function           | Type       | Avg cycles |
|--------------------|------------|------------|
| dummy()            | userspace  |      15.60 |
| empty_func()       | userspace  |      15.72 |
| increment()        | userspace  |      15.64 |
| arithmetic()       | userspace  |      15.44 |
| small_loop()       | userspace  |      23.52 |
| getpid()           | syscall    |     490.20 |
| gettimeofday()     | syscall    |    1472.36 |
| time()             | syscall    |      73.12 |
| clock_gettime()    | syscall    |      76.76 |
| open+close()       | syscall    |   32194.52 |
| stat()             | syscall    |    2005.80 |
| write(0B)          | syscall    |     442.92 |
| read(0B)           | syscall    |    3233.68 |
| usleep(0)          | syscall    |  110835.36 |
| getcwd()           | syscall    |     943.40 |
|--------------------|------------|------------|

```

Для 25 итераций на горячую (после вызова 1000000 схожих итераций):
```
| Function           | Type       | Avg cycles |
|--------------------|------------|------------|
| dummy()            | userspace  |      13.24 |
| empty_func()       | userspace  |      13.40 |
| increment()        | userspace  |      12.88 |
| arithmetic()       | userspace  |      13.04 |
| small_loop()       | userspace  |      18.44 |
| getpid()           | syscall    |     282.40 |
| gettimeofday()     | syscall    |     705.08 |
| time()             | syscall    |      56.20 |
| clock_gettime()    | syscall    |      65.16 |
| open+close()       | syscall    |    2195.68 |
| stat()             | syscall    |     790.64 |
| write(0B)          | syscall    |     291.28 |
| read(0B)           | syscall    |    2402.48 |
| usleep(0)          | syscall    |  108930.32 |
| getcwd()           | syscall    |     488.56 |
|--------------------|------------|------------|
```

Наблюдения по таблицам:
- Syscall вызовы на порядки превосходят userspace по затратности, но если говорить о том же gettimeofday, технология vDSO помогает ей быть менее затратной, если не сбрасывать кэш. 
- Значительно поменялись значения getcwd, read, write, stat, open+close, т.е. все системные вызовы, после дропа кэша, стали затратнее Даже gettimeofday (~x2). Значит, они чувствительны к кэшу.
- Userspace вызовы особо не изменились после дропа кэша (~3-5 циклов)
- Если повторять gettimeofday много раз, постепенно затратность выполнения снижается.
- usleep(0) чрезвычайно велик (>100k циклов). usleep(0) обычно вызывает планировщик: «yield» или sleep на 0 микросекунд — фактически вызывает контекстный переключатель или sched_yield, и ожидаемое время — на порядки выше, поскольку включает переход в ядро, работу планировщика и возврат. Потому и очень большое значение.


### Вывод perf-stat (25 итераций)
```
 Performance counter stats for './benchmark':

         3,184,177      cpu_core/cycles/                                                   
     <not counted>      cpu_atom/cycles/        (0.00%)
         4,112,155      cpu_core/instructions/                                             
     <not counted>      cpu_atom/instructions/  (0.00%)
                25      context-switches                                                   
               130      page-faults                                                        

       0.004920334 seconds time elapsed
       0.003835000 seconds user
```
- 25 context-switches - из-за тестированиян а usleep
- 130 page-faults - при инициализации
- 0.004920334 seconds time elapsed - всего времени исполнения
- 0.003835000 seconds user - время в userspace
- ~1мс в kernelspace (по разнице между общим и user)

## Ответы на вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

Системный вызов (syscall) — это интерфейс, через который программа в пользовательском пространстве (user mode) может запросить у ядра операционной системы выполнение операции, которая требует привилегий ядра (kernel mode).

Обычная функция выполняется целиком в пользовательском пространстве, не требует перехода в ядро.

Системный вызов:
- Переключает процессор из user mode → kernel mode.
- Включает проверки прав доступа, работу с аппаратными ресурсами и памятью.

Примеры: 
- read()
- write()
- open()
- getpid().

Системные вызовы нужны, когда программа должна взаимодействовать с оборудованием или защищёнными ресурсами, а обычные функции ограничены своей областью памяти.

### 2. Почему системный вызов медленнее обычной функции?

Причины медленной работы:
- Context switch: процессор переключается из user mode → kernel mode и обратно.
- Сохранение и восстановление регистров, состояния стека, контекста.
- Проверки прав доступа к файлам, памяти, устройствам.
- Доступ к аппаратным ресурсам (диск, сеть) — задержки I/O.
- В отличие от обычной функции, которая просто выполняется в CPU, syscall «тяжёлый» из-за перехода в ядро и всех проверок.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

LD_PRELOAD — переменная окружения, позволяющая загрузить свою динамическую библиотеку перед стандартными при запуске программы. Позволяет подменять функции, например open(), read(), write().

Ограничения:
- Работает только для динамически слинкованных программ, где символы разрешаются через динамический линкер (ld.so).
- Не работает для статических программ (-static) — код всех функций встроен, динамический линкер не используется.
- Не работает с Setuid-бинарниками — системная защита запрещает LD_PRELOAD, чтобы не дать обычному пользователю возможность перехватывать privileged-функции.

### 4. Что такое vDSO и зачем он нужен?

vDSO (virtual Dynamic Shared Object) — это специальная виртуальная библиотека, которую ядро монтирует в адресное пространство процесса. Она содержит быстрые реализации некоторых системных вызовов без перехода в ядро.
Примеры: 
- gettimeofday()
- clock_gettime()
- time().

#### Цель:
Избежать context switch, ускорить часто вызываемые syscalls, снизить накладные расходы.

Например, вместо вызова полноценного gettimeofday() через syscall, процесс просто читает значение из vDSO в user space — почти как обычная функция.

### 5. Почему open() медленнее getpid() на несколько порядков?

Разница связана с характером работы syscalls:
#### getpid():
Просто читает уже известный процессный идентификатор.
Может выполняться через vDSO → не требует обращения к файловой системе.

#### open():
Вовлекает файловую систему: поиск пути, проверка прав доступа, возможно создание inode/dentry, доступ к диску или кэшам.
Даже если файл уже в кэше, проверки прав и структура FS делают вызов дороже на порядок-два.

#### Итог: 
getpid() — быстрый syscall без I/O, open() — тяжелый, включающий FS и кэш/диск.



