# Лабораторная работа №4 — Системные вызовы: граница между программой и ядром

## Выбор программ
**Номер в списке группы:** 8  
**Расчёт:** 8 % 4 = 0  
**Программы для анализа:** `ls`, `cat`, `grep`  
**Выполненные задания:** A (LD_PRELOAD), B (Benchmark)

---

## Среда выполнения
- ОС: Ubuntu 22.04 (WSL2)
- Ядро: 5.15.133.1-microsoft-standard-WSL2
- Процессор: Intel Core i5-1135G7 (4 ядра, 8 потоков)
- Компилятор: gcc 11.4.0
- Perf доступен с ограничениями (некоторые счётчики “not supported”)

---

## Задание A — Перехват системных вызовов через LD_PRELOAD

### Код библиотеки
Реализована динамическая библиотека `libsyscall_spy.so`, перехватывающая функции:
`open`, `openat`, `read`, `write`, `close`.  
Для каждого вызова выводятся имя функции, аргументы, возвращаемое значение и код ошибки.

**Компиляция:**
```bash
gcc -O2 -fPIC -Wall -Wextra -shared -o libsyscall_spy.so syscall_spy.c -ldl
```

**Использование:**
```bash
LD_PRELOAD=./libsyscall_spy.so <программа>
```

---

### Эксперимент 1 — `ls -la /etc`
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so ls -la /etc |& tee logs_ls.txt
```

Лог перехвата содержит десятки строк `[SPY] openat(...)`, `[SPY] read(...)`, `[SPY] close(...)`.  
`ls` активно читает системные каталоги `/etc`, `/lib/x86_64-linux-gnu`, `/usr/lib`, открывает `.so`-библиотеки, а также использует `openat(AT_FDCWD, ".")` для обхода текущего каталога.

**Краткий анализ:**  
- ~60 вызовов `openat`, по одному `read` на каждый открытый каталог.  
- Основные цели: чтение записей каталогов, открытие `libselinux.so`, `libc.so`.  
- Причина большого количества вызовов — `ls` обходит дерево директорий и форматирует вывод.

---

### Эксперимент 2 — `cat /etc/hosts`
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so bash -c 'cat /etc/hosts' |& tee logs_cat.txt
```

**Вывод (из лога):**
```
[SPY] open("/etc/hosts", O_RDONLY) = 3 (OK)
[SPY] read(fd=3, buf=..., count=262144) = 273 (OK)
[SPY] write(fd=1, buf=..., count=273) = 273 (OK)
[SPY] close(fd=3) = 0 (OK)
```

**Анализ:**  
- `cat` вызывает всего 1 раз `open`, 2 раза `read` и один `write`.  
- Работает исключительно с указанным файлом и стандартными потоками.  
- Минимальное количество системных вызовов по сравнению с `ls`.

---

### Эксперимент 3 — `grep root /etc/passwd`
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so bash -c 'grep root /etc/passwd' |& tee logs_grep.txt
```

**Вывод (из лога):**
```
[SPY] open("/proc/self/maps", O_RDONLY) = 3 (OK)
[SPY] openat(AT_FDCWD, "/etc/passwd", O_RDONLY) = 3 (OK)
[SPY] read(fd=3, buf=..., count=98304) = 2810 (OK)
[SPY] close(fd=3) = 0 (OK)
```

**Анализ:**  
- `grep` открывает `/proc/self/maps` для чтения своих карт памяти (особенность glibc).  
- Затем открывает `/etc/passwd`, выполняет несколько `read` до конца файла.  
- Вывод совпадает с ожидаемым результатом фильтрации строки.

---

### Сравнительная таблица системных вызовов

| Программа | open/openat | read | write | close |
|------------|-------------|------|--------|--------|
| `ls`       | ~60         | ~60  | ~1     | ~60    |
| `cat`      | 1           | 2    | 1      | 2      |
| `grep`     | 2           | 3    | 1      | 2      |

**Выводы:**  
- `ls` делает наибольшее количество системных вызовов, так как читает множество директорий и метаданных.  
- `cat` и `grep` выполняют минимальное число вызовов.  
- Неожиданно обнаружено открытие `/proc/self/maps` у `grep`.  

---

### Проверка статически слинкованной программы

**Команда:**
```bash
gcc -static -o hello_static hello.c
LD_PRELOAD=./libsyscall_spy.so ./hello_static
```

**Результат:** перехват не сработал — `[SPY] ...` отсутствует.  
**Причина:** статическая линковка не использует динамический загрузчик, поэтому LD_PRELOAD игнорируется.

---

## Задание B — Benchmark системных вызовов

**Компиляция:**
```bash
gcc -O2 -march=native -o benchmark benchmark.c
```

**Запуск:**
```bash
./benchmark
```

### Результаты измерений

| Операция | Среднее время (ns) | Циклов CPU | Замедление относительно userspace |
|-----------|-------------------:|------------:|----------------------------------:|
| dummy() | 0.00 | 0.00 | 1x |
| getpid() | 418.44 | 960.57 | ~400x |
| open()+close() | 6973.16 | 16007.77 | ~17000x |
| gettimeofday() (vDSO) | 57.48 | 131.94 | ~130x |

---

### Эксперимент с кэшем

| Операция | “Холодный” кэш (ns) | “Горячий” кэш (ns) | Разница |
|-----------|--------------------:|--------------------:|---------:|
| open+close | 7135.95 | 6973.16 | ~2% медленнее |

Разница минимальна — файл мал, и чтение происходит из page cache.

---

### Вывод `perf stat`
```
 Performance counter stats for './benchmark':

   <not supported>      cycles
   <not supported>      instructions
                11      context-switches
                65      page-faults

       8.54 seconds time elapsed
       0.96 seconds user
       7.58 seconds sys
```

---

## Ответы на вопросы

1. **Что такое системный вызов и чем он отличается от обычной функции?**  
   Это обращение программы к ядру для выполнения привилегированных операций. В отличие от обычной функции, требует перехода из user mode в kernel mode.

2. **Почему системный вызов медленнее обычной функции?**  
   Из-за переключения контекста, проверок прав и обращения к данным ядра.

3. **Как работает LD_PRELOAD и когда не работает?**  
   Позволяет подменить функции библиотек при динамической линковке. Не действует для статических и setuid бинарей.

4. **Что такое vDSO?**  
   Virtual Dynamic Shared Object — механизм, позволяющий выполнять часто используемые вызовы (например `gettimeofday`) без перехода в ядро.

5. **Почему open() медленнее getpid()?**  
   Потому что open() включает операции с файловой системой и диском, а getpid() — простое чтение структуры в памяти ядра.

---

## Общие выводы
- Системные вызовы — дорогие операции по сравнению с функциями в userspace.  
- LD_PRELOAD позволяет наблюдать реальную работу программ без изменения их кода.  
- vDSO показывает, как ядро оптимизирует работу популярных вызовов.  
- Понимание границы userspace↔kernel помогает анализировать производительность и безопасность Linux-приложений.

---

## Воспроизводимость
```bash
make
LD_PRELOAD=./libsyscall_spy.so ls -la /etc
LD_PRELOAD=./libsyscall_spy.so bash -c 'cat /etc/hosts'
LD_PRELOAD=./libsyscall_spy.so bash -c 'grep root /etc/passwd'
./benchmark
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches
./benchmark
sudo perf stat -e cycles,instructions,context-switches,page-faults ./benchmark
```
