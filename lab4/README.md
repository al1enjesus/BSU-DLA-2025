# Лабораторная 4 — Системные вызовы: граница между программой и ядром

Курс: Проектирование приложений под Linux (DLA, 4 курс)

В предыдущих лабах вы работали с процессами (lab2) и читали данные из `/proc` (lab3). Теперь мы изучим, **как программы общаются с ядром Linux** через системные вызовы (syscalls). Это мост между вашим кодом и операционной системой.

## Что такое системный вызов (простыми словами)

Когда ваша программа хочет сделать что-то важное — открыть файл, создать процесс, выделить память — она **не может сделать это сама**. Вместо этого она просит ядро Linux сделать это за неё. Эта просьба называется **системным вызовом** (system call, syscall).

**Примеры:**
- `open("file.txt")` → ядро открывает файл и даёт дескриптор
- `fork()` → ядро создаёт новый процесс
- `write(fd, data)` → ядро записывает данные в файл/сокет

**Почему нельзя напрямую?** Потому что ядро контролирует железо (диск, память, CPU), и если каждая программа делала бы что хочет — была бы анархия. Ядро проверяет права, изолирует процессы и защищает систему.

## Цели лабораторной

- Понять, что такое системный вызов и как он работает изнутри.
- Увидеть **все** системные вызовы, которые делает программа (даже те, что скрыты библиотеками).
- Измерить **накладные расходы** (overhead) — сколько времени тратится на переход в ядро и обратно.
- Научиться **перехватывать** вызовы без изменения кода программы через `LD_PRELOAD`.
- Понять разницу между работой в userspace и kernel space.

## Подготовка среды

```bash
sudo apt update && sudo apt install -y \
  build-essential gcc gdb strace ltrace \
  linux-tools-common linux-tools-generic perf

# Проверка, что всё работает:
strace -e trace=openat ls  # должны увидеть вызовы openat() для каждого файла
perf --version             # для бенчмарков
```

**Для WSL2/виртуалки:** `perf` может требовать дополнительной настройки kernel symbols.

## Задания

**Все студенты выполняют одинаковые задания:**

- ✅ **Задание A (LD_PRELOAD)** — перехват функций библиотеки (обязательно)
- ✅ **Задание B (Benchmark)** — измерение времени системных вызовов (обязательно)
- ⭐ **Задание C* (ptrace)** — написать упрощённый strace (опционально, даёт бонусные баллы)

---

## Выбор программ для анализа

**Номер в списке определяет программы для анализа в задании A:**

```
Группа программ = (Номер в списке группы) % 4
```

Где `%` — это **остаток от деления**.

| Остаток | Программы для задания A                     |
|---------|---------------------------------------------|
| **0**   | `ls`, `cat`, `grep`                         |
| **1**   | `find`, `tar`, `cp`                         |
| **2**   | `curl`, `wget` (сетевые)                    |
| **3**   | `gcc`, `make`, `as` (компиляция)            |

**Примеры:**
- Студент №1 → 1 % 4 = **1** → анализирует `find`, `tar`, `cp`
- Студент №8 → 8 % 4 = **0** → анализирует `ls`, `cat`, `grep`
- Студент №23 → 23 % 4 = **3** → анализирует `gcc`, `make`, `as`

**В REPORT.MD обязательно укажите:**
```markdown
Номер в списке: <номер>
Программы: <номер> % 4 = <остаток> → <список программ>
```

## Где работать и как сдавать

Структура как в предыдущих лабах:

```
lab4/
  gr<группа>sub<подгруппа>/
    ФАМИЛИЯ_ИМЯ/
      REPORT.MD   # обязательный отчёт с ПОЛНЫМИ замерами
      README.md   # как запустить и воспроизвести
      src/        # исходники (C/C++), Makefile
      logs/       # логи экспериментов (вывод программ, strace, perf)
      run.sh      # (по желанию) сценарий запуска/демо
```

Ветка/PR — как в корневом `README.md`: личная ветка от `main`, работать только в своей папке, открыть PR в `main`.

---

## Обзор заданий

### A) LD_PRELOAD: перехват функций библиотеки (обязательно для всех)

**Что такое LD_PRELOAD (простыми словами):**

Когда программа вызывает функцию типа `open()`, она на самом деле вызывает функцию из библиотеки `libc.so`. **LD_PRELOAD** позволяет подсунуть вашу собственную версию этой функции **до того, как загрузится настоящая**.

**Как это работает (детально):**

1. При запуске программы **динамический линкер** (`/lib64/ld-linux-x86-64.so.2`) загружает все нужные библиотеки (`.so` файлы)
2. Если установлена переменная окружения `LD_PRELOAD`, линкер загружает указанные библиотеки **первыми**
3. При разрешении символов (функций) линкер использует **первую найденную** версию
4. Мы можем вызвать оригинальную функцию через `dlsym(RTLD_NEXT, "имя_функции")`

**Пример из жизни:**

Представьте, что вы хотите знать, какие файлы открывает программа `ls`. Вы пишете свою функцию `open()`, которая:
1. Печатает имя файла
2. Вызывает настоящую `open()` из системной библиотеки
3. Возвращает результат программе

Программа `ls` даже не знает, что её "прослушивают"!

---

#### Задание:

Напишите библиотеку `libsyscall_spy.so`, которая перехватывает:
- `open()` / `openat()` — открытие файлов
- `read()` / `write()` — чтение/запись данных
- `close()` — закрытие дескрипторов

Для каждого вызова логируйте:
- Имя функции
- Аргументы (имя файла, флаги, размер данных и т.д.)
- Результат (возвращаемое значение или ошибка)

---

#### Пример реализации (полный код):

**Файл `syscall_spy.c`:**

```c
#define _GNU_SOURCE
#include <dlfcn.h>      // dlsym
#include <stdio.h>
#include <fcntl.h>      // O_RDONLY, AT_FDCWD и т.д.
#include <stdarg.h>     // va_list для variadic функций
#include <unistd.h>

// ═════════════════════════════════════════════════════════════
// Перехват open()
// ═════════════════════════════════════════════════════════════
int open(const char *pathname, int flags, ...) {
    // Получаем указатель на оригинальную функцию
    static int (*original_open)(const char*, int, ...) = NULL;
    if (!original_open) {
        original_open = dlsym(RTLD_NEXT, "open");
    }

    // Обработка необязательного аргумента mode (для O_CREAT)
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }

    // Вызываем оригинальную функцию
    int result = original_open(pathname, flags, mode);

    // Логируем вызов
    fprintf(stderr, "[SPY] open(\"%s\", flags=0x%x) = %d\n",
            pathname, flags, result);

    return result;
}

// ═════════════════════════════════════════════════════════════
// Перехват openat()
// ═════════════════════════════════════════════════════════════
int openat(int dirfd, const char *pathname, int flags, ...) {
    static int (*original_openat)(int, const char*, int, ...) = NULL;
    if (!original_openat) {
        original_openat = dlsym(RTLD_NEXT, "openat");
    }

    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }

    int result = original_openat(dirfd, pathname, flags, mode);

    // Красивое форматирование dirfd
    const char *dirfd_str = (dirfd == AT_FDCWD) ? "AT_FDCWD" : "<fd>";
    fprintf(stderr, "[SPY] openat(%s, \"%s\", 0x%x) = %d\n",
            dirfd_str, pathname, flags, result);

    return result;
}

// ═════════════════════════════════════════════════════════════
// Перехват read()
// ═════════════════════════════════════════════════════════════
ssize_t read(int fd, void *buf, size_t count) {
    static ssize_t (*original_read)(int, void*, size_t) = NULL;
    if (!original_read) {
        original_read = dlsym(RTLD_NEXT, "read");
    }

    ssize_t result = original_read(fd, buf, count);

    fprintf(stderr, "[SPY] read(fd=%d, buf=%p, count=%zu) = %zd\n",
            fd, buf, count, result);

    return result;
}

// ═════════════════════════════════════════════════════════════
// Перехват write()
// ═════════════════════════════════════════════════════════════
ssize_t write(int fd, const void *buf, size_t count) {
    static ssize_t (*original_write)(int, const void*, size_t) = NULL;
    if (!original_write) {
        original_write = dlsym(RTLD_NEXT, "write");
    }

    ssize_t result = original_write(fd, buf, count);

    // НЕ логируем write() на stderr (иначе бесконечная рекурсия!)
    if (fd != 2) {  // 2 = stderr
        fprintf(stderr, "[SPY] write(fd=%d, buf=%p, count=%zu) = %zd\n",
                fd, buf, count, result);
    }

    return result;
}

// ═════════════════════════════════════════════════════════════
// Перехват close()
// ═════════════════════════════════════════════════════════════
int close(int fd) {
    static int (*original_close)(int) = NULL;
    if (!original_close) {
        original_close = dlsym(RTLD_NEXT, "close");
    }

    int result = original_close(fd);

    fprintf(stderr, "[SPY] close(fd=%d) = %d\n", fd, result);

    return result;
}
```

**Компиляция:**
```bash
gcc -shared -fPIC -o libsyscall_spy.so syscall_spy.c -ldl
```

**Использование:**
```bash
# Простой пример
LD_PRELOAD=./libsyscall_spy.so ls

# Вывод:
# [SPY] openat(AT_FDCWD, "/etc/ld.so.cache", 0x80000) = 3
# [SPY] close(fd=3) = 0
# [SPY] openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libselinux.so.1", 0x80000) = 3
# [SPY] read(fd=3, buf=0x7ffc12340000, count=832) = 832
# ...
# [SPY] openat(AT_FDCWD, ".", 0x90800) = 3
# [SPY] read(fd=3, buf=0x..., count=32768) = 416
# ...
```

---

#### Важные детали реализации:

**1. Почему `static` для указателя на оригинальную функцию?**
```c
static int (*original_open)(...) = NULL;
```
Чтобы `dlsym()` вызывался только один раз (при первом вызове `open()`), а не каждый раз.

**2. Почему `RTLD_NEXT`?**
```c
dlsym(RTLD_NEXT, "open")
```
Ищет следующую версию функции `open` в цепочке библиотек (не нашу!). Без этого получится бесконечная рекурсия.

**3. Почему проверка `if (fd != 2)` в `write()`?**
```c
if (fd != 2) {  // не логируем запись в stderr
    fprintf(stderr, ...);
}
```
Иначе `fprintf()` → вызовет `write(fd=2)` → наша функция → `fprintf()` → бесконечная рекурсия!

**4. Variadic функции (переменное число аргументов):**
```c
int open(const char *pathname, int flags, ...) {
    mode_t mode = 0;
    if (flags & O_CREAT) {
        va_list args;
        va_start(args, flags);
        mode = va_arg(args, mode_t);
        va_end(args);
    }
}
```
`open()` имеет опциональный третий аргумент `mode`, который нужен только при создании файла (`O_CREAT`).

---

#### Улучшения (опционально):

**Декодирование флагов `open()`:**
```c
void print_open_flags(int flags) {
    fprintf(stderr, "flags=");
    if (flags & O_RDONLY) fprintf(stderr, "O_RDONLY|");
    if (flags & O_WRONLY) fprintf(stderr, "O_WRONLY|");
    if (flags & O_RDWR)   fprintf(stderr, "O_RDWR|");
    if (flags & O_CREAT)  fprintf(stderr, "O_CREAT|");
    if (flags & O_TRUNC)  fprintf(stderr, "O_TRUNC|");
    if (flags & O_APPEND) fprintf(stderr, "O_APPEND|");
    // ...
}
```

**Вывод содержимого буфера при `write()`:**
```c
// В write():
if (fd == 1 && count < 100) {  // stdout и небольшой размер
    fprintf(stderr, "[SPY] write(fd=1, \"%.*s\", %zu)\n",
            (int)count, (char*)buf, count);
}
```

**Что показать в отчёте (ОБЯЗАТЕЛЬНО):**

**1. Код и компиляция:**
- Код библиотеки с комментариями.
- Команды компиляции и проверки (`file libsyscall_spy.so`, `ldd`).

**2. Эксперименты на выбранных программах:**
- Запуск на **всех 3 программах** с **ПОЛНЫМИ логами** (минимум 30-50 строк на каждую программу).
- **Сравнительная таблица** вызовов по программам.

**3. ОБЯЗАТЕЛЬНЫЙ АНАЛИЗ И РАССУЖДЕНИЯ** (это самое важное!):

- **Какая программа делает больше всего системных вызовов? Почему?**
  - Объясните природу работы каждой программы (файловая vs сетевая vs компиляция)
  - Например: "find делает много openat(), потому что рекурсивно обходит дерево директорий"

- **Какие неожиданные файлы открываются?**
  - Системные библиотеки (`/lib/x86_64-linux-gnu/libc.so.6` — почему именно эта?)
  - Конфигурационные файлы (`/etc/ld.so.cache` — зачем нужен?)
  - Псевдо-файлы (`/proc/filesystems`, `/sys/...` — для чего программа их читает?)

- **Сравните профили вызовов:**
  - Почему у одной программы много `read()`, а у другой — много `write()`?
  - Какая программа открывает файлы чаще остальных и почему?

- **Что узнали нового о работе программ?**
  - Были ли неожиданности? Что удивило?
  - Как это помогает в отладке и оптимизации?

**4. Эксперимент со статической программой:**
- Скомпилируйте простую программу с `-static`
- Запустите с `LD_PRELOAD` и покажите, что перехват НЕ работает
- **ОБЪЯСНИТЕ ДЕТАЛЬНО:** почему LD_PRELOAD не работает на статических программах? (динамический линкер, разрешение символов, встраивание кода)

---

### B) Benchmark: сколько стоит системный вызов? (обязательно)

**Зачем это нужно:**

Системный вызов — это дорого! Процессор переключается из user mode в kernel mode, сохраняет регистры, выполняет код ядра, и возвращается обратно. Для быстрых программ это может быть узким местом.

**Задание:**

Измерьте время выполнения разных типов вызовов:

1. **Быстрая функция в userspace** (без syscall):
   ```c
   int dummy() { return 42; }
   ```

2. **Быстрый системный вызов** (почти ничего не делает):
   ```c
   getpid();  // просто возвращает PID из кэша ядра
   ```

3. **Медленный системный вызов** (обращение к диску):
   ```c
   int fd = open("/tmp/testfile", O_RDONLY);
   close(fd);
   ```

4. **vDSO-вызов** (специальная оптимизация ядра):
   ```c
   gettimeofday(&tv, NULL);  // выполняется БЕЗ перехода в ядро!
   ```

**Как измерить:**

Используйте **RDTSC** (Read Time-Stamp Counter) — инструкция процессора, которая возвращает количество тактов:

```c
#include <x86intrin.h>

uint64_t start = __rdtsc();
getpid();  // измеряемый код
uint64_t end = __rdtsc();
printf("Cycles: %lu\n", end - start);
```

Или используйте `clock_gettime(CLOCK_MONOTONIC, ...)` (но это само по себе syscall, правда быстрый через vDSO).

**Запустите каждый вызов 1 миллион раз** и посчитайте среднее время.

**Что показать в отчёте (ОБЯЗАТЕЛЬНО):**

**1. Код и результаты:**
- Полный код `benchmark.c` с комментариями
- **Полный вывод программы** `./benchmark` (все итерации и результаты)
- **Таблицу с результатами** (в наносекундах и тактах CPU):
  ```
  | Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
  |--------------------|------------|------------|------------------------------------|
  | dummy()            | 2 ns       | 5 cycles   | 1x (базовая линия)                 |
  | getpid()           | 150 ns     | 400 cycles | 75x                                |
  | open+close         | 5000 ns    | 13000 cyc  | 2500x                              |
  | gettimeofday vDSO  | 20 ns      | 50 cycles  | 10x                                |
  ```

**2. Эксперименты:**
- **Эксперимент с кэшем**: запустите бенчмарк `open()` дважды — со сбросом кэша (`echo 3 > /proc/sys/vm/drop_caches`) и без. Покажите разницу в таблице.
- **Вывод `perf stat`** (ОБЯЗАТЕЛЬНО):
  ```bash
  perf stat -e cycles,instructions,context-switches,page-faults ./benchmark
  ```
  Вставьте полный вывод.

**3. ОБЯЗАТЕЛЬНЫЙ АНАЛИЗ И РАССУЖДЕНИЯ** (это самое важное!):

- **Почему системный вызов в 50-100 раз медленнее userspace функции?**
  - Объясните механизм context switch (user mode → kernel mode)
  - Что происходит с регистрами CPU?
  - Почему ядро должно проверять права доступа?
  - Приведите конкретные числа из ваших замеров

- **Почему `open()` в ~2000 раз медленнее `getpid()`?**
  - Что делает `getpid()`: просто читает поле структуры в ядре
  - Что делает `open()`: файловая система, парсинг пути, проверка прав, блокировки, возможно обращение к диску
  - Как влияет кэш page cache? (используйте данные из эксперимента с `drop_caches`)

- **Что такое vDSO и почему это важно?**
  - Почему `gettimeofday()` всего в 10 раз медленнее userspace функции?
  - Как vDSO избегает context switch?
  - Какие ещё функции могут быть в vDSO? (подумайте о часто используемых syscalls)

- **Анализ `perf stat` вывода:**
  - Сколько context switches произошло на 1 млн итераций? Почему не 1 млн?
  - Сколько page faults? О чём это говорит?
  - Какой IPC (instructions per cycle)? Высокий или низкий? Почему?

- **Практические выводы:**
  - Как эти знания помогут оптимизировать код?
  - В каких ситуациях стоит избегать системных вызовов?
  - Когда буферизация важна?

---

### C*) Tracer: пишем свой упрощённый strace через ptrace (опционально, со звёздочкой)

**Что такое strace (простыми словами):**

`strace` — это программа, которая "подглядывает" за другой программой и показывает **все** системные вызовы, которые она делает. Это как логирование, но извне, без изменения кода.

**Как это работает:**

Используется системный вызов `ptrace()` — он позволяет одному процессу (tracer/родитель) контролировать другой процесс (tracee/дочерний):
- **Останавливать** его в определённых точках (например, перед каждым syscall)
- **Читать** его память и регистры CPU
- **Изменять** регистры (можно подменить аргументы syscall!)
- **Возобновлять** выполнение

**Архитектура решения:**

```
┌─────────────────┐                    ┌──────────────────┐
│  Родитель       │                    │  Дочерний процесс│
│  (tracer)       │                    │  (tracee)        │
├─────────────────┤                    ├──────────────────┤
│ 1. fork()       │───────создаёт────>│                  │
│                 │                    │ 2. ptrace(       │
│                 │                    │    PTRACE_TRACEME│
│                 │                    │    )             │
│                 │                    │ 3. execvp("ls")  │
│                 │                    │    ↓             │
│ 4. waitpid()    │<───останавливает───│ SIGTRAP (готов) │
│                 │                    │                  │
│ while(1) {      │                    │                  │
│   PTRACE_SYSCALL│───────продолжить──>│ до след. syscall │
│   waitpid()     │<───────останов─────│ SIGTRAP!         │
│   GETREGS       │────читать регистры─│ rax=номер syscall│
│   printf(...)   │                    │                  │
│   PTRACE_SYSCALL│───────продолжить──>│ выполнить syscall│
│   waitpid()     │<───────останов─────│ SIGTRAP (выход)  │
│ }               │                    │                  │
└─────────────────┘                    └──────────────────┘
```

**Задание:**

Напишите упрощённую версию `strace` — программу `mytracer`, которая:
1. Запускает дочерний процесс (например, `ls`) через `fork()` + `execvp()`
2. Перехватывает каждый системный вызов (вход и выход)
3. Выводит номер syscall из регистра `orig_rax` (x86_64)
4. (Опционально) Декодирует номер в имя syscall
5. (Опционально) Показывает аргументы и возвращаемое значение

---

#### Шаг 1: Базовая версия (только номера syscalls)

**Полный код `mytracer_basic.c` с подробными комментариями:**

```c
#define _GNU_SOURCE
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/user.h>   // struct user_regs_struct
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <program> [args...]\n", argv[0]);
        return 1;
    }

    pid_t child = fork();

    if (child == -1) {
        perror("fork");
        return 1;
    }

    if (child == 0) {
        // ═══════════════════════════════════════════════════════════
        // ДОЧЕРНИЙ ПРОЦЕСС (tracee)
        // ═══════════════════════════════════════════════════════════

        // Шаг 1: Разрешаем родителю трассировать нас
        // После этого вызова каждый execve() будет вызывать SIGTRAP
        if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) == -1) {
            perror("ptrace(PTRACE_TRACEME)");
            exit(1);
        }

        // Шаг 2: Запускаем целевую программу (например, ls)
        // execvp() заменяет наш процесс новой программой
        // argv[1] = имя программы, &argv[1] = массив аргументов
        execvp(argv[1], &argv[1]);

        // Если дошли сюда — execvp() провалился
        perror("execvp");
        exit(1);

    } else {
        // ═══════════════════════════════════════════════════════════
        // РОДИТЕЛЬСКИЙ ПРОЦЕСС (tracer)
        // ═══════════════════════════════════════════════════════════

        int status;

        // Шаг 1: Ждём первой остановки дочернего процесса
        // Она происходит сразу после execvp() из-за PTRACE_TRACEME
        waitpid(child, &status, 0);

        // Шаг 2: Настраиваем опции трассировки
        // PTRACE_O_TRACESYSGOOD: при остановке на syscall ставим бит 0x80 в status
        // Это позволяет отличить остановку на syscall от обычного сигнала
        ptrace(PTRACE_SETOPTIONS, child, 0, PTRACE_O_TRACESYSGOOD);

        printf("[TRACER] Started tracing PID %d\n", child);

        // Шаг 3: Основной цикл трассировки
        while (1) {
            // 3.1: Продолжить выполнение до ВХОДА в следующий syscall
            if (ptrace(PTRACE_SYSCALL, child, 0, 0) == -1) {
                perror("ptrace(PTRACE_SYSCALL)");
                break;
            }

            // 3.2: Ждём остановки (дочерний остановился ПЕРЕД syscall)
            if (waitpid(child, &status, 0) == -1) {
                perror("waitpid");
                break;
            }

            // 3.3: Проверяем, завершился ли процесс
            if (WIFEXITED(status)) {
                printf("[TRACER] Process exited with code %d\n",
                       WEXITSTATUS(status));
                break;
            }

            if (WIFSIGNALED(status)) {
                printf("[TRACER] Process killed by signal %d\n",
                       WTERMSIG(status));
                break;
            }

            // 3.4: Читаем регистры процесса
            struct user_regs_struct regs;
            if (ptrace(PTRACE_GETREGS, child, 0, &regs) == -1) {
                perror("ptrace(PTRACE_GETREGS)");
                break;
            }

            // 3.5: Выводим номер системного вызова
            // На x86_64:
            //   orig_rax = номер syscall (исходное значение rax)
            //   rdi, rsi, rdx, r10, r8, r9 = аргументы 1-6
            printf("syscall(%lld)\n", regs.orig_rax);

            // 3.6: Продолжить выполнение до ВЫХОДА из syscall
            if (ptrace(PTRACE_SYSCALL, child, 0, 0) == -1) {
                perror("ptrace(PTRACE_SYSCALL)");
                break;
            }

            // 3.7: Ждём остановки (дочерний остановился ПОСЛЕ syscall)
            if (waitpid(child, &status, 0) == -1) {
                perror("waitpid");
                break;
            }

            if (WIFEXITED(status) || WIFSIGNALED(status)) {
                break;
            }

            // Здесь можно прочитать regs.rax для получения return value
            // но мы пока пропускаем
        }
    }

    return 0;
}
```

**Компиляция и запуск:**
```bash
gcc -o mytracer mytracer_basic.c
./mytracer ls

# Вывод:
# [TRACER] Started tracing PID 12345
# syscall(59)   # execve
# syscall(21)   # access
# syscall(21)   # access
# syscall(257)  # openat
# syscall(5)    # fstat
# syscall(9)    # mmap
# syscall(3)    # close
# ...
# [TRACER] Process exited with code 0
```

**Что делает каждый ptrace вызов:**

1. **`PTRACE_TRACEME`** (в дочернем): "Разреши родителю меня контролировать"
2. **`PTRACE_SETOPTIONS`**: Настройки (здесь: отличать syscall от сигналов)
3. **`PTRACE_SYSCALL`**: "Продолжить до следующего syscall" (вход или выход)
4. **`PTRACE_GETREGS`**: "Дай мне все регистры процессора"

**Почему два `waitpid()` на каждый syscall?**

Каждый системный вызов имеет **две точки остановки**:
1. **Вход** (before syscall): здесь `orig_rax` = номер syscall, `rdi/rsi/...` = аргументы
2. **Выход** (after syscall): здесь `rax` = возвращаемое значение

```
   Процесс          Tracer
   ───────          ──────
   [код]
   syscall() ────> СТОП (вход) ──> waitpid() #1, read orig_rax
                   PTRACE_SYSCALL
   [ядро выполняет]
   return ───────> СТОП (выход) ──> waitpid() #2, read rax (result)
                   PTRACE_SYSCALL
   [код]
```

---

#### Шаг 2: Декодирование номеров syscalls в имена

Номера syscalls определены в `/usr/include/asm/unistd_64.h`:
- 0 = read
- 1 = write
- 2 = open (старый, deprecated)
- 257 = openat (новый)
- и т.д. (всего ~330 syscalls в Linux)

**Создайте файл `syscall_names.h`:**

```c
#ifndef SYSCALL_NAMES_H
#define SYSCALL_NAMES_H

// Массив имён системных вызовов для x86_64
// Индекс = номер syscall, значение = имя
static const char *syscall_names[] = {
    [0] = "read",
    [1] = "write",
    [2] = "open",
    [3] = "close",
    [4] = "stat",
    [5] = "fstat",
    [6] = "lstat",
    [7] = "poll",
    [8] = "lseek",
    [9] = "mmap",
    [10] = "mprotect",
    [11] = "munmap",
    [12] = "brk",
    // ... (добавьте остальные по /usr/include/asm/unistd_64.h)
    [21] = "access",
    [39] = "getpid",
    [56] = "clone",
    [57] = "fork",
    [59] = "execve",
    [60] = "exit",
    [61] = "wait4",
    [62] = "kill",
    [63] = "uname",
    [72] = "fcntl",
    [78] = "getdents",
    [79] = "getcwd",
    [80] = "chdir",
    [257] = "openat",
    [262] = "newfstatat",
    [318] = "getrandom",
    // Всего можно добавить до 400 (с запасом)
};

#define SYSCALL_MAX (sizeof(syscall_names) / sizeof(syscall_names[0]))

const char *get_syscall_name(long long syscall_num) {
    if (syscall_num < 0 || syscall_num >= SYSCALL_MAX) {
        return "unknown";
    }
    const char *name = syscall_names[syscall_num];
    return name ? name : "unknown";
}

#endif
```

**Используйте в mytracer:**

```c
#include "syscall_names.h"

// В цикле трассировки:
printf("%s(%lld)\n", get_syscall_name(regs.orig_rax), regs.orig_rax);

// Вывод:
// execve(59)
// access(21)
// openat(257)
// fstat(5)
```

---

#### Шаг 3: Показываем аргументы и возвращаемое значение

**Расширенная версия `mytracer_advanced.c`:**

```c
// ... (предыдущие includes)
#include "syscall_names.h"

int main(int argc, char *argv[]) {
    // ... (код fork, PTRACE_TRACEME, execvp)

    while (1) {
        // Вход в syscall
        ptrace(PTRACE_SYSCALL, child, 0, 0);
        waitpid(child, &status, 0);
        if (WIFEXITED(status)) break;

        struct user_regs_struct regs_enter;
        ptrace(PTRACE_GETREGS, child, 0, &regs_enter);

        long long syscall_num = regs_enter.orig_rax;
        const char *name = get_syscall_name(syscall_num);

        // Выход из syscall
        ptrace(PTRACE_SYSCALL, child, 0, 0);
        waitpid(child, &status, 0);
        if (WIFEXITED(status)) break;

        struct user_regs_struct regs_exit;
        ptrace(PTRACE_GETREGS, child, 0, &regs_exit);

        long long retval = regs_exit.rax;

        // Красивый вывод
        printf("%s(", name);

        // Аргументы (если известны для конкретного syscall)
        if (syscall_num == 39) {  // getpid()
            printf(") = %lld\n", retval);
        } else if (syscall_num == 1) {  // write(fd, buf, count)
            printf("fd=%lld, buf=0x%llx, count=%lld) = %lld\n",
                   regs_enter.rdi, regs_enter.rsi, regs_enter.rdx, retval);
        } else {
            // Общий формат для остальных
            printf("0x%llx, 0x%llx, 0x%llx) = %lld\n",
                   regs_enter.rdi, regs_enter.rsi, regs_enter.rdx, retval);
        }
    }

    return 0;
}
```

**Пример вывода:**
```
execve(0x7ffc1234, 0x7ffc5678, 0x7ffc9abc) = 0
access(0x7f9a12345678, 0x0, 0x0) = -2
openat(0xffffff9c, 0x7f9a12340000, 0x80000) = 3
fstat(0x3, 0x7ffc12340000, 0x0) = 0
mmap(0x0, 0x1234, 0x3) = 140123456789
close(0x3, 0x0, 0x0) = 0
write(fd=1, buf=0x7ffc1000, count=15) = 15
getpid() = 12345
```

**Для чтения строк (например, имя файла в openat):**

```c
// Чтение строки из памяти дочернего процесса
char *read_string(pid_t child, unsigned long long addr) {
    static char buffer[256];
    for (int i = 0; i < 256; i += sizeof(long)) {
        long data = ptrace(PTRACE_PEEKDATA, child, addr + i, NULL);
        memcpy(buffer + i, &data, sizeof(long));
        if (strchr((char*)&data, '\0')) break;
    }
    buffer[255] = '\0';
    return buffer;
}

// Использование:
if (syscall_num == 257) {  // openat(dfd, filename, flags)
    char *filename = read_string(child, regs_enter.rsi);
    printf("openat(AT_FDCWD, \"%s\", %lld) = %lld\n",
           filename, regs_enter.rdx, retval);
}

// Вывод:
// openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY) = 3
```

**Что показать в отчёте (ОБЯЗАТЕЛЬНО):**
- Код tracer'а с комментариями.
- **Полный вывод трассировки** простой программы (`/bin/true`, `ls`):
  ```bash
  ./mytracer /bin/true
  ```
  Вставьте все syscalls (минимум 50-100 строк).
- **Расшифровка первых 10 вызовов** в таблице (номер → имя → назначение).
- **Сравнение со `strace`**:
  ```bash
  strace -c /bin/true        # официальный strace
  ./mytracer /bin/true | sort | uniq -c | sort -nr | head -10  # ваш tracer
  ```
  Покажите оба вывода и таблицу сравнения (совпадают ли частоты вызовов?).
- **Измерение overhead** (ОБЯЗАТЕЛЬНО):
  ```bash
  time ls -R /usr/include > /dev/null           # без трассировки
  time strace -o /dev/null ls -R /usr/include > /dev/null  # со strace
  time ./mytracer ls -R /usr/include > /dev/null           # с вашим tracer
  ```
  Таблица с тремя временами и процентом замедления.
- Объяснение: почему `ptrace()` так медленный? (каждый syscall требует двух остановок, context switch, копирование регистров)

---


## Что конкретно нужно сделать (чек-лист)

### Код (в `src/`):
- [ ] **A)** Библиотека `libsyscall_spy.so` с перехватом `open/openat/read/write/close` (обязательно для всех).
- [ ] **B)** Программа `benchmark.c` для измерения времени syscalls (обязательно для всех).
- [ ] **C*)** (опционально) Программа `mytracer.c` — упрощённый strace через ptrace.
- [ ] `Makefile` или чёткие команды сборки в `README.md`.

### Эксперименты (в `REPORT.MD`) — ОБЯЗАТЕЛЬНО МНОГО ЗАМЕРОВ:
- [ ] **Задание A:** запуск на **3 программах из вашей группы** с полными логами (30-50 строк на программу), сравнительная таблица, эксперимент со статической программой.
- [ ] **Задание B:** таблица результатов, полный вывод программы, perf stat, эксперимент с кэшем, выводы.
- [ ] **Задание C* (опционально):** полный вывод трассировки, сравнение со strace, измерение overhead.
- [ ] **Минимум 150 строк выводов** в code blocks суммарно (для A+B обязательных заданий).

---

## Вопросы для отчёта (ответить обязательно)

1. **Что такое системный вызов и чем он отличается от обычной функции?**
   - Подсказка: user mode vs kernel mode, защита памяти.

2. **Почему системный вызов медленнее обычной функции?**
   - Подсказка: context switch, сохранение регистров, проверки прав.

3. **Как работает LD_PRELOAD и в каких случаях он НЕ работает?**
   - Подсказка: динамическая линковка, статические программы, `setuid` бинарники.

4. **Что такое vDSO и зачем он нужен?**
   - Подсказка: избегание context switch для быстрых syscalls типа `gettimeofday()`.

5. **Почему `open()` медленнее `getpid()` на несколько порядков?**
   - Подсказка: файловая система, диск, кэши, проверка прав доступа.

6. **(Для задания C*)** Почему `ptrace()` так сильно замедляет программу?
   - Подсказка: две остановки на каждый syscall, context switch, копирование данных.

---

## ТРЕБОВАНИЯ К ОТЧЁТУ (REPORT.MD) — ДЕТАЛЬНО

**ВАЖНО:** Отчёт должен содержать **МНОГО выводов программ и замеров**. Это не просто описание кода, а полноценное исследование с данными!

### Обязательная структура REPORT.MD:

```markdown
# Лабораторная 4 — Системные вызовы

## Выбор программ
Номер в списке группы: <ваш номер>
Расчёт группы программ: <номер> % 4 = <результат>
Программы для анализа: <список из таблицы>
Мои задания: A (LD_PRELOAD), B (Benchmark) — обязательные, C* (ptrace) — опционально

## Среда выполнения
- ОС: <Linux/WSL2/VM, версия дистрибутива>
- Ядро: <uname -r>
- Процессор: <lscpu | grep "Model name">
- Компилятор: <gcc --version>

---

## Задание A: LD_PRELOAD перехват
**(Обязательно для всех)**

### Код библиотеки
<Краткое описание реализации, какие функции перехватываете>

### Эксперимент 1: Программа 1 из вашей группы
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so <программа> <аргументы>
```

**Полный вывод (первые 30-50 строк):**
```
[вставьте вывод программы]
```

**Анализ:**
- Сколько всего вызовов: <число>
- Какие файлы открывались: <список>
- Неожиданности: <что удивило>

### Эксперимент 2: Программа 2 из вашей группы
<аналогично>

### Эксперимент 3: Программа 3 из вашей группы
<аналогично>

### Сравнительная таблица
| Программа | Вызовов open/openat | Вызовов read | Вызовов write | Вызовов close |
|-----------|---------------------|--------------|---------------|---------------|
| <prog1>   | X                   | Y            | Z             | W             |
| <prog2>   | ...                 | ...          | ...           | ...           |
| <prog3>   | ...                 | ...          | ...           | ...           |

**Выводы:**
- Какая программа делает больше всего системных вызовов?
- Почему? (природа работы: файловая vs сетевая vs компиляция)
- Какие неочевидные файлы открываются? (библиотеки, конфиги, /proc, /sys)

### Проверка на статически слинкованной программе
**Команда:**
```bash
# Создаём статическую программу
gcc -static -o hello_static hello.c
LD_PRELOAD=./libsyscall_spy.so ./hello_static
```

**Результат:**
```
<вывод — должен быть пустым, перехвата нет>
```

**Объяснение:** почему LD_PRELOAD не работает на статических программах?

---

## Задание B: Benchmark системных вызовов
**(Обязательно для всех)**

### Исходный код
<Краткое описание методики измерения>

### Таблица результатов (1 миллион итераций)

| Операция                  | Среднее время (ns) | Циклов CPU | Во ск. раз медленнее userspace |
|---------------------------|--------------------|------------|---------------------------------|
| dummy() userspace         | <значение>         | <значение> | 1x (baseline)                   |
| getpid()                  | <значение>         | <значение> | <X>x                            |
| open("/tmp/test")+close() | <значение>         | <значение> | <Y>x                            |
| gettimeofday() vDSO       | <значение>         | <значение> | <Z>x                            |

**Команды для воспроизведения:**
```bash
./benchmark
```

**Вывод программы (полностью):**
```
<вставьте вывод>
```

### Дополнительный замер: влияние кэша страниц
**Эксперимент:** сравнить `open()` на файле в кэше vs без кэша

```bash
# Сброс кэша (требует root)
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches

# Первый запуск (холодный кэш)
./benchmark_open

# Второй запуск (горячий кэш)
./benchmark_open
```

**Результаты:**
- Холодный кэш: <значение> ns
- Горячий кэш: <значение> ns
- Разница: <X>x

### Проверка через perf stat
```bash
perf stat -e cycles,instructions,context-switches,page-faults ./benchmark
```

**Вывод:**
```
<вставьте вывод perf stat>
```

**Анализ:**
- Сколько context switches на миллион итераций?
- Сколько page faults?
- IPC (instructions per cycle) — высокий или низкий?

**Выводы:**
- Почему системный вызов в 50-100 раз медленнее userspace функции?
- Что такое vDSO и почему gettimeofday() быстрее обычного syscall?
- Какие факторы влияют на время выполнения open()? (файловая система, кэш, права)

---

## Задание C*: Tracer через ptrace
**(Опционально со звёздочкой — для всех студентов)**

### Исходный код
<Краткое описание реализации>

### Эксперимент: трассировка простой программы

**Команда:**
```bash
./mytracer /bin/true
```

**Полный вывод:**
```
<вставьте вывод — все syscalls с номерами>
```

**Расшифровка первых 10 вызовов:**
| Номер syscall | Имя syscall | Назначение                |
|---------------|-------------|---------------------------|
| 59            | execve      | Запуск программы          |
| 257           | openat      | Открытие файла            |
| ...           | ...         | ...                       |

### Сравнение с настоящим strace

**Команда strace:**
```bash
strace -c /bin/true
```

**Вывод strace -c:**
```
<вставьте таблицу частоты вызовов>
```

**Команда вашего tracer:**
```bash
./mytracer /bin/true | sort | uniq -c | sort -nr | head -10
```

**Вывод:**
```
<топ-10 syscalls от вашего tracer>
```

**Сравнительная таблица:**
| Syscall | Частота (strace) | Частота (mytracer) | Совпадает? |
|---------|------------------|--------------------|------------|
| mmap    | X                | Y                  | ✓/✗        |
| ...     | ...              | ...                | ...        |

**Выводы:**
- Совпадают ли результаты?
- Если есть расхождения — почему? (mytracer может пропускать некоторые вызовы)
- Насколько сложно декодировать аргументы syscalls? (strace делает это автоматически)

### Измерение overhead трассировки

**Без трассировки:**
```bash
time ls -R /usr/include > /dev/null
# real 0m0.123s
```

**С strace:**
```bash
time strace -o /dev/null ls -R /usr/include > /dev/null
# real 0m3.456s  (в 28 раз медленнее!)
```

**С вашим tracer:**
```bash
time ./mytracer ls -R /usr/include > /dev/null
# real 0m3.XXXs
```

**Таблица:**
| Метод       | Время (секунды) | Замедление |
|-------------|-----------------|------------|
| Без трассир.| <значение>      | 1x         |
| strace      | <значение>      | <X>x       |
| mytracer    | <значение>      | <Y>x       |

**Вывод:** почему ptrace такой медленный?

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?
<Ваш развёрнутый ответ с примерами из экспериментов>

### 2. Почему системный вызов медленнее обычной функции?
<Ваш ответ с отсылкой к замерам из задания B>

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?
<Ваш ответ с отсылкой к экспериментам из задания A>

### 4. Что такое vDSO и зачем он нужен?
<Ваш ответ с данными из бенчмарка>

### 5. Почему open() медленнее getpid() на несколько порядков?
<Ваш ответ с конкретными числами из бенчмарка>

---

## Общие выводы

- Что нового узнали о работе syscalls?
- Какие инструменты показались наиболее полезными?
- Какие трудности возникли?
- Как понимание границы userspace↔kernel поможет в дальнейшем изучении Linux?

---

## Воспроизводимость

### Команды для полного воспроизведения

```bash
# Сборка
cd src/
make

# Задание A
LD_PRELOAD=./libsyscall_spy.so ls -la

# Задание B
./benchmark

# Задание C* (опционально)
./mytracer /bin/true
```

### Окружение
- <список установленных пакетов>
- <особенности среды: WSL2, VM, physical Linux>
```

---

## Критерии зачёта

### Обязательные требования:

**Для всех (задания A и B):**
- ✅ **A (LD_PRELOAD)** библиотека работает, логирует вызовы, показаны эксперименты на **3 программах из вашей группы** с полными выводами (30-50 строк на программу), сравнительная таблица, эксперимент со статической программой.
- ✅ **B (Benchmark)** выполнено полностью: таблица с результатами, полный вывод программы, проверка через `perf stat`, эксперимент с кэшем, выводы корректны и подкреплены данными.
- ✅ **Отчёт** содержит **МНОГО выводов программ** (не менее 150 строк суммарно в code blocks для заданий A+B).
- ✅ Все таблицы заполнены **реальными данными** (не пустые шаблоны, не примерные значения).
- ✅ Ответы на обязательные вопросы (минимум вопросы 1-5) со ссылками на ваши эксперименты.
- ✅ Код компилируется, инструкции воспроизводимы.
- ✅ Группа программ выбрана правильно (номер в списке % 4), программы для анализа соответствуют таблице.

### Опциональное (для повышенной оценки):
- ⭐ **C* (ptrace tracer)** — полная реализация с декодированием syscalls, полный вывод трассировки (50-100 строк), сравнение со `strace -c`, таблица совпадений, измерение overhead.
- ⭐ Дополнительные эксперименты в задании B: сравнение файловых систем (ext4 vs tmpfs), анализ через `perf record`, влияние турбобуста CPU.
- ⭐ Декодирование аргументов syscalls в LD_PRELOAD (чтение флагов `open()`, показ содержимого буферов `read/write`).

### Частые причины возврата на доработку:
- ❌ **Неправильные программы:** использованы не программы из вашей группы (проверьте таблицу!).
- ❌ Отчёт без выводов программ (только описание кода).
- ❌ Таблицы не заполнены или заполнены "примерными" значениями типа "<значение>".
- ❌ Нет полных выводов программ (только фрагменты "...").
- ❌ Эксперименты не выполнены (например, "эксперимент с кэшем" только описан, но не запущен).
- ❌ Ответы на вопросы общие из интернета, без привязки к вашим данным и экспериментам.
- ❌ Менее 150 строк суммарно в code blocks с выводами программ.

**Примечания:**
- **macOS:** системные вызовы отличаются (Mach kernel), `ptrace` ограничен. Делайте в Linux/WSL2/VM; опишите ограничения.
- **WSL2:** большинство работает корректно.

---

## Подсказки и частые ошибки

### LD_PRELOAD не работает?
- Проверьте, что программа динамически слинкована: `ldd /bin/ls` (должны быть `.so` библиотеки).
- Статические программы (`ls --version` → GNU coreutils обычно динамические, но `/bin/busybox` статический).
- `sudo` игнорирует `LD_PRELOAD` для безопасности.

### Бенчмарк показывает странные результаты?
- Процессор может спать (frequency scaling) — отключите: `sudo cpupower frequency-set --governor performance`.
- Компилятор оптимизирует "пустые" циклы — используйте `volatile` или `__attribute__((noinline))`.
- Первый вызов всегда медленнее (cold cache) — делайте warmup.

### ptrace не компилируется?
- Включите `#define _GNU_SOURCE` перед `#include`.
- На некоторых системах нужен флаг `ptrace(PTRACE_SEIZE, ...)` вместо старого API.

---

## Связь с другими лабами и курсом

- **Lab2 (процессы):** Вы создавали процессы и управляли ими. Теперь видите, что каждый `fork()`, `kill()`, `wait()` — это системный вызов.
- **Lab3 (/proc):** Вы читали метрики из `/proc/<pid>/`. Теперь понимаете, что `/proc` наполняется ядром при обработке syscalls.
- **Дальнейшее изучение:** Понимание границы userspace↔kernel — база для углубленной работы с Linux на уровне ядра.

---

## Быстрый старт (пример для A)

```bash
# 1. Создайте файл src/syscall_spy.c:
cat > src/syscall_spy.c << 'EOF'
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <fcntl.h>

int open(const char *pathname, int flags, ...) {
    fprintf(stderr, "[SPY] open(%s)\n", pathname);
    int (*orig_open)(const char*, int, ...) = dlsym(RTLD_NEXT, "open");
    return orig_open(pathname, flags);
}
EOF

# 2. Соберите библиотеку:
gcc -shared -fPIC -o libsyscall_spy.so src/syscall_spy.c -ldl

# 3. Запустите ls с перехватом:
LD_PRELOAD=./libsyscall_spy.so ls

# Вывод:
# [SPY] open(/etc/ld.so.cache)
# [SPY] open(/lib/x86_64-linux-gnu/libc.so.6)
# ...
```

---

## Дополнительные материалы (опционально)

- **Список системных вызовов Linux:** `man syscalls` или https://filippo.io/linux-syscall-table/
- **ptrace глубже:** `man 2 ptrace`, примеры в strace source code (https://github.com/strace/strace)
- **vDSO explanation:** https://man7.org/linux/man-pages/man7/vdso.7.html

---

## Быстрая справка

**ВСЕ студенты делают одинаковые задания:**
- ✅ **A (LD_PRELOAD)** — обязательно
- ✅ **B (Benchmark)** — обязательно
- ⭐ **C* (ptrace)** — опционально (бонусные баллы)

**Номер в списке определяет программы для анализа в задании A:**

```
┌──────────┬────────────────────────────────────────────┐
│ Остаток  │  Программы для анализа (задание A)         │
├──────────┼────────────────────────────────────────────┤
│  0       │  ls, cat, grep                             │
│  1       │  find, tar, cp                             │
│  2       │  curl, wget                                │
│  3       │  gcc, make, as                             │
└──────────┴────────────────────────────────────────────┘

Группа программ = (номер в списке) % 4

Примеры:
  Студент №1  → 1 % 4 = 1 → find, tar, cp
  Студент №8  → 8 % 4 = 0 → ls, cat, grep
  Студент №23 → 23 % 4 = 3 → gcc, make, as
```

**Удачи! Эта лаба даёт фундаментальное понимание работы системных вызовов — базу для дальнейшего изучения Linux.**