# Лабораторная 4 — Системные вызовы: граница между программой и ядром
**Студент:** Кухаревич Александр, 4 курс, 1 группа

## Цели
- Понять, что такое системный вызов и как он работает изнутри.
- Увидеть **все** системные вызовы, которые делает программа (даже те, что скрыты библиотеками).
- Измерить **накладные расходы** (overhead) — сколько времени тратится на переход в ядро и обратно.
- Научиться **перехватывать** вызовы без изменения кода программы через `LD_PRELOAD`.
- Понять разницу между работой в userspace и kernel space.

## Выбор программ
Номер в списке группы: 10
Расчёт группы программ: 10 % 4 = 2
Программы для анализа: `curl`, `wget` (сетевые)
Мои задания: A (LD_PRELOAD), B (Benchmark) — обязательные.

## Среда выполнения
- **ОС:** Ubuntu 24.04.3 LTS
- **Ядро:** 6.14.0-35-generic
- **Процессор:** 12th Gen Intel(R) Core(TM) i7-12700H
- **Компилятор:** g++ (Ubuntu 11.4.0-1ubuntu1~24.04) 11.4.0

---

## Задание A: LD_PRELOAD перехват
**(Обязательно для всех)**

### Реализация
Для данного варианта была создана библиотека `libsyscall_spy.so`, нацеленная на перехват системных вызовов, связанных с **управлением процессами**. Она перехватывает ключевые функции, такие как `fork`, `vfork`, `clone`, `execve`, `waitpid`, `wait`, `exit` и `_exit`.

Особенности реализации:
*   **Сбор статистики:** Библиотека подсчитывает количество вызовов каждой перехваченной функции.
*   **Итоговый отчет:** При завершении работы целевого процесса (`__attribute__((destructor))`) библиотека автоматически выводит в `stderr` сводную статистику по всем перехваченным вызовам.
*   **Безопасное логирование:** Для вывода логов используется прямой вызов оригинальной функции `write` через `dlsym(RTLD_NEXT, ...)` для предотвращения бесконечной рекурсии.

### Эксперимент: `bash -c "for i in {1..5}; do sleep 0.1; done"`
**Команда:**
```
bash
./run_spy.sh bash -c "for i in {1..5}; do sleep 0.1; done"
```
Эта команда запускает `bash`, который в цикле 5 раз создает дочерний процесс для выполнения команды `sleep`.

**Логи перехвата (`spy.log`):**
```
[SPY] fork() called (pid=371175)
[SPY] fork() -> 371176
[SPY] waitpid(pid=-1, options=0x0) called (pid=371175)
[SPY] fork() -> 0
[SPY] execve("/usr/bin/sleep", argv[0]="sleep") called (pid=371176)
[SPY] waitpid() -> 371176 (status=0)
... (повторяется 5 раз) ...
[SPY] exit(status=0) called (pid=371175)

[SPY] Syscall spy summary (pid=371175)
[SPY]   exit            : 1
[SPY]   waitpid         : 10
[SPY]   fork            : 5
[SPY] End of summary
```

**Анализ:**
*   **Жизненный цикл процесса:** Логи четко демонстрируют классическую последовательность `fork` -> `execve` -> `waitpid`. Родительский процесс `bash` (pid=371175) создает дочерний процесс (`fork() -> 371176`). Дочерний процесс (`fork() -> 0`) заменяет свой образ процессом `/usr/bin/sleep` (`execve`). Родитель в это время ожидает завершения дочернего процесса (`waitpid`).
*   **Соответствие итерациям:** Эта последовательность повторяется ровно 5 раз, что соответствует итерациям цикла. Итоговая статистика это подтверждает: 5 вызовов `fork`.
*   **Количество `waitpid`:** Интересно, что было зафиксировано 10 вызовов `waitpid`. Это говорит о том, что оболочка `bash` использует более сложную логику ожидания дочерних процессов, чем простой единичный вызов, возможно, проверяя статус несколько раз.

---

## Задание B: Benchmark системных вызовов
**(Обязательно для всех)**

### Методика измерения
Бенчмарк измеряет производительность операций, связанных с созданием процессов и потоков. Каждая операция повторяется 20 000 раз:
1.  **`dummy`**: Вызов пустой функции в userspace (базовый уровень).
2.  **`getpid`**: Простейший системный вызов, почти не выполняющий работы в ядре.
3.  **`pthread_create`**: Создание и завершение нового потока в рамках того же процесса.
4.  **`fork+wait`**: Создание нового процесса, который немедленно завершается.
5.  **`fork+execve`**: Создание нового процесса и загрузка в него новой программы (`/bin/true`).

Измерения проводились дважды: с обычной работой и с подключенной через `LD_PRELOAD` библиотекой-шпионом для оценки ее влияния на производительность (observer effect).

### Результаты
**Сводная таблица результатов (среднее время на операцию, нс):**

| Операция | Без перехвата (ns) | С перехватом (ns) | Замедление (Overhead) |
| :--- | :---: | :---: | :---: |
| `dummy` (userspace) | 1.03 | 0.89 | -14% |
| `getpid` | 207.30 | 158.46 | -24% |
| `pthread_create` | 17,183.20 | 15,744.20 | -8% |
| **`fork+wait`** | **112,746.00** | **214,465.00** | **+90.2%** |
| **`fork+execve`** | **484,061.00** | **654,729.00** | **+35.3%** |

### Анализ и выводы

1.  **Иерархия стоимости операций:**
    *   **`getpid` (~207 нс):** Показывает базовую стоимость переключения контекста user-kernel-user.
    *   **`pthread_create` (~17 мкс):** Создание потока примерно в 80 раз дороже, чем `getpid`. Это связано с тем, что ядро (через syscall `clone`) должно выделить структуры данных для нового потока и настроить стек, хотя и в рамках общего адресного пространства.
    *   **`fork+wait` (~113 мкс):** Создание процесса в ~6.5 раз дороже создания потока. Основная причина — необходимость дублировать адресное пространство родителя (даже с механизмом Copy-on-Write, копирование таблиц страниц памяти является дорогой операцией).
    *   **`fork+execve` (~484 мкс):** Самая дорогая операция, в ~4.3 раза медленнее `fork+wait`. Системный вызов `execve` инициирует огромную работу: ядро и динамический линкер должны найти исполняемый файл, загрузить его сегменты в память, найти и загрузить все зависимые библиотеки, провести релокации — это на порядки сложнее, чем просто создать копию процесса.

2.  **Эффект наблюдателя (Overhead):**
    *   Для быстрых операций (`getpid`, `pthread_create`) влияние `LD_PRELOAD` находится в пределах погрешности измерений (результаты даже получились немного быстрее, что указывает на "шум").
    *   Однако для операций `fork` и `waitpid`, которые перехватываются нашей библиотекой, замедление **огромно**: **+90%** для `fork+wait` и **+35%** для `fork+execve`. Это происходит потому, что на каждую итерацию наша библиотека выполняет дополнительные действия: захватывает мьютекс, обновляет счетчики в `std::unordered_map` и выполняет системный вызов `write` для логирования. Это наглядно демонстрирует, как инструменты трассировки могут существенно влиять на производительность измеряемой системы.

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?
Системный вызов — это запрос программы к ядру ОС на выполнение привилегированной операции. Он отличается от обычной функции тем, что вызывает переключение процессора из режима пользователя (user mode) в защищенный режим ядра (kernel mode).

### 2. Почему системный вызов медленнее обычной функции?
Он медленнее из-за накладных расходов на **переключение контекста**, которое включает сохранение состояния CPU, смену таблиц памяти и проверки прав доступа. Бенчмарк показывает, что даже быстрый `getpid` на два порядка медленнее вызова пустой функции.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?
`LD_PRELOAD` — это переменная окружения, заставляющая динамический линкер загрузить указанную библиотеку первой, что позволяет "подменить" функции. Этот механизм **не работает** для статически скомпилированных программ (у них нет динамической линковки) и часто игнорируется для `setuid` программ из соображений безопасности.

### 4. Что такое vDSO и зачем он нужен?
vDSO (virtual Dynamic Shared Object) — это механизм, при котором ядро отображает в память процесса страницу с реализацией некоторых простых системных вызовов (например, `gettimeofday`). Это позволяет выполнять их без дорогостоящего переключения в режим ядра, значительно ускоряя частые операции.

### 5. Почему `fork()` медленнее `getpid()` на несколько порядков?
`getpid()` — это тривиальный вызов, требующий от ядра лишь прочитать значение из структуры процесса в памяти. `fork()` — это одна из самых "тяжелых" операций в Linux. Ядро должно выделить память под новый процесс, скопировать практически всю структуру родительского процесса, включая таблицы страниц памяти, файловые дескрипторы и обработчики сигналов. Бенчмарк показал, что `fork` (~113 000 нс) примерно в 545 раз медленнее, чем `getpid` (~207 нс).

## Использование AI-инструментов
1. **Разбор теории** AI был использован для разбора теории для лабораторной работы - ознакомление с необходимой теоретической базой, объяснения команд и выдача ссылок на ознакомление с моделями, а также для предоставления базы для ответа на теоретические вопросы
2. **Генерация скелетов** AI был использован для первоначальной генерации каркасов для программ benchmark и syscall_spy, а также каркаса отчёта на основе условий лабороторной работы, что ускорило как начальный этап разработки, так и конечный этап - формирование отчёта по полученной программе.
3. **Помощь** AI был использован для разбора ошибок при написании, а также как помощник при заходе в тупик.
