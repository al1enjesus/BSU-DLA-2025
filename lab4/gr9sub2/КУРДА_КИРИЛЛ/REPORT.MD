# Лабораторная работа 4 — Системные вызовы

**Студент:** Курда Кирилл  
**Номер в списке:** 10

## Среда выполнения

| Параметр | Значение |
|----------|----------|
| ОС | Ubuntu on WSL2 |
| Ядро | Linux DESKTOP-VGP8IQ4 5.15.167.4-microsoft-standard-WSL2 |
| Процессор | AMD Ryzen 7 6800H with Radeon Graphics |
| GCC | gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0 |
| Архитектура | x86_64 |

## Задание A. Перехват системных вызовов с LD_PRELOAD

### Сборка и запуск

```bash
cd src
make
cd ..
./run.sh
```

В результате сборки и запуска были получены:

- библиотека `libsyscall_spy.so` — реализует перехват open/read/write/close;
- бинарь `benchmark` — используется для замеров производительности;
- логи в каталоге `logs/`.

### Пример вывода (первые строки логов)

**curl** (`logs/curl_ldpreload.log`):
```
[SPY] open("/proc/sys/crypto/fips_enabled", flags=0x0, mode=00) = -1 (No such file or directory)
[SPY] open("/home/kirill_kurda/.curlrc", flags=0x0, mode=00) = -1 (No such file or directory)
[SPY] open("/home/kirill_kurda/.config/curlrc", flags=0x0, mode=00) = -1 (No such file or directory)
[SPY] write(fd=6, buf=0x..., count=1) = 1
[SPY] close(fd=6) = 0 (OK)
```

**wget** (`logs/wget_ldpreload.log`):
```
[SPY] open("/proc/sys/crypto/fips_enabled", flags=0x0, mode=00) = -1 (No such file or directory)
[SPY] read(fd=4, buf=0x..., count=2367) = 2367
[SPY] write(fd=4, buf=0x..., count=148) = 148
[SPY] read(fd=4, buf=0x..., count=513) = 513
200 OK
```

### Счётчики вызовов системных функций

| Программа | open | openat | read | write | close |
|-----------|------|--------|------|-------|-------|
| curl      | 4    | 0      | 0    | 1     | 6     |
| wget      | 1    | 0      | 20   | 3     | 0     |

### Наиболее часто открываемые пути

**curl:**
- 2 — `/home/kirill_kurda/.curlrc`
- 1 — `/proc/sys/crypto/fips_enabled`
- 1 — `/home/kirill_kurda/.config/curlrc`

**wget:**
- 1 — `/proc/sys/crypto/fips_enabled`

### Анализ результатов

Файл `/proc/sys/crypto/fips_enabled` проверяется многими библиотеками OpenSSL/GnuTLS для определения режима FIPS (повышенной криптостойкости). Отсутствие файла — норма для большинства систем.

curl пытается читать пользовательские конфиги (`~/.curlrc`, `~/.config/curlrc`) для загрузки параметров запуска.

wget обращается только к FIPS-файлу и затем активно использует read/write для сетевых сокетов.

`close(fd)` чаще встречается у curl, что указывает на более частое открытие временных или служебных файлов.

LD_PRELOAD сработал корректно: системные вызовы были перехвачены и записаны в логи.

### Проверка статической линковки

**Команда:**
```bash
gcc -static -o src/hello_static src/hello.c
LD_PRELOAD="./src/libsyscall_spy.so" ./src/hello_static 2> logs/hello_static.log || true
```

**Результат:**
Файл `logs/hello_static.log` пуст — LD_PRELOAD не сработал, т.к. статически слинкованные программы не используют динамический загрузчик (ld.so) и не подгружают внешние библиотеки. Это подтверждает, что LD_PRELOAD влияет только на динамически связанный код.

## Задание B. Benchmark

### Описание

Бенчмарк выполняет замеры количества процессорных циклов для четырёх операций:

- `dummy()` — пустая функция (базовая задержка в user space);
- `getpid()` — системный вызов (через ядро);
- `open() + close()` — пара системных вызовов (работа с файловой подсистемой);
- `gettimeofday()` — измерение времени (через vDSO, т.е. без перехода в ядро).

### Результаты (усреднены по трём прогонам)

| Операция | Среднее (циклы) | Время (нс при 3.0 ГГц) | Относительно dummy |
|----------|-----------------|------------------------|-------------------|
| dummy() | 73.09 | 24.36 ns | 1.00× |
| getpid() | 722.99 | 241.00 ns | 9.89× |
| open() + close() | 9369.88 | 3123.29 ns | 128.20× |
| gettimeofday() vDSO | 173.78 | 57.93 ns | 2.38× |

### Анализ результатов

`dummy()` — минимальная стоимость вызова в user space (~24 нс).

`getpid()` требует перехода в режим ядра, из-за чего ~10× медленнее.

`open+close()` — наиболее тяжёлая операция (~3 мкс) из-за работы файловой системы, проверки прав, буферов и т.д.

`gettimeofday()` использует vDSO — специальную область памяти, позволяющую читать системное время без системного вызова, поэтому она почти в 5 раз быстрее, чем обычный syscall.

При отсутствии perf в WSL (perf: command not found) аппаратные счётчики не были собраны — это допустимо.

## Заключение

В ходе лабораторной работы были выполнены:

- Реализация библиотеки libsyscall_spy.so, перехватывающей системные вызовы open, read, write, close с помощью LD_PRELOAD.
- Анализ поведения программ curl и wget на уровне системных вызовов.
- Проведено сравнение производительности различных операций (dummy, getpid, open/close, gettimeofday).
- Проверено, что LD_PRELOAD не действует на статически слинкованные бинарные файлы.

Полученные результаты подтвердили:

- Системные вызовы существенно дороже обычных функций пользовательского уровня.
- LD_PRELOAD позволяет эффективно анализировать активность программ без изменения исходного кода.
- В Linux динамическая загрузка является гибким инструментом для отладки и исследования поведения систем.

---

## Ответы на вопросы отчёта

### 1. Что такое системный вызов и чем он отличается от обычной функции?

**Системный вызов** — это специальный механизм, позволяющий программе в пользовательском режиме (user space) перейти в режим ядра (kernel space) для выполнения привилегированных операций.

**Основные отличия от обычной функции:**

- **Уровень выполнения**: обычная функция работает в user space и не требует переключения контекста, системный вызов требует перехода в режим ядра.
- **Привилегии**: системные вызовы могут выполнять операции, запрещённые в user space (прямой доступ к аппаратуре, управление памятью, работа с файловой системой).
- **Производительность**: системные вызовы намного медленнее из-за переключения контекста процессора.
- **Интерфейс**: системные вызовы предоставляются операционной системой через специальный API (в Linux это таблица syscall).

Пример: функция `strlen()` — обычная функция (работает локально), `open()` — системный вызов (требует доступа к файловой системе).

### 2. Почему системный вызов медленнее обычной функции?

Системный вызов медленнее из-за нескольких факторов:

- **Переключение контекста процессора**: переход из режима user в режим kernel требует сохранения регистров, переключения таблицы страниц памяти и других накладных операций. По результатам бенчмарка `getpid()` медленнее `dummy()` в ~10 раз.

- **Проверка безопасности**: ядро должно проверить параметры вызова, права доступа процесса и валидность аргументов.

- **Переключение контекста**: процессор должен очистить конвейер команд, переключить TLB (Translation Lookaside Buffer), что приводит к промахам в кэше.

- **Возврат в user space**: после выполнения операции в ядре необходимо вернуться обратно в пользовательский код с восстановлением всех регистров.

- **Синхронизация**: если операция блокирует процесс (например, чтение с диска), ядро может переключиться на другой процесс, добавляя дополнительные задержки.

Из таблицы результатов видно, что `open+close()` требует в 128 раз больше циклов, чем `dummy()`, так как работа с файловой системой — это комплексная операция с множеством проверок и буферизацией.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

**Как работает LD_PRELOAD:**

LD_PRELOAD — это переменная окружения, которая указывает динамическому загрузчику (ld.so) загрузить указанную библиотеку раньше других. Это позволяет переопределить функции из стандартных библиотек.

**Механизм:**

1. При запуске программы динамический загрузчик читает переменную LD_PRELOAD.
2. Загрузчик загружает библиотеку, указанную в LD_PRELOAD.
3. Символы (функции) из этой библиотеки получают приоритет при разрешении имён.
4. Когда программа вызывает функцию (например, `open()`), используется переопределённая версия из библиотеки LD_PRELOAD, а не оригинальная функция.

В работе использовался LD_PRELOAD для перехвата `open`, `read`, `write`, `close`:
```bash
LD_PRELOAD="./src/libsyscall_spy.so" curl https://example.com
```

**Когда LD_PRELOAD НЕ работает:**

- **Статическая линковка**: если программа скомпилирована с флагом `-static`, она содержит все необходимые функции внутри и не использует динамический загрузчик. LD_PRELOAD не может повлиять на статически слинкованный код, как подтвердила проверка с `hello_static`.

- **Встроенные функции**: если функция встроена в основной бинарник (inlining) или скомпилирована как встроенная (inline), LD_PRELOAD не сработает.

- **Прямые системные вызовы**: если программа использует `syscall()` напрямую, минуя glibc, LD_PRELOAD не перехватит вызов.

- **Защита ASLR и SELinux**: на некоторых системах с жёсткой защитой LD_PRELOAD может быть запрещена для определённых приложений.

- **Setuid/Setgid программы**: для безопасности LD_PRELOAD игнорируется для программ с установленными битами setuid или setgid.

### 4. Что такое vDSO и зачем он нужен?

**vDSO** (virtual Dynamic Shared Object) — это специальная область памяти ядра, отображаемая в адресное пространство каждого процесса, которая содержит некоторые системные функции.

**Назначение:**

vDSO позволяет выполнять определённые операции без полного перехода в режим ядра (без переключения контекста), что существенно ускоряет их выполнение.

**Как это работает:**

- Ядро отображает vDSO в адресное пространство процесса в user space.
- Процесс может вызвать функции из vDSO напрямую, как обычные функции, без системного вызова.
- Функции в vDSO читают данные из общей памяти, которую ядро регулярно обновляет.

**Примеры функций в vDSO:**

- `gettimeofday()` — чтение системного времени
- `clock_gettime()` — получение времени с высокой точностью
- `getcpu()` — получение номера текущего процессора

**По результатам бенчмарка:**

`gettimeofday()` через vDSO выполняется за 173.78 циклов (~57.93 нс), что лишь в 2.38× медленнее, чем пустая функция `dummy()`. Это намного быстрее, чем обычный системный вызов `getpid()`, который требует 722.99 циклов.

**Преимущества:**

- Избегаются накладные расходы на переключение контекста.
- Улучшается производительность частоиспользуемых операций.
- Прозрачно для приложений — код работает так же, но быстрее.

### 5. Почему open() медленнее getpid() на несколько порядков?

По результатам бенчмарка `open() + close()` требует 9369.88 циклов, в то время как `getpid()` требует только 722.99 циклов. Это в ~13 раз медленнее.

**Причины:**

- **Сложность операции**: `getpid()` — это простая операция, которая ядру нужно только вернуть ID процесса из структуры task_struct. `open()` же требует выполнить множество проверок и операций.

- **Работа с файловой системой**: `open()` должна:
  - Проверить права доступа (владельца, группу, права доступа)
  - Разобрать путь файла (разделить на компоненты)
  - Пройти по цепочке директорий (path traversal)
  - Найти инод файла в файловой системе
  - Выделить дескриптор файла
  - Инициализировать структуру file descriptor
  
  Каждый из этих шагов может требовать обращений к кэшу ядра, буферам и таблицам.

- **Взаимодействие с оборудованием**: если файл находится на диске, ядро может выполнить операции чтения/записи, обратиться к кэшу диска.

- **Синхронизация**: файловая система должна обеспечить консистентность данных, что может требовать блокировок и синхронизации.

- **Буферизация и кэширование**: ядро работает с буферными кэшами, TLB, page cache.

- **Два системных вызова**: в бенчмарке измеряется `open() + close()`, то есть два переключения контекста вместо одного.

Фактически, из таблицы видно, что `open() + close()` медленнее в 128 раз, чем `dummy()`, что свидетельствует об экстремальной сложности работы с файловой системой по сравнению с простым чтением переменной ядра.