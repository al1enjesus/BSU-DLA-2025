# Лабораторная работа 4 - Системные вызовы: граница между программой и ядром
## Задание А: LD_PRELOAD перехват системных вызовов

**Программы:** 3 - gcc, make, as


## 1. Реализация библиотеки перехвата

### 1.1. Перехватываемые системные вызовы

Библиотека `libsyscall_spy.so` перехватывает следующие системные вызовы:
- `open()`, `openat()` - открытие файлов
- `read()` - чтение данных 
- `write()` - запись данных (с защитой от рекурсии для stderr)
- `close()` - закрытие файловых дескрипторов

### 1.2. Ключевые особенности реализации

```c
// Использование dlsym для доступа к оригинальным функциям
static int (*original_open)(const char*, int, ...) = NULL;
if (!original_open) {
    original_open = dlsym(RTLD_NEXT, "open");
}

// Обработка variadic arguments в open()/openat()
mode_t mode = 0;
if (flags & O_CREAT) {
    va_list args;
    va_start(args, flags);
    mode = va_arg(args, mode_t);
    va_end(args);
}

// Защита от рекурсии при записи в stderr
if (fd != 2) { // 2 = stderr
    fprintf(stderr, "[SPY] write(...)");
}

```

### 1.3. Компиляция библиотеки

```bash
gcc -shared -fPIC -o libsyscall_spy.so syscall_spy.c -ldl
```

Проверка:

```bash
file libsyscall_spy.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked
ldd libsyscall_spy.so: зависит от libdl.so.2, libc.so.6
```

## 2. Результаты экспериментов
###2.1. Статистика системных вызовов по программам

Программа	Всего вызовов	open	openat	read	write	close
gcc_version	0	0	0	0	0	0
gcc_compile	19	5	0	4	0	9
make_version	0	0	0	0	0	0
make_build	164	21	0	75	0	36
as_version	0	0	0	0	0	0
as_assemble	0	0	0	0	0	0

### 2.2. Детальный анализ программ

gcc_compile (компиляция simple.c)

    Всего вызовов: 19

    Открытые файлы:

        simple.c - исходный файл

        /usr/include/stdc-predef.h - стандартные предикаты

        /usr/include/x86_64-linux-gnu/stdc-predef.h - архитектурно-специфичные предикаты

        /usr/lib/gcc/x86_64-linux-gnu/9/include/stdc-predef.h - предикаты компилятора

        /usr/local/include/stdc-predef.h - локальные предикаты

Наблюдения: GCC последовательно ищет файл stdc-predef.h в разных директориях, начиная с самых специфичных.
make_build (сборка проекта)

    Всего вызовов: 164

    Основные активности:

        Множественные операции read() (75 вызовов) - чтение объектных файлов и библиотек

        21 вызов open() для открытия файлов зависимостей

        36 вызовов close() - интенсивная работа с файловыми дескрипторами

Открываемые файлы включают:

    Библиотеки: libgcc_s.so.1, libc.so.6, ld-linux-x86-64.so.2

    Объектные файлы: Scrt1.o, crti.o, crtn.o, crtbeginS.o, crtendS.o

    Временные файлы: /tmp/cctcEsBA.ld, /tmp/ccrYs3iC.le

### 2.3. Программы без перехвата

Программы gcc_version, make_version, as_version, as_assemble не показали перехваченных вызовов. Это связано с тем, что:

    Версионные команды (--version) могут использовать другие механизмы вывода

    Ассемблер (as) при работе с stdin может использовать другие системные вызовы

    Некоторые программы могут использовать openat() вместо open()

## 3. Анализ и выводы
### 3.1. Сравнительный анализ программ

gcc_compile vs make_build:

    make_build делает в 8.6 раз больше системных вызовов чем gcc_compile (164 vs 19)

    make_build имеет значительно больше операций чтения (75 vs 4) из-за обработки зависимостей

    Обе программы интенсивно используют файловые операции, но make работает с более сложной структурой проекта

### 3.2. Природа работы программ

gcc (компилятор C):

    Фокусируется на последовательной обработке исходного кода

    Ищет заголовочные файлы в установленной иерархии

    Относительно небольшое количество файловых операций

make (система сборки):

    Управляет сложными зависимостями между файлами

    Работает с множеством объектных файлов и библиотек одновременно

    Интенсивное использование временных файлов

    Высокая нагрузка на файловую систему

### 3.3. Неожиданные наблюдения

    Отсутствие openat() - все программы использовали только open(), хотя современные приложения часто используют openat() для безопасности

    Интенсивное использование временных файлов - make создает несколько временных файлов в /tmp для линковки

    Поиск предикатов - GCC ищет stdc-predef.h в 4 разных местах, демонстрируя иерархию поиска заголовочных файлов

### 3.4. Новые знания о работе программ

    Процесс компиляции включает не только обработку исходного кода, но и поиск системных библиотек и заголовков

    Сборка проекта требует координации множества файловых операций, что объясняет высокую нагрузку на IO

    Динамическая линковка добавляет значительное количество операций с файлами для разрешения зависимостей

## 4. Тест со статической компиляцией
### 4.1. Результат эксперимента

Запуск статической программы с LD_PRELOAD:
Hello from test program!
Starting test program...
Test program finished.
Результат: перехват НЕ сработал

### 4.2. Объяснение почему LD_PRELOAD не работает

LD_PRELOAD не работает со статически скомпилированными программами по следующим причинам:

    Отсутствие динамического линкера

        Статические программы не используют /lib64/ld-linux-x86-64.so.2

        Все библиотеки включены непосредственно в исполняемый файл

    Разрешение символов на этапе компиляции

        В статических программах все символы (функции) разрешаются во время компиляции

        Нет механизма позднего связывания (late binding)

    Встраивание библиотечного кода

        Функции из libc (open, read, write) копируются в исполняемый файл

        Программа вызывает свои собственные копии функций, а не системные

    LD_PRELOAD механизм

        Работает через перехват вызовов динамического линкера

        Требует наличия разделяемых библиотек (.so)

        Неприменим к самодостаточным статическим бинарникам

Технические детали:

    Динамический линкер обрабатывает переменную окружения LD_PRELOAD

    При статической компиляции линкер отсутствует в процессе выполнения

    Вызовы функций напрямую обращаются к встроенному коду, минуя механизм перехвата
    
    
## Задание B: Benchmark системных вызовов

### 1. Код benchmark.c

```bash
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <time.h>

int dummy() { return 42; }

long long get_time_ns() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000LL + ts.tv_nsec;
}

int main() {
    int iterations = 1000000;
    
    // Измеряем dummy()
    long long start = get_time_ns();
    for (int i = 0; i < iterations; i++) dummy();
    long long end = get_time_ns();
    long long dummy_time = (end - start) / iterations;
    
    // Измеряем getpid()
    start = get_time_ns();
    for (int i = 0; i < iterations; i++) getpid();
    end = get_time_ns();
    long long getpid_time = (end - start) / iterations;
    
    // Измеряем gettimeofday()
    struct timeval tv;
    start = get_time_ns();
    for (int i = 0; i < iterations; i++) gettimeofday(&tv, NULL);
    end = get_time_ns();
    long long gettime_time = (end - start) / iterations;
    
    printf("dummy(): %lld ns\n", dummy_time);
    printf("getpid(): %lld ns (%.1fx)\n", getpid_time, (double)getpid_time/dummy_time);
    printf("gettimeofday(): %lld ns (%.1fx)\n", gettime_time, (double)gettime_time/dummy_time);
    
    return 0;
}

```

### 2. Результаты измерений

=== Benchmark системных вызовов ===
Итераций: 1000000

Результаты (среднее время):
dummy():         5 ns (1x)
getpid():        63 ns (12.6x)
gettimeofday():  13 ns (2.6x)

### 3. Результаты perf stat

 Performance counter stats for './benchmark':

       316.485.864      cycles
       336.027.814      instructions              #    1,06  insn per cycle 
                 5      context-switches                                            
                57      page-faults                                                 

       0,082827034 seconds time elapsed
       0,041427000 seconds user
       0,041427000 seconds sys

### 4. Анализ результатов

Сравнительная таблица:
Операция	Время	Во сколько раз медленнее
dummy()	5 нс	1x
getpid()	63 нс	12.6x
gettimeofday()	13 нс	2.6x

Анализ perf stat:

    Cycles: 316,485,864 - общее количество тактов процессора

    Instructions: 336,027,814 - выполнено инструкций

    IPC: 1.06 - высокий показатель, хорошая эффективность конвейера

    Context-switches: 5 - минимальное количество переключений контекста

    Page-faults: 57 - небольшое количество страничных нарушений

Детальный анализ:

1. Почему getpid() в 12.6 раза медленнее dummy():

    dummy(): Выполняется полностью в userspace (5 нс)

    getpid(): Требует перехода в kernel space (63 нс):

        Сохранение регистров CPU

        Проверка прав доступа

        Поиск в syscall table

        Чтение PID из структуры task_struct

        Возврат в userspace

2. Почему gettimeofday() быстрее getpid():

    Использует vDSO (Virtual Dynamic Shared Object)

    Выполняется в userspace без перехода в ядро

    Ядро размещает данные времени в области памяти, доступной из userspace

    Время выполнения всего 13 нс (всего в 2.6 раза медленнее userspace функции)

3. Анализ производительности:

    IPC = 1.06 - хороший показатель, программа эффективно использует конвейер процессора

    Минимальные context-switches - программа работает практически без переключений

    Мало page-faults - эффективное использование памяти
