# Лабораторная 4 — Системные вызовы

## Выбор программ

Номер в списке группы: 12
Расчёт группы программ: 12 % 4 = 0
Программы для анализа: ls, cat, grep
Мои задания: A (LD_PRELOAD)

## Среда выполнения

- ОС: Ubuntu 24.04 (running on WSL2)
- Ядро: 6.14.0-33-generic
- Процессор: AMD Ryzen 5 5600H with Radeon Graphics
- Компилятор: gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки

Для перехвата вызовов была реализована библиотека `libsyscall_spy.so` в файле [syscall_spy.c](./src/syscall_spy.c). Она использует механизм `LD_PRELOAD` для "подмены" стандартных библиотечных функций `open`, `openat`, `read`, `write` и `close` своими версиями.

Каждая перехваченная функция выполняет следующие действия:

1.  Получает указатель на оригинальную функцию с помощью `dlsym(RTLD_NEXT, "имя_функции")`.
2.  Вызывает оригинальную функцию, сохраняя её результат.
3.  Логирует имя функции, её аргументы и результат в `stderr`.
4.  Возвращает результат оригинальной функции.

Для защиты от бесконечной рекурсии (когда `fprintf` в нашей функции вызывает `write`, который мы перехватываем), запись в `stderr` (файловый дескриптор 2) не логируется.

### Эксперимент 1: Программа `ls`

**Команда:**

```bash
make run_ls
```

**Полный вывод и Анализ:**

Изначально программа выводила файлы в директории, а перехватчик ничего не логировал. Это связано с тем, что `ls` напрямую совершает многие системные вызовы, минуя стандартные библиотечные функции, которые мы перехватываем. Для подтверждения этого была написана функция для перехвата `dup`. После её добавления в библиотеку, `ls` начал логировать вызовы `dup`, что подтвердило гипотезу:

```
[SPY] dup(2)
total 44
drwxrwxr-x 6 denis denis 4096 Oct 13 09:24 .
drwxrwxr-x 3 denis denis 4096 Oct 13 08:35 ..
drwxrwxr-x 2 denis denis 4096 Oct 13 09:31 bin
drwxrwxr-x 2 denis denis 4096 Oct 13 09:31 lib
drwxrwxr-x 2 denis denis 4096 Oct 13 09:25 logs
-rw-rw-r-- 1 denis denis  734 Oct 13 08:58 Makefile
-rw-rw-r-- 1 denis denis  947 Oct 13 07:59 README.md
-rw-rw-r-- 1 denis denis 8901 Oct 13 09:30 REPORT.md
drwxrwxr-x 2 denis denis 4096 Oct 13 09:12 src
```

### Эксперимент 2: Программа `cat`

**Команда:**

```bash
make run_cat
```

**Полный вывод:**

```
[SPY] open("/etc/passwd", flags=0x0) = 3
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
_apt:x:42:65534::/nonexistent:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:998:998:systemd Network Management:/:/usr/sbin/nologin
systemd-timesync:x:996:996:systemd Time Synchronization:/:/usr/sbin/nologin
dhcpcd:x:100:65534:DHCP Client Daemon,,,:/usr/lib/dhcpcd:/bin/false
messagebus:x:101:101::/nonexistent:/usr/sbin/nologin
syslog:x:102:102::/nonexistent:/usr/sbin/nologin
systemd-resolve:x:991:991:systemd Resolver:/:/usr/sbin/nologin
uuidd:x:103:103::/run/uuidd:/usr/sbin/nologin
usbmux:x:104:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
tss:x:105:105:TPM software stack,,,:/var/lib/tpm:/bin/false
systemd-oom:x:990:990:systemd Userspace OOM Killer:/:/usr/sbin/nologin
kernoops:x:106:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin
whoopsie:x:107:109::/nonexistent:/bin/false
dnsmasq:x:999:65534:dnsmasq:/var/lib/misc:/usr/sbin/nologin
avahi:x:108:111:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
tcpdump:x:109:112::/nonexistent:/usr/sbin/nologin
sssd:x:110:113:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin
speech-dispatcher:x:111:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false
cups-pk-helper:x:112:114:user for cups-pk-helper service,,,:/nonexistent:/usr/sbin/nologin
fwupd-refresh:x:989:989:Firmware update daemon:/var/lib/fwupd:/usr/sbin/nologin
saned:x:113:116::/var/lib/saned:/usr/sbin/nologin
geoclue:x:114:117::/var/lib/geoclue:/usr/sbin/nologin
cups-browsed:x:115:114::/nonexistent:/usr/sbin/nologin
hplip:x:116:7:HPLIP system user,,,:/run/hplip:/bin/false
gnome-remote-desktop:x:988:988:GNOME Remote Desktop:/var/lib/gnome-remote-desktop:/usr/sbin/nologin
polkitd:x:987:987:User for polkitd:/:/usr/sbin/nologin
rtkit:x:117:119:RealtimeKit,,,:/proc:/usr/sbin/nologin
colord:x:118:120:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
gnome-initial-setup:x:119:65534::/run/gnome-initial-setup/:/bin/false
gdm:x:120:121:Gnome Display Manager:/var/lib/gdm3:/bin/false
nm-openvpn:x:121:122:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
denis:x:1000:1000:Denis:/home/denis:/bin/bash
_rpc:x:122:65534::/run/rpcbind:/usr/sbin/nologin
statd:x:123:65534::/var/lib/nfs:/usr/sbin/nologin
[SPY] close(fd=3) = 0
```

**Анализ:**

- `cat` выполняет ровно два ожидаемых вызова: `open` для открытия файла и `close` для его закрытия. Само чтение и запись на `stdout` происходят внутри, вероятно, с использованием буферизации, поэтому отдельные вызовы `read`/`write` не перехватываются.

### Эксперимент 3: Программа `grep`

**Команда:**

```bash
make run_grep
```

**Полный вывод:**

```
[SPY] open("/proc/self/maps", flags=0x0) = 3
[SPY] read(fd=3, buf=0x70082a94e000, count=8192) = 3954
[SPY] read(fd=3, buf=0x70082a94ef72, count=4238) = 1383
[SPY] read(fd=3, buf=0x70082a94c000, count=16384) = 3954
[SPY] read(fd=3, buf=0x70082a94cf72, count=12430) = 1383
[SPY] read(fd=3, buf=0x70082a94d4d9, count=11047) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/passwd", 0x100) = 3
[SPY] read(fd=3, buf=0x55c31661f000, count=98304) = 2960
[SPY] read(fd=3, buf=0x55c31661fb90, count=94208) = 0
[SPY] close(fd=3) = 0
root:x:0:0:root:/root:/bin/bash
nm-openvpn:x:121:122:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
```

**Анализ:**

- `grep` сначала открывает `/proc/self/maps` для анализа собственного адресного пространства, а затем уже открывает и читает целевой файл `/etc/passwd`.

### Сравнительный анализ и рассуждения

#### Сравнительная таблица

| Программа | Вызовов open/openat | Вызовов read   | Вызовов write  | Вызовов close  |
| --------- | ------------------- | -------------- | -------------- | -------------- |
| ls        | 0 (не удалось)      | 0 (не удалось) | 0 (не удалось) | 0 (не удалось) |
| cat       | 1                   | 0              | 0              | 1              |
| grep      | 2                   | 4              | 0              | 2              |

#### Какая программа делает больше всего системных вызовов и почему?

Согласно собранным данным, `grep` делает больше всего перехваченных системных вызовов (8 в сумме: 2 `openat`, 4 `read`, 2 `close`). `cat` делает всего 2 вызова (`open` и `close`), а для `ls` не удалось зафиксировать большинство вызовов.

Причина в том, что `grep` выполняет более сложную работу, чем `cat`. Ему нужно не просто скопировать данные из одного места в другое, а проанализировать их. Для этого он читает файл (`/etc/passwd`) по частям в буфер, что отражается в нескольких вызовах `read`. Кроме того, `grep` проявляет "любопытство" и анализирует собственное адресное пространство через `/proc/self/maps`, что добавляет ещё одну пару вызовов `open`/`close` и несколько `read`.

#### Природа работы программ

Все три утилиты (`ls`, `cat`, `grep`) являются **файловыми**. Их основная задача — работа с файловой системой и данными в файлах.

- **`ls`**: Читает метаданные директорий и выводит список файлов. Её работа заключается в syscall-ах типа `getdents64` (который мы не перехватывали), позволяющих получить содержимое директории. Она не столько читает _содержимое_ файлов, сколько информацию _о_ них.
- **`cat`**: Последовательно читает содержимое одного или нескольких файлов и выводит его в `stdout`. Это классическая операция потокового файлового I/O.
- **`grep`**: Читает файл для поиска в нём определённого шаблона. Это также файловый I/O, но сопряжённый с вычислениями (поиском по строкам).

#### Неожиданные открываемые файлы

В ходе анализа были замечены обращения к файлам, не указанным в командной строке напрямую. Это иллюстрирует, как программы взаимодействуют с операционной системой.

- `grep` открывает `/proc/self/maps`. Это файл из виртуальной файловой системы `procfs`, который содержит карту памяти текущего процесса. `grep` может использовать эту информацию для оптимизации работы с памятью или для внутренних проверок. Это было самым неожиданным открытием.

#### Сравнение профилей вызовов

- **`read()` vs `write()`**: В логах `grep` много вызовов `read`, так как он активно читает файл для поиска. В то же время вызовов `write` не зафиксировано ни у одной программы. Причина в **буферизации `stdout`**. Функции вроде `printf` накапливают данные в буфере в пользовательском пространстве и делают один большой системный вызов `write`, когда буфер заполнится или программа завершится. Наша библиотека не перехватывает `write` в `stderr` (для избежания рекурсии), а `write` в `stdout` происходит позже и, возможно, всего один раз. У `cat` вызовы `read` также не были зафиксированы, что говорит о другой стратегии чтения — возможно, файл целиком отображается на память (`mmap`) или читается одним большим куском.

- **Частота `open()`**: `grep` открывает файлы чаще (`/proc/self/maps` и `/etc/passwd`), потому что его логика сложнее и включает самоанализ. `cat` делает это только один раз для целевого файла.

#### Что нового удалось узнать?

- **Неожиданности**:

  1.  Главный сюрприз — `ls` не использует стандартные `open`/`read` для чтения содержимого директории, а полагается на более специфичные системные вызовы (`getdents64`), что делает перехват через `LD_PRELOAD` неполным для этой утилиты.
  2.  "Любопытство" `grep` в виде чтения `/proc/self/maps` показывает, что даже простые утилиты могут иметь скрытую логику для оптимизации.
  3.  Отсутствие перехваченных `read` у `cat` и `write` у всех программ ярко демонстрирует эффект буферизации ввода-вывода в стандартной библиотеке C. Программы не делают по одному syscall на каждую операцию, а оптимизируют их.

- **Польза для отладки и оптимизации**:
  - Анализ системных вызовов — мощный инструмент для **профилирования производительности**. Если программа делает тысячи мелких вызовов `read`/`write`, это явный кандидат на оптимизацию через увеличение размеров буферов.
  - Это помогает в **отладке**, когда программа падает или ведёт себя некорректно. Лог вызовов может показать, на каком файле или операции она споткнулась.

### Проверка на статически слинкованной программе

**Команда:**

```bash
make run_static_test
```

**Результат:** Логи перехвата отсутствуют.

**Объяснение:** Механизм `LD_PRELOAD` не работает для статически скомпонованных программ из-за фундаментальных различий в том, как они собираются и запускаются, по сравнению с динамически линкованными программами.

1.  **Динамическая линковка и роль `ld.so`**:
    *   Когда программа компилируется с динамической линковкой (стандартный режим), её исполняемый файл не содержит код всех используемых функций (например, `printf` из `libc`). Вместо этого он содержит "заглушки" и таблицу символов, указывающих, что ему нужна функция `printf` из библиотеки `libc.so`.
    *   При запуске такой программы операционная система передаёт управление **динамическому компоновщику** (`ld.so` или `ld-linux.so`).
    *   Именно `ld.so` отвечает за поиск и загрузку в память всех необходимых `.so` библиотек, после чего он производит **разрешение символов** (symbol resolution) — находит реальные адреса запрошенных функций в памяти и "связывает" вызовы из основной программы с этими адресами.
    *   `LD_PRELOAD` — это инструкция для `ld.so`. Она говорит ему: "Перед тем, как искать символы в стандартных библиотеках, сначала поищи их в библиотеке, указанной в `LD_PRELOAD`". Таким образом, `ld.so` находит нашу функцию-перехватчик раньше, чем оригинальную, и связывает программу с ней.

2.  **Статическая линковка**:
    *   При статической линковке (флаг `-static` у `gcc`) компоновщик (`ld`) на этапе сборки находит код всех вызываемых функций в статических библиотеках (`.a` файлах) и **полностью встраивает (копирует) этот код** в конечный исполняемый файл.
    *   В результате получается единый, монолитный файл, который не имеет внешних зависимостей от `.so` библиотек. Все вызовы функций (например, `open`) превращаются в прямые переходы на адрес кода, уже находящегося внутри самого исполняемого файла.

3.  **Почему `LD_PRELOAD` бессилен**:
    *   Когда запускается статическая программа, операционной системе не нужно вызывать динамический компоновщик `ld.so`, так как разрешать символы и загружать библиотеки не нужно — всё уже встроено.
    *   Поскольку `ld.so` никогда не запускается, он не может прочитать переменную окружения `LD_PRELOAD`. Эта инструкция просто игнорируется, так как адресат (`ld.so`) отсутствует в процессе запуска.
    *   Нет этапа "разрешения символов" во время выполнения, в который можно было бы вмешаться. Все связи жёстко прописаны на этапе компиляции.

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

Системный вызов — это запрос программы к ядру операционной системы на выполнение привилегированной операции. Его ключевое отличие от обычной функции — **переход между режимами работы процессора**.

*   **Обычная функция** выполняется полностью в пространстве пользователя (`user mode`), оперируя только данными своего процесса.
*   **Системный вызов** инициирует переключение в пространство ядра (`kernel mode`), где ядро имеет полный доступ ко всем ресурсам системы (файлы, сеть, память). Этот переход необходим для безопасности и стабильности ОС.

### 2. Почему системный вызов медленнее обычной функции?

Системный вызов медленнее из-за высоких накладных расходов на **переключение контекста** (`context switch`) между режимом пользователя и режимом ядра.

Этот процесс включает в себя множество шагов, отсутствующих при вызове обычной функции:
*   Сохранение текущего состояния процессора (регистры, указатель стека).
*   Переключение на стек ядра.
*   Проверка ядром аргументов системного вызова на корректность.
*   Выполнение запрашиваемой операции ядром.
*   Восстановление состояния пользовательского процесса.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

`LD_PRELOAD` — это переменная окружения, которая даёт инструкцию динамическому компоновщику (`ld.so`) загрузить указанную в ней библиотеку **перед всеми остальными**, включая стандартную библиотеку C (`libc`). Это позволяет эффективно "подменить" оригинальные функции своими реализациями-перехватчиками.

Механизм **не работает** в следующих случаях:
*   **Статически скомпонованные программы**: В них нет этапа динамической компоновки при запуске, и `ld.so` не вызывается.
*   **Программы с флагами `setuid`/`setgid`**: В целях безопасности ядро игнорирует `LD_PRELOAD` для таких программ, чтобы предотвратить выполнение вредоносного кода с повышенными привилегиями.
*   **Прямые системные вызовы**: Если программа использует инструкцию `syscall` напрямую, а не через обёртки в `libc` (такие как `open`, `read`), перехватить вызов с помощью `LD_PRELOAD` невозможно.

### 4. Что такое vDSO и зачем он нужен?

**vDSO (Virtual Dynamic Shared Object)** — это механизм оптимизации, позволяющий выполнять некоторые системные вызовы без дорогостоящего переключения контекста в режим ядра.

Принцип работы:
*   Ядро отображает в адресное пространство каждого процесса специальную страницу памяти, которая содержит и данные (например, текущее время), и функции для их чтения.
*   Когда программа вызывает такой syscall (например, `gettimeofday()`), стандартная библиотека `libc` вместо реального системного вызова обращается к функции внутри vDSO.
*   Эта функция выполняется полностью в `user mode`, напрямую читая данные, которые ядро для неё подготовило. Это так же быстро, как вызов обычной функции.

### 5. Почему open() медленнее getpid() на несколько порядков?

Вызов `open()` медленнее `getpid()` из-за колоссальной разницы в объёме и сложности работы, которую должно выполнить ядро.

*   **`getpid()`**: Чрезвычайно быстрая операция. В большинстве случаев она реализуется через **vDSO**, то есть выполняется вообще без входа в ядро. Процесс просто читает свой ID из подготовленной ядром области памяти.
*   **`open()`**: Сложный, многоступенчатый процесс, который может включать медленные операции ввода-вывода.
    *   **Разбор пути**: Ядро должно пройти по каждому компоненту пути к файлу.
    *   **Проверка прав доступа**: На каждом шаге проверяются права пользователя.
    *   **Обращение к файловой системе**: Ядро взаимодействует с драйвером ФС.
    *   **Дисковый ввод-вывод**: Если нужные данные не в кэше, происходит обращение к физическому диску, что на порядки медленнее доступа к ОЗУ.
    *   **Выделение ресурсов**: Ядро должно выделить файловый дескриптор и другие структуры данных.

### 6. (Для задания C) Почему ptrace() так сильно замедляет программу?

Системный вызов `ptrace()` (основа `strace` и `gdb`) кардинально замедляет программу, потому что он принудительно останавливает её выполнение **дважды на каждый системный вызов**.

Этот механизм приводит к "буре" переключений контекста:
*   **Остановка на входе (Syscall-Entry Stop)**: Перед выполнением системного вызова ядро останавливает программу и передаёт управление отладчику (`tracer`).
*   **Остановка на выходе (Syscall-Exit Stop)**: После выполнения системного вызова ядро снова останавливает программу и отдаёт управление отладчику для анализа результата.
*   **Двойные переключения**: Каждый из этих двух шагов требует минимум двух переключений контекста (с программы на отладчик и обратно), что в сумме даёт огромное замедление.
