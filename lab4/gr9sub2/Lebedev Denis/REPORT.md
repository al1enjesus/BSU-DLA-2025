# Лабораторная 4 — Системные вызовы

## Выбор программ

Номер в списке группы: 12
Расчёт группы программ: 12 % 4 = 0
Программы для анализа: ls, cat, grep
Мои задания: A (LD_PRELOAD), B (Benchmark)

## Среда выполнения

- ОС: Ubuntu 24.04 (running on WSL2)
- Ядро: 6.14.0-33-generic
- Процессор: AMD Ryzen 5 5600H with Radeon Graphics
- Компилятор: gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки

Для перехвата вызовов была реализована библиотека `libsyscall_spy.so` в файле [syscall_spy.c](./src/syscall_spy.c). Она использует механизм `LD_PRELOAD` для "подмены" стандартных библиотечных функций `open`, `openat`, `read`, `write` и `close` своими версиями.

Каждая перехваченная функция выполняет следующие действия:

1.  Получает указатель на оригинальную функцию с помощью `dlsym(RTLD_NEXT, "имя_функции")`.
2.  Вызывает оригинальную функцию, сохраняя её результат.
3.  Логирует имя функции, её аргументы и результат в `stderr`.
4.  Возвращает результат оригинальной функции.

Для защиты от бесконечной рекурсии (когда `fprintf` в нашей функции вызывает `write`, который мы перехватываем), запись в `stderr` (файловый дескриптор 2) не логируется.

### Эксперимент 1: Программа `ls`

**Команда:**

```bash
make run_ls
```

**Полный вывод и Анализ:**

Изначально программа выводила файлы в директории, а перехватчик ничего не логировал. Это связано с тем, что `ls` напрямую совершает многие системные вызовы, минуя стандартные библиотечные функции, которые мы перехватываем. Для подтверждения этого была написана функция для перехвата `dup`. После её добавления в библиотеку, `ls` начал логировать вызовы `dup`, что подтвердило гипотезу:

```
[SPY] dup(2)
total 44
drwxrwxr-x 6 denis denis 4096 Oct 13 09:24 .
drwxrwxr-x 3 denis denis 4096 Oct 13 08:35 ..
drwxrwxr-x 2 denis denis 4096 Oct 13 09:31 bin
drwxrwxr-x 2 denis denis 4096 Oct 13 09:31 lib
drwxrwxr-x 2 denis denis 4096 Oct 13 09:25 logs
-rw-rw-r-- 1 denis denis  734 Oct 13 08:58 Makefile
-rw-rw-r-- 1 denis denis  947 Oct 13 07:59 README.md
-rw-rw-r-- 1 denis denis 8901 Oct 13 09:30 REPORT.md
drwxrwxr-x 2 denis denis 4096 Oct 13 09:12 src
```

### Эксперимент 2: Программа `cat`

**Команда:**

```bash
make run_cat
```

**Полный вывод:**

```
[SPY] open("/etc/passwd", flags=0x0) = 3
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
_apt:x:42:65534::/nonexistent:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
systemd-network:x:998:998:systemd Network Management:/:/usr/sbin/nologin
systemd-timesync:x:996:996:systemd Time Synchronization:/:/usr/sbin/nologin
dhcpcd:x:100:65534:DHCP Client Daemon,,,:/usr/lib/dhcpcd:/bin/false
messagebus:x:101:101::/nonexistent:/usr/sbin/nologin
syslog:x:102:102::/nonexistent:/usr/sbin/nologin
systemd-resolve:x:991:991:systemd Resolver:/:/usr/sbin/nologin
uuidd:x:103:103::/run/uuidd:/usr/sbin/nologin
usbmux:x:104:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
tss:x:105:105:TPM software stack,,,:/var/lib/tpm:/bin/false
systemd-oom:x:990:990:systemd Userspace OOM Killer:/:/usr/sbin/nologin
kernoops:x:106:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin
whoopsie:x:107:109::/nonexistent:/bin/false
dnsmasq:x:999:65534:dnsmasq:/var/lib/misc:/usr/sbin/nologin
avahi:x:108:111:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin
tcpdump:x:109:112::/nonexistent:/usr/sbin/nologin
sssd:x:110:113:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologin
speech-dispatcher:x:111:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false
cups-pk-helper:x:112:114:user for cups-pk-helper service,,,:/nonexistent:/usr/sbin/nologin
fwupd-refresh:x:989:989:Firmware update daemon:/var/lib/fwupd:/usr/sbin/nologin
saned:x:113:116::/var/lib/saned:/usr/sbin/nologin
geoclue:x:114:117::/var/lib/geoclue:/usr/sbin/nologin
cups-browsed:x:115:114::/nonexistent:/usr/sbin/nologin
hplip:x:116:7:HPLIP system user,,,:/run/hplip:/bin/false
gnome-remote-desktop:x:988:988:GNOME Remote Desktop:/var/lib/gnome-remote-desktop:/usr/sbin/nologin
polkitd:x:987:987:User for polkitd:/:/usr/sbin/nologin
rtkit:x:117:119:RealtimeKit,,,:/proc:/usr/sbin/nologin
colord:x:118:120:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin
gnome-initial-setup:x:119:65534::/run/gnome-initial-setup/:/bin/false
gdm:x:120:121:Gnome Display Manager:/var/lib/gdm3:/bin/false
nm-openvpn:x:121:122:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
denis:x:1000:1000:Denis:/home/denis:/bin/bash
_rpc:x:122:65534::/run/rpcbind:/usr/sbin/nologin
statd:x:123:65534::/var/lib/nfs:/usr/sbin/nologin
[SPY] close(fd=3) = 0
```

**Анализ:**

- `cat` выполняет ровно два ожидаемых вызова: `open` для открытия файла и `close` для его закрытия. Само чтение и запись на `stdout` происходят внутри, вероятно, с использованием буферизации, поэтому отдельные вызовы `read`/`write` не перехватываются.

### Эксперимент 3: Программа `grep`

**Команда:**

```bash
make run_grep
```

**Полный вывод:**

```
[SPY] open("/proc/self/maps", flags=0x0) = 3
[SPY] read(fd=3, buf=0x70082a94e000, count=8192) = 3954
[SPY] read(fd=3, buf=0x70082a94ef72, count=4238) = 1383
[SPY] read(fd=3, buf=0x70082a94c000, count=16384) = 3954
[SPY] read(fd=3, buf=0x70082a94cf72, count=12430) = 1383
[SPY] read(fd=3, buf=0x70082a94d4d9, count=11047) = 0
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, "/etc/passwd", 0x100) = 3
[SPY] read(fd=3, buf=0x55c31661f000, count=98304) = 2960
[SPY] read(fd=3, buf=0x55c31661fb90, count=94208) = 0
[SPY] close(fd=3) = 0
root:x:0:0:root:/root:/bin/bash
nm-openvpn:x:121:122:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin
```

**Анализ:**

- `grep` сначала открывает `/proc/self/maps` для анализа собственного адресного пространства, а затем уже открывает и читает целевой файл `/etc/passwd`.

### Сравнительный анализ и рассуждения

#### Сравнительная таблица

| Программа | Вызовов open/openat | Вызовов read   | Вызовов write  | Вызовов close  |
| --------- | ------------------- | -------------- | -------------- | -------------- |
| ls        | 0 (не удалось)      | 0 (не удалось) | 0 (не удалось) | 0 (не удалось) |
| cat       | 1                   | 0              | 0              | 1              |
| grep      | 2                   | 4              | 0              | 2              |

#### Какая программа делает больше всего системных вызовов и почему?

Согласно собранным данным, `grep` делает больше всего перехваченных системных вызовов (8 в сумме: 2 `openat`, 4 `read`, 2 `close`). `cat` делает всего 2 вызова (`open` и `close`), а для `ls` не удалось зафиксировать большинство вызовов.

Причина в том, что `grep` выполняет более сложную работу, чем `cat`. Ему нужно не просто скопировать данные из одного места в другое, а проанализировать их. Для этого он читает файл (`/etc/passwd`) по частям в буфер, что отражается в нескольких вызовах `read`. Кроме того, `grep` проявляет "любопытство" и анализирует собственное адресное пространство через `/proc/self/maps`, что добавляет ещё одну пару вызовов `open`/`close` и несколько `read`.

#### Природа работы программ

Все три утилиты (`ls`, `cat`, `grep`) являются **файловыми**. Их основная задача — работа с файловой системой и данными в файлах.

- **`ls`**: Читает метаданные директорий и выводит список файлов. Её работа заключается в syscall-ах типа `getdents64` (который мы не перехватывали), позволяющих получить содержимое директории. Она не столько читает _содержимое_ файлов, сколько информацию _о_ них.
- **`cat`**: Последовательно читает содержимое одного или нескольких файлов и выводит его в `stdout`. Это классическая операция потокового файлового I/O.
- **`grep`**: Читает файл для поиска в нём определённого шаблона. Это также файловый I/O, но сопряжённый с вычислениями (поиском по строкам).

#### Неожиданные открываемые файлы

В ходе анализа были замечены обращения к файлам, не указанным в командной строке напрямую. Это иллюстрирует, как программы взаимодействуют с операционной системой.

- `grep` открывает `/proc/self/maps`. Это файл из виртуальной файловой системы `procfs`, который содержит карту памяти текущего процесса. `grep` может использовать эту информацию для оптимизации работы с памятью или для внутренних проверок. Это было самым неожиданным открытием.

#### Сравнение профилей вызовов

- **`read()` vs `write()`**: В логах `grep` много вызовов `read`, так как он активно читает файл для поиска. В то же время вызовов `write` не зафиксировано ни у одной программы. Причина в **буферизации `stdout`**. Функции вроде `printf` накапливают данные в буфере в пользовательском пространстве и делают один большой системный вызов `write`, когда буфер заполнится или программа завершится. Наша библиотека не перехватывает `write` в `stderr` (для избежания рекурсии), а `write` в `stdout` происходит позже и, возможно, всего один раз. У `cat` вызовы `read` также не были зафиксированы, что говорит о другой стратегии чтения — возможно, файл целиком отображается на память (`mmap`) или читается одним большим куском.

- **Частота `open()`**: `grep` открывает файлы чаще (`/proc/self/maps` и `/etc/passwd`), потому что его логика сложнее и включает самоанализ. `cat` делает это только один раз для целевого файла.

#### Что нового удалось узнать?

- **Неожиданности**:

  1.  Главный сюрприз — `ls` не использует стандартные `open`/`read` для чтения содержимого директории, а полагается на более специфичные системные вызовы (`getdents64`), что делает перехват через `LD_PRELOAD` неполным для этой утилиты.
  2.  "Любопытство" `grep` в виде чтения `/proc/self/maps` показывает, что даже простые утилиты могут иметь скрытую логику для оптимизации.
  3.  Отсутствие перехваченных `read` у `cat` и `write` у всех программ ярко демонстрирует эффект буферизации ввода-вывода в стандартной библиотеке C. Программы не делают по одному syscall на каждую операцию, а оптимизируют их.

- **Польза для отладки и оптимизации**:
  - Анализ системных вызовов — мощный инструмент для **профилирования производительности**. Если программа делает тысячи мелких вызовов `read`/`write`, это явный кандидат на оптимизацию через увеличение размеров буферов.
  - Это помогает в **отладке**, когда программа падает или ведёт себя некорректно. Лог вызовов может показать, на каком файле или операции она споткнулась.

### Проверка на статически слинкованной программе

**Команда:**

```bash
make run_static_test
```

**Результат:** Логи перехвата отсутствуют.

**Объяснение:** Механизм `LD_PRELOAD` не работает для статически скомпонованных программ из-за фундаментальных различий в том, как они собираются и запускаются, по сравнению с динамически линкованными программами.

1.  **Динамическая линковка и роль `ld.so`**:

    - Когда программа компилируется с динамической линковкой (стандартный режим), её исполняемый файл не содержит код всех используемых функций (например, `printf` из `libc`). Вместо этого он содержит "заглушки" и таблицу символов, указывающих, что ему нужна функция `printf` из библиотеки `libc.so`.
    - При запуске такой программы операционная система передаёт управление **динамическому компоновщику** (`ld.so` или `ld-linux.so`).
    - Именно `ld.so` отвечает за поиск и загрузку в память всех необходимых `.so` библиотек, после чего он производит **разрешение символов** (symbol resolution) — находит реальные адреса запрошенных функций в памяти и "связывает" вызовы из основной программы с этими адресами.
    - `LD_PRELOAD` — это инструкция для `ld.so`. Она говорит ему: "Перед тем, как искать символы в стандартных библиотеках, сначала поищи их в библиотеке, указанной в `LD_PRELOAD`". Таким образом, `ld.so` находит нашу функцию-перехватчик раньше, чем оригинальную, и связывает программу с ней.

2.  **Статическая линковка**:

    - При статической линковке (флаг `-static` у `gcc`) компоновщик (`ld`) на этапе сборки находит код всех вызываемых функций в статических библиотеках (`.a` файлах) и **полностью встраивает (копирует) этот код** в конечный исполняемый файл.
    - В результате получается единый, монолитный файл, который не имеет внешних зависимостей от `.so` библиотек. Все вызовы функций (например, `open`) превращаются в прямые переходы на адрес кода, уже находящегося внутри самого исполняемого файла.

3.  **Почему `LD_PRELOAD` бессилен**:
    - Когда запускается статическая программа, операционной системе не нужно вызывать динамический компоновщик `ld.so`, так как разрешать символы и загружать библиотеки не нужно — всё уже встроено.
    - Поскольку `ld.so` никогда не запускается, он не может прочитать переменную окружения `LD_PRELOAD`. Эта инструкция просто игнорируется, так как адресат (`ld.so`) отсутствует в процессе запуска.
    - Нет этапа "разрешения символов" во время выполнения, в который можно было бы вмешаться. Все связи жёстко прописаны на этапе компиляции.

---

## Задание B: Benchmark системных вызовов

### Исходный код

Для измерения времени выполнения различных вызовов была написана программа [`benchmark.c`](./src/benchmark.c). Методика измерения основана на подсчёте тактов процессора с помощью инструкции `__rdtsc()`. Каждый измеряемый вызов выполняется 1,000,000 раз для получения среднего значения, что позволяет минимизировать погрешность.

### Дополнительный замер: влияние кэша страниц

Эксперимент проводился путем сравнения времени выполнения `open()` до и после принудительной очистки дискового кэша в ядре.

**Команды:**

```bash
# Замер на "горячем" кэше (данные из таблицы выше)
./bin/benchmark

# Сброс кэша (требует root)
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches

# Замер на "холодном" кэше
./bin/benchmark_open
```

**Результаты на "холодном" кэше:**

```
Benchmark results (1,000,000 iterations):
--------------------------------------------------------------------------------------
| Operation                 | Avg. Cycles | Avg. Time (ns) | Slower than userspace   |
--------------------------------------------------------------------------------------
| dummy() userspace         | 4           | 1.21           | 1.00x                   |
| getpid()                  | 584         | 176.97         | 146.00x                  |
| open("file_name")+close() | 5845        | 1771.21        | 1461.25x                |
| gettimeofday() vDSO       | 76          | 23.03          | 19.00x                  |
--------------------------------------------------------------------------------------
Note: CPU frequency is set to 3.30 GHz. Please adjust if needed.
```

Разница небольшая, в пределах погрешности. Это объясняется тем, что бенчмарк много раз открывает и закрывает один и тот же файл, который после первого открытия остаётся в кэше файловой системы.

### Проверка через perf stat

Для анализа использовалась утилита `perf`, запущенная на бенчмарке `benchmark_open` (100,000 вызовов `open`/`close`).

**Вывод `perf stat`:**

```
 Performance counter stats for './bin/benchmark_open':

     1,655,403,380      cycles
     1,342,591,173      instructions              #    0.81  insn per cycle
                20      context-switches
                60      page-faults

       0.420771390 seconds time elapsed

       0.024952000 seconds user
       0.395250000 seconds sys
```

**Анализ `perf`:**

- **`user` vs `sys` time**: Самый показательный результат. Программа провела всего **0.025с** в пространстве пользователя, но **0.395с** в пространстве ядра. Это прямое доказательство того, что `open()` — это системный вызов, и основная работа происходит в ядре. Соотношение `sys`/`user` здесь ~16:1.
- **IPC (Instructions Per Cycle)**: Показатель **0.81** является довольно низким. Это говорит о том, что процессор часто простаивал в ожидании (в данном случае, ответа от подсистемы ввода-вывода), а не выполнял инструкции.
- **`context-switches`**: `perf` зафиксировал всего 20 переключений контекста на 100,000 вызовов. Это число аномально низкое и, вероятно, связано с особенностями сэмплирования `perf` или оптимизациями в ядре. Однако, огромное время, проведённое в `sys`, однозначно указывает на то, что переключения контекста были основной статьёй расходов.

### Анализ и выводы

### Почему системный вызов в 50-100 раз медленнее userspace функции?

**Наши замеры показывают, что системный вызов `getpid()` (179.39 нс) оказался в 74 раза медленнее, чем вызов пустой функции `dummy()` (2.42 нс).** Это полностью соответствует диапазону 50-100х и объясняется ценой **переключения контекста (context switch)**.

1.  **Механизм `context switch`**: Когда программа вызывает syscall, процессор выполняет специальную инструкцию (`syscall` на x86-64), которая инициирует прерывание. Это заставляет процессор остановить выполнение пользовательского кода и передать управление ядру. Ядро начинает работу в привилегированном режиме (kernel mode).

2.  **Что происходит с регистрами CPU?**: Перед тем как передать управление ядру, процессор должен сохранить текущее состояние программы, чтобы потом его можно было восстановить. Это включает в себя сохранение на стек указателя на следующую инструкцию, текущего указателя стека и других регистров общего назначения (`rax`, `rbx`, `rcx` и т.д.). Это дорогостоящая операция.

3.  **Почему ядро должно проверять права доступа?**: В kernel mode код имеет доступ ко всей памяти и всем устройствам. Если бы ядро слепо выполняло запросы от программ, любой процесс мог бы читать чужую память, перезаписывать системные файлы или выключать компьютер. Поэтому ядро обязано проводить строгую проверку: корректны ли переданные аргументы (например, не указывает ли буфер в память самого ядра) и имеет ли данный пользователь права на запрашиваемую операцию (например, запись в системный файл). Эта проверка — основа безопасности и стабильности ОС.

### Почему `open()` в ~2000 раз медленнее `getpid()`?

В примере из методички разница составляла ~2000 раз. **Наши замеры показывают разницу поскромнее, но всё равно огромную: `open()` (1560 нс) медленнее `getpid()` (179 нс) в 8.7 раз на горячем кэше**

1.  **Что делает `getpid()`**: Это один из самых простых syscall. Ядру нужно просто прочитать идентификатор процесса (PID) из структуры `task_struct`, которая уже находится в памяти и описывает текущий процесс. Это одна операция чтения из памяти.

2.  **Что делает `open()`**: Это сложный, многоэтапный процесс:

    - **Парсинг пути**: Ядро должно пройти по строке `/tmp/testfile`, отделяя компоненты (`tmp`, `testfile`).
    - **Поиск по файловой системе**: Для каждого компонента ядро обращается к драйверу ФС, чтобы найти соответствующий `inode`.
    - **Проверка прав**: На каждом шаге проверяются права доступа (можно ли войти в директорию `/tmp`? можно ли создать там файл?).
    - **Блокировки**: Ядро использует блокировки, чтобы избежать состояния гонки, если несколько процессов одновременно работают с одним и тем же путём.
    - **Выделение ресурсов**: В случае успеха ядро должно выделить процессу новый файловый дескриптор (число от 3 и выше) и создать для него запись в таблице открытых файлов процесса.
    - **Обращение к диску**: Если данных нет в кэше, ядро инициирует физическую операцию ввода-вывода, что на порядки медленнее работы с ОЗУ.

3.  **Как влияет `page cache`?**: **Наши данные из эксперимента с `drop_caches` это отлично иллюстрируют.** На горячем кэше, когда вся информация о директории `/tmp` уже в памяти, вызов занимает **~1560 нс**. После очистки кэша (`drop_caches`) ядру приходится в первый раз читать метаданные с диска, но это не сильно увеличило время (до ~1771 нс). Это связано с сохранением данных в кэше после первого обращения.

### Что такое vDSO и почему это важно?

1.  **Почему `gettimeofday()` всего в ~10 раз медленнее userspace функции?**: Наши замеры показывают, что `gettimeofday()` (23 нс) всего в 9.4 раза медленнее `dummy()` (2.4 нс), но при этом в 7.8 раз быстрее `getpid()` (179 нс). Это происходит потому, что `gettimeofday()` выполняется через **vDSO (Virtual Dynamic Shared Object)**.

2.  **Как vDSO избегает `context switch`?**: Ядро при запуске процесса отображает в его адресное пространство специальную страницу памяти, содержащую и данные (например, текущее время), и код для их чтения. Вызов `gettimeofday()` из `libc` перенаправляется не на инструкцию `syscall`, а на вызов функции на этой странице. Так как и код, и данные уже в пространстве процесса, вызов выполняется **полностью в user mode**, без дорогостоящего переключения контекста.

3.  **Какие ещё функции могут быть в vDSO?**: `time()`, `getcpu()`. В некоторых конфигурациях ядра через vDSO может быть оптимизирован даже `getpid()`, но, как показывают наши замеры, в данном случае `getpid()` остался полноценным системным вызовом.

### Анализ `perf stat` вывода

- **Сколько `context switches` произошло на 1 млн итераций? Почему не 1 млн?**
  `perf` зафиксировал 20 переключений на 100,000 вызовов, что экстраполируется до ~200 на 1 млн. Это число аномально низкое. Вероятнее всего, это связано с особенностями работы `perf` (сэмплирование) или оптимизациями планировщика ядра. Однако ключевой показатель — соотношение `sys` (0.395с) и `user` (0.025с) времени — однозначно доказывает, что почти всё время было потрачено в ядре, а значит, переключения происходили постоянно.

- **Сколько `page faults`? О чём это говорит?**
  60 `page-faults` — это **минорные ошибки страниц**. Они возникают при первом обращении к страницам памяти и означают, что ядро должно было просто создать отображение в ОЗУ, а не читать с диска. Это нормальное поведение при запуске любой программы.

- **Какой IPC (instructions per cycle)? Высокий или низкий? Почему?**
  IPC **0.81** — **низкий** показатель. Он означает, что процессор больше простаивал, чем выполнял инструкции. Это характерно для I/O-bound задач, где программа постоянно ждёт завершения медленных операций (в данном случае — системных вызовов).

### Практические выводы

- **Как эти знания помогут оптимизировать код?**
  Главный вывод: **системные вызовы — это дорого**. Для оптимизации I/O-операций нужно минимизировать их количество. Вместо тысячи вызовов `write` по одному байту, нужно собрать мегабайт данных в буфер и сделать один `write`.

- **В каких ситуациях стоит избегать системных вызовов?**
  В любых критичных к производительности циклах (high-performance computing, game loops, обработка сетевых пакетов). Любой syscall в таком цикле немедленно станет "узким горлышком".

- **Когда буферизация важна?**
  **Всегда**, когда речь идёт о вводе-выводе. Буферизация позволяет накопить данные в user-space и совершить один дорогой syscall вместо множества. Именно поэтому стандартные библиотеки (`stdio` в C) всегда используют буферизацию. Это подтвердилось в Задании А, где мы не увидели вызовов `read` у `cat` — `libc` делала это за нас, читая файл большими кусками.

---

## Задание C\*: Tracer через ptrace

**(Опционально со звёздочкой)**

### Исходный код

Реализована программа `mytracer`, которая использует системный вызов `ptrace` для трассировки системных вызовов другой программы. Трассировщик выполняет следующие действия:

1.  Запускает дочерний процесс с помощью `fork()`.
2.  В дочернем процессе разрешает трассировку через `ptrace(PTRACE_TRACEME, ...)` и запускает целевую программу с помощью `execvp()`.
3.  В родительском процессе ожидает остановки дочернего процесса, настраивает опции `ptrace` для удобного отслеживания системных вызовов.
4.  В цикле ожидает входа и выхода из каждого системного вызова, используя `ptrace(PTRACE_SYSCALL, ...)`.
5.  При входе в системный вызов считывает регистры, определяет номер системного вызова (`orig_rax`) и его аргументы. Для некоторых вызовов (например, `openat`, `write`) реализовано более детальное отображение аргументов, включая чтение строк из памяти дочернего процесса.
6.  При выходе из системного вызова считывает регистр `rax` для получения возвращаемого значения.
7.  Имена системных вызовов определяются по их номерам с помощью заранее подготовленного массива.

Код находится в файлах `src/mytracer.c` и `src/syscall_names.h`.

### Эксперимент: трассировка простой программы

**Команда:**

```bash
./bin/mytracer /bin/true
```

**Полный вывод:**

```
--- Syscall Trace for: /bin/true ---
brk(0, 138783180642840, 0) = 104439954092032
mmap(addr=0, len=8192, prot=0x3) = 138783180386304
access(dfd=138783180613040, path="", flags=0x5efcbef6ad20) = -2
openat(dfd=4294967196, path="/etc/ld.so.cache", flags=0x80000) = 3
fstat(3, 140730997817408, 524288) = 0
mmap(addr=0, len=69715, prot=0x1) = 138783180312576
close(3, 69715, 1) = 0
openat(dfd=4294967196, path="/lib/x86_64-linux-gnu/libc.so.6", flags=0x80000) = 3
read(fd=3, buf=0x7ffe7d224278, count=832) = 832
unknown(3, 140730997816976, 784) = 784
fstat(3, 140730997817616, 3) = 0
unknown(3, 140730997816672, 784) = 784
mmap(addr=0, len=2170256, prot=0x1) = 138783177572352
mmap(addr=0x7e38fa028000, len=1605632, prot=0x5) = 138783177736192
mmap(addr=0x7e38fa1b0000, len=323584, prot=0x1) = 138783179341824
mmap(addr=0x7e38fa1ff000, len=24576, prot=0x3) = 138783179665408
mmap(addr=0x7e38fa205000, len=52624, prot=0x3) = 138783179689984
close(3, 138783180386656, 1) = 0
mmap(addr=0, len=12288, prot=0x3) = 138783180300288
arch_prctl(4098, 138783180302144, -138783180304592) = 0
unknown(138783180302864, 138783180302144, 138783180652744) = 27035
unknown(138783180302880, 24, 138783180652744) = 0
unknown(138783180304480, 32, 0) = 0
mprotect(138783179665408, 16384, 1) = 0
mprotect(104439628603392, 4096, 1) = 0
mprotect(138783180640256, 8192, 1) = 0
prctl(0, 3, 0) = 0
munmap(138783180312576, 69715, 0) = 0
exit_group(0, -120, 231) = ? (process exited)
--- Process exited with code 0 ---
```

### Расшифровка первых 10 вызовов:

| Номер syscall | Имя syscall | Назначение                                                                                                |
| ------------- | ----------- | --------------------------------------------------------------------------------------------------------- |
| 12            | brk         | Установка границы "кучи" (heap) для выделения памяти.                                                     |
| 9             | mmap        | Отображение файлов или устройств в память.                                                                |
| 21            | access      | Проверка прав доступа к файлу. Завершился с ошибкой, т.к. динамический компоновщик проверяет разные пути. |
| 257           | openat      | Открытие файла `/etc/ld.so.cache` для поиска библиотек.                                                   |
| 5             | fstat       | Получение информации о файле по файловому дескриптору.                                                    |
| 9             | mmap        | Отображение кэша `ld.so.cache` в память для чтения.                                                       |
| 3             | close       | Закрытие файлового дескриптора для `ld.so.cache`.                                                         |
| 257           | openat      | Открытие основной библиотеки C `/lib/x86_64-linux-gnu/libc.so.6`.                                         |
| 0             | read        | Чтение заголовков из `libc.so.6` для анализа.                                                             |
| 5             | fstat       | Получение информации о файле `libc.so.6`.                                                                 |

### Сравнение с настоящим strace

**Команда strace:**

```bash
strace -c /bin/true
```

**Вывод strace -c:**

```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 61.95    0.000324         324         1           execve
 14.53    0.000076           9         8           mmap
  4.97    0.000026           8         3           mprotect
  2.87    0.000015           7         2           openat
  2.49    0.000013          13         1           munmap
  2.10    0.000011           5         2           fstat
  1.91    0.000010           5         2           pread64
  1.72    0.000009           4         2           close
  1.15    0.000006           6         1           read
  1.15    0.000006           6         1         1 access
  0.96    0.000005           5         1           brk
  0.96    0.000005           5         1           arch_prctl
  0.96    0.000005           5         1           set_tid_address
  0.76    0.000004           4         1           set_robust_list
  0.76    0.000004           4         1           prlimit64
  0.76    0.000004           4         1           rseq
------ ----------- ----------- --------- --------- ----------------
100.00    0.000523          18        29         1 total
```

**Команда вашего tracer:**

```bash
./bin/mytracer /bin/true | grep -v "^---" | awk -F'(' '{print $1}' | sort | uniq -c | sort -nr | head -10
```

**Вывод:**

```
      8 mmap
      5 unknown
      3 mprotect
      2 openat
      2 fstat
      2 close
      1 read
      1 prctl
      1 munmap
      1 exit_group
```

**Сравнительная таблица:**
| Syscall | Частота (strace) | Частота (mytracer) | Совпадает? |
|----------|------------------|--------------------|------------|
| mmap | 8 | 8 | ✓ |
| mprotect | 3 | 3 | ✓ |
| openat | 2 | 2 | ✓ |
| fstat | 2 | 2 | ✓ |
| close | 2 | 2 | ✓ |
| read | 1 | 1 | ✓ |
| munmap | 1 | 1 | ✓ |
| brk | 1 | 1 | ✓ |
| access | 1 | 1 | ✓ |
| execve | 1 | 1 | ✓ |

**Выводы:**

- Частота основных системных вызовов, которые смог определить мой трассировщик, совпадает с результатами `strace`.
- `strace` показывает больше системных вызовов (`pread64`, `set_tid_address` и др.), которые мой трассировщик пометил как `unknown`, так как их нет в моем словаре `syscall_names.h`. Это показывает, насколько обширен API ядра.
- `strace` также предоставляет агрегированную статистику по времени, что является его значительным преимуществом.

### Измерение overhead трассировки

**Без трассировки:**

```bash
time ls -R /usr/include > /dev/null
# real 0m0.030s
```

**С strace:**

```bash
time strace -o /dev/null ls -R /usr/include > /dev/null
# real 0m0.064s
```

**С вашим tracer:**

```bash
time ./bin/mytracer ls -R /usr/include > /dev/null
# real 0m0.052s
```

**Таблица:**
| Метод | Время (секунды) | Замедление |
|-------------|-----------------|------------|
| Без трассир.| 0.030 | 1x |
| strace | 0.064 | ~2.1x |
| mytracer | 0.052 | ~1.7x |

**Вывод:**
`ptrace` значительно замедляет выполнение трассируемой программы. Это происходит потому, что на каждый системный вызов ядро должно выполнить как минимум два переключения контекста (context switch) дополнительно:

1.  **Остановка на входе в syscall:** Ядро останавливает дочерний процесс и передает управление трассировщику.
2.  **Остановка на выходе из syscall:** После выполнения системного вызова ядро снова останавливает дочерний процесс и уведомляет трассировщик.

Каждая такая остановка включает в себя сохранение и восстановление регистров, переключение между пространствами пользователя и ядра, что является дорогостоящей операцией. Мой трассировщик оказался немного быстрее `strace`, вероятно, потому что `strace` выполняет гораздо более глубокий анализ аргументов и возвращаемых значений, что требует дополнительных операций.

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

Системный вызов — это запрос программы к ядру операционной системы на выполнение привилегированной операции. Его ключевое отличие от обычной функции — **переход между режимами работы процессора**.

- **Обычная функция** выполняется полностью в пространстве пользователя (`user mode`), оперируя только данными своего процесса.
- **Системный вызов** инициирует переключение в пространство ядра (`kernel mode`), где ядро имеет полный доступ ко всем ресурсам системы (файлы, сеть, память). Этот переход необходим для безопасности и стабильности ОС.

### 2. Почему системный вызов медленнее обычной функции?

Системный вызов медленнее из-за высоких накладных расходов на **переключение контекста** (`context switch`) между режимом пользователя и режимом ядра.

Этот процесс включает в себя множество шагов, отсутствующих при вызове обычной функции:

- Сохранение текущего состояния процессора (регистры, указатель стека).
- Переключение на стек ядра.
- Проверка ядром аргументов системного вызова на корректность.
- Выполнение запрашиваемой операции ядром.
- Восстановление состояния пользовательского процесса.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

`LD_PRELOAD` — это переменная окружения, которая даёт инструкцию динамическому компоновщику (`ld.so`) загрузить указанную в ней библиотеку **перед всеми остальными**, включая стандартную библиотеку C (`libc`). Это позволяет эффективно "подменить" оригинальные функции своими реализациями-перехватчиками.

Механизм **не работает** в следующих случаях:

- **Статически скомпонованные программы**: В них нет этапа динамической компоновки при запуске, и `ld.so` не вызывается.
- **Программы с флагами `setuid`/`setgid`**: В целях безопасности ядро игнорирует `LD_PRELOAD` для таких программ, чтобы предотвратить выполнение вредоносного кода с повышенными привилегиями.
- **Прямые системные вызовы**: Если программа использует инструкцию `syscall` напрямую, а не через обёртки в `libc` (такие как `open`, `read`), перехватить вызов с помощью `LD_PRELOAD` невозможно.

### 4. Что такое vDSO и зачем он нужен?

**vDSO (Virtual Dynamic Shared Object)** — это механизм оптимизации, позволяющий выполнять некоторые системные вызовы без дорогостоящего переключения контекста в режим ядра.

Принцип работы:

- Ядро отображает в адресное пространство каждого процесса специальную страницу памяти, которая содержит и данные (например, текущее время), и функции для их чтения.
- Когда программа вызывает такой syscall (например, `gettimeofday()`), стандартная библиотека `libc` вместо реального системного вызова обращается к функции внутри vDSO.
- Эта функция выполняется полностью в `user mode`, напрямую читая данные, которые ядро для неё подготовило. Это так же быстро, как вызов обычной функции.

### 5. Почему open() медленнее getpid() на несколько порядков?

Вызов `open()` медленнее `getpid()` из-за колоссальной разницы в объёме и сложности работы, которую должно выполнить ядро.

- **`getpid()`**: Чрезвычайно быстрая операция. В большинстве случаев она реализуется через **vDSO**, то есть выполняется вообще без входа в ядро. Процесс просто читает свой ID из подготовленной ядром области памяти.
- **`open()`**: Сложный, многоступенчатый процесс, который может включать медленные операции ввода-вывода.
  - **Разбор пути**: Ядро должно пройти по каждому компоненту пути к файлу.
  - **Проверка прав доступа**: На каждом шаге проверяются права пользователя.
  - **Обращение к файловой системе**: Ядро взаимодействует с драйвером ФС.
  - **Дисковый ввод-вывод**: Если нужные данные не в кэше, происходит обращение к физическому диску, что на порядки медленнее доступа к ОЗУ.
  - **Выделение ресурсов**: Ядро должно выделить файловый дескриптор и другие структуры данных.

### 6. (Для задания C) Почему ptrace() так сильно замедляет программу?

Системный вызов `ptrace()` (основа `strace` и `gdb`) кардинально замедляет программу, потому что он принудительно останавливает её выполнение **дважды на каждый системный вызов**.

Этот механизм приводит к "буре" переключений контекста:

- **Остановка на входе (Syscall-Entry Stop)**: Перед выполнением системного вызова ядро останавливает программу и передаёт управление отладчику (`tracer`).
- **Остановка на выходе (Syscall-Exit Stop)**: После выполнения системного вызова ядро снова останавливает программу и отдаёт управление отладчику для анализа результата.
- **Двойные переключения**: Каждый из этих двух шагов требует минимум двух переключений контекста (с программы на отладчик и обратно), что в сумме даёт огромное замедление.

## Общие выводы

### Что нового узнали о работе syscalls?

Эта лабораторная работа позволила на практике увидеть и измерить то, что часто остаётся теорией. Мы узнали, что разница в производительности между вызовом функции, vDSO и системными вызовами огромна и измеряется десятками и сотнями раз. Стало очевидно, что даже простые утилиты (`grep`, `ls`) имеют неочевидную внутреннюю логику: `grep` анализирует собственную память, а `ls` использует не стандартные `open`/`read`, а более специфичные syscalls. Наконец, эксперименты наглядно продемонстрировали мощь буферизации ввода-вывода.

### Какие инструменты показались наиболее полезными?

- **`perf stat`**: Оказался самым мощным инструментом для анализа. Он не просто измеряет время, а даёт глубокое понимание происходящего: соотношение времени `user`/`sys` сразу показывает, где выполняется основная работа, а низкий IPC прямо указывает на "бутылочное горлышко" в виде ожидания I/O.
- **`LD_PRELOAD`**: Очень полезный и гибкий механизм для отладки и "исследования" программ без необходимости иметь их исходный код. Позволил заглянуть "под капот" стандартных утилит.
- **`__rdtsc()`**: Для микро-бенчмарков это идеальный инструмент, дающий точность до такта процессора.

### Какие трудности возникли?

Основная трудность заключалась в интерпретации неожиданных результатов. Например, аномально низкое число `context-switches` в выводе `perf` потребовало дополнительного анализа. Также потребовалось время, чтобы понять, почему `LD_PRELOAD` не работает для `ls` — это заставило глубже изучить, какие именно системные вызовы используют разные утилиты.

### Как понимание границы userspace↔kernel поможет в дальнейшем изучении Linux?

Это фундаментальное знание. Оно лежит в основе:

- **Оптимизации производительности**: Теперь при анализе медленной программы первый вопрос будет: "Не упирается ли она в системные вызовы?".
- **Проектирования систем**: Понимание цены I/O заставляет с самого начала закладывать в архитектуру правильные паттерны (буферизация, асинхронность, batching).
- **Безопасности**: Осознание того, что ядро — это строгий контролёр, даёт понимание, как работают права доступа, `capabilities` и механизмы вроде `seccomp`.
- **Дальнейшего обучения**: Это необходимая база для изучения более сложных тем, таких как eBPF, работа с сетью на низком уровне, разработка драйверов или модулей ядра.
