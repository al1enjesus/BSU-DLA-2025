# Лабораторная 4 — Системные вызовы

Курс: Проектирование приложений под Linux (DLA, 4 курс)

## Выбор программ

Номер в списке группы: 25
Расчёт группы программ: 25 % 4 = 1
Программы для анализа: find, tap, cp
Задания : A,B

*** Параметры системы и окружения ***
- Операционная система : Ubuntu 22.04.2
- Версия ядра : Linux version 6.6.87.2-microsoft-standard-WSL2
- CPU(s) : 16
- Компилятор: gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
## Задание A: LD_PRELOAD перехват

### Код библиотеки

Для перехвата вызовов была реализована библиотека `libsyscall_spy.so` в файле [syscall_spy.c](./src/syscall_spy.c). Она использует механизм `LD_PRELOAD` для "подмены" стандартных библиотечных функций `open`, `openat`, `read`, `write` и `close` своими версиями.
Код для компиляции shared library
```bash
gcc -shared -fPIC -o libsyscall_spy.so syscall_spy.c -ldl
```
***Эксперимент 1 - Find***
Для проверки работы были созданы тестовые файлы и папк.Они в полной мере демонстрируют процесс выполнения команды find,которая занимается реккурсивным поиском фалйлов.
```bash
LD_PRELOAD=./libsyscall_spy.so find test_data -type f
```
Вывод команды:
```bash
[36m
[SPY] === Variant: find/tar/cp === Program: find ===
[0m[32m[SPY] OPEN: "." -> fd=3
[0m[32m[SPY] OPENAT: AT_FDCWD/"test_data" -> fd=4
[0m[32m[SPY] OPENAT: dirfd/"folder1" -> fd=6
[0m[SPY] CLOSE: fd=4
[SPY] CLOSE: fd=7
[SPY] CLOSE: fd=4
[32m[SPY] OPENAT: dirfd/"subdir" -> fd=6
[0m[SPY] CLOSE: fd=4
[SPY] CLOSE: fd=7
[SPY] CLOSE: fd=4
[SPY] CLOSE: fd=5
[SPY] CLOSE: fd=4
[SPY] CLOSE: fd=3
test_data/folder1/file3.txt
test_data/file2.txt
test_data/subdir/file4.txt
test_data/file1.txt
```
Из логов видно,что преобладает openat() - 6 вызовов для безопасного обхода директорий
Рекурсивный обход - открытие каждой поддиректории через openat()
Только метаданные - отсутствие read()/write(), так как не читается содержимое файлов
Активное управление дескрипторами - множество close() для освобождения ресурсов

***Эксперимент 2 - TAR***
Tar- команда для создания,извлечения и управления архивными файлами.Она позволяет объединять множество файлов и каталогов в один файл архива, что удобно для резервного копирования и перемещения данных.
Запускается командой 
```bash
LD_PRELOAD=./libsyscall_spy.so tar -cf archive.tar test_data
```

```bash
[36m
[SPY] === Variant: find/tar/cp === Program: tar ===
[0m[33m[SPY] READ: fd=6, bytes=16
[0m[SPY] CLOSE: fd=6
[33m[SPY] READ: fd=5, bytes=15
[0m[SPY] CLOSE: fd=5
[33m[SPY] READ: fd=6, bytes=15
[0m[SPY] CLOSE: fd=6
[33m[SPY] READ: fd=5, bytes=15
[0m[SPY] CLOSE: fd=5
[35m[SPY] WRITE: fd=3, bytes=10240
[0m[SPY] CLOSE: fd=3
[SPY] === Variant: find/tar/cp === Program: tar ===
[0m[32m[SPY] OPEN: "archive.tar" -> fd=3
[0m[33m[SPY] READ: fd=3, bytes=10240
[0m[32m[SPY] OPENAT: dirfd/"test_data/folder1/file3.txt" -> fd=5
[0m[35m[SPY] WRITE: fd=5, bytes=16
[0m[SPY] CLOSE: fd=5
[32m[SPY] OPENAT: dirfd/"test_data/file2.txt" -> fd=5
[0m[35m[SPY] WRITE: fd=5, bytes=15
[0m[SPY] CLOSE: fd=5
[32m[SPY] OPENAT: dirfd/"test_data/subdir/file4.txt" -> fd=5
[0m[35m[SPY] WRITE: fd=5, bytes=15
[0m[SPY] CLOSE: fd=5
[32m[SPY] OPENAT: dirfd/"test_data/file1.txt" -> fd=5
[0m[35m[SPY] WRITE: fd=5, bytes=15
[0m[SPY] CLOSE: fd=5
[SPY] CLOSE: fd=3
``` 
***Эксперимент 3 - CP***
```bash
LD_PRELOAD=./libsyscall_spy.so cp test_data/file1.txt copied.txt
```

вывод
```bash
[36m
[SPY] === Variant: find/tar/cp === Program: cp ===
[0m[32m[SPY] OPEN: "test_data/file1.txt" -> fd=3
[0m[32m[SPY] OPEN: "copied.txt" -> fd=4
[0m[33m[SPY] READ: fd=3, bytes=15
[0m[35m[SPY] WRITE: fd=4, bytes=15
[0m[SPY] CLOSE: fd=4
[SPY] CLOSE: fd=3 
```
Анализ CP: Симметричная модель - пары open/close для каждого файла.Реализовано Прямое копирование - read() затем сразу следует write().Минимальные вызовы - только необходимые операции для копирования.Простота реализации - линейная последовательность операций
***СРАВНИТЕЛЬНАЯ ТАБЛИЦА ВЫЗОВОВ**
Программа    | OPEN | OPENAT | READ | WRITE | CLOSE
-------------|------|--------|------|-------|------
FIND         | 1 | 3 | 0 | 0 | 9
TAR CREATE   | 0 | 0 | 4 | 1 | 5
TAR EXTRACT  | 1 | 4 | 1 | 4 | 5
CP           | 2 | 0 | 1 | 1 | 2
FIND делает наибольшее кол-во вызовов:
13  - максимальное количество среди всех программ
Это объясняется тем,что  рекурсивный обход требует открытия каждой директории.Эффективен за счет игнорирования содержимого файлов,читаем только метаданные.
TAR CREATE делает интенсивные операции:
4 read() - чтение всех файлов для архивации
1 write() - буферизованная запись всего архива
Причина проста - необходимо прочитать все данные перед упаковкой
CP выступает за минималистичный подход:
6 вызовов - минимально необходимый набор
Симметрия: равное количество операций для источника и приемника
#### Природа работы программ
Все три утилиты являются файловыми. Их основная задача — работа с файловой системой и данными в файлах, но каждая имеет свою специализацию:
`find`: Рекурсивный обход файловой системы и поиск файлов по критериям. Работает преимущественно с метаданными, а не содержимым файлов. Использует специализированные системные вызовы для эффективного обхода директорий.

`tar`: Работа с архивами - упаковка и распаковка файлов. Требует как чтения содержимого файлов, так и записи архивных структур. Оптимизирован для работы с большими объемами данных через буферизацию.

`cp`: Копирование файлов из источника в приемник. Классическая операция файлового I/O с линейной последовательностью операций. Минималистичный подход к работе с файлами.
#### Интересные наблюдения:
Наблюдение 1: find не использует стандартные open()/read() для обхода директорий.Стандартные утилиты оптимизированы для конкретных задач.Существуют специализированные системные вызовы для повышения эффективности.Перехват через LD_PRELOAD может быть неполным без учета всех вызовов
Наблюдение 2: Разный профиль create/extract в tar.tar create и tar extract имеют совершенно разные профили вызовов.Объясняеся тем, что CREATE требует чтения множества файлов и записи одного архива,EXTRACT требует чтения одного архива и создания множества файлов.Асимметрия отражает фундаментальные различия в задачах
Наблюдение 3: Отсутствие множественных write() вызовов в выводе.

### Проверка на статической программе

```bash
gcc -static -o static_test static_test.c
LD_PRELOAD=./libsyscall_spy.so ./static_test
```
Механизм LD_PRELOAD не работает для статически скомпонованных программ из-за фундаментальных различий в том, как они собираются и запускаются:
## Задание B: Benchmark
Для измерения времени выполнения вызовов был разработан код в файле benchmark.c.Методика измерения основана на подсчёте тактов процессора с помощью инструкции __rdtsc(). Каждый измеряемый вызов выполняется 100000 раз для получения среднего значения.
Эксперимент проводился путем сравнения времени выполнения open() до и после принудительной очистки дискового кэша в ядре.
Команды:
```bash
gcc -O2 -o benchmark benchmark.c
gcc -O2 -o benchmark_cold benchmark_cold.c
./benchmark
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches
./benchmark_cold
```

Результат для горячего кэша
```
RESULTS:
--------------------------------------------------------------------------------------
| Operation                 | Avg. Cycles | Avg. Time (ns) | Slower than userspace   |
--------------------------------------------------------------------------------------
| dummy() userspace         | 9           | 3.11           | 1.00x                   |
| gettimeofday() vDSO       | 74          | 25.57          | 8.22x                  |
| getpid()                  | 908         | 313.69         | 100.89x                  |
| open+close() (cached)     | 9160        | 3164.56        | 1017.78x                |
| open+close() (new file)   | 121164      | 41859.23       | 13462.67x                |
--------------------------------------------------------------------------------------
=== SYSTEM CALL BENCHMARK ===
CPU Frequency: 2.89 GHz
Iterations: 1000000
```
Результат для холодного кэша
```
RESULTS:
--------------------------------------------------------------------------------------
| Operation                 | Avg. Cycles | Avg. Time (ns) | Slower than userspace   |
--------------------------------------------------------------------------------------
| dummy() userspace         | 9           | 3.11           | 1.00x                   |
| gettimeofday() vDSO       | 70          | 24.18          | 7.78x                  |
| getpid()                  | 873         | 301.60         | 97.00x                  |
| open+close() (cached)     | 10373       | 3583.62        | 1152.56x                |
| open+close() (new file)   | 135589      | 46842.71       | 15065.44x                |
--------------------------------------------------------------------------------------
```
Разница небольшая, в пределах погрешности. Это объясняется тем, что бенчмарк много раз открывает и закрывает один и тот же файл, который после первого открытия остаётся в кэше файловой системы.
***perf:***
Для запуска perf потребовалось написать программу benchmark_perf.c для анализа perf stats.
Бенчмарк успешно выполнил все виды нагрузки за 137.0 миллисекунд.
```
Starting benchmark_open with 100000 iterations...
Benchmark completed in 0.137042000 seconds
```
### Анализ и выводы

### Почему системный вызов в 50-100 раз медленнее userspace функции?

**Наши замеры показывают, что системный вызов `getpid()` (179.39 нс) оказался в 74 раза медленнее, чем вызов пустой функции `dummy()` (2.42 нс).** Это полностью соответствует диапазону 50-100х и объясняется ценой **переключения контекста (context switch)**.

1.  **Механизм `context switch`**: Когда программа вызывает syscall, процессор выполняет специальную инструкцию (`syscall` на x86-64), которая инициирует прерывание. Это заставляет процессор остановить выполнение пользовательского кода и передать управление ядру. Ядро начинает работу в привилегированном режиме (kernel mode).

2.  **Что происходит с регистрами CPU?**: Перед тем как передать управление ядру, процессор должен сохранить текущее состояние программы, чтобы потом его можно было восстановить. Это включает в себя сохранение на стек указателя на следующую инструкцию, текущего указателя стека и других регистров общего назначения (`rax`, `rbx`, `rcx` и т.д.). Это дорогостоящая операция.

3.  **Почему ядро должно проверять права доступа?**: В kernel mode код имеет доступ ко всей памяти и всем устройствам. Если бы ядро слепо выполняло запросы от программ, любой процесс мог бы читать чужую память, перезаписывать системные файлы или выключать компьютер. Поэтому ядро обязано проводить строгую проверку: корректны ли переданные аргументы (например, не указывает ли буфер в память самого ядра) и имеет ли данный пользователь права на запрашиваемую операцию (например, запись в системный файл). Эта проверка — основа безопасности и стабильности ОС.

### Почему `open()` в ~2000 раз медленнее `getpid()`?

В примере из методички разница составляла ~2000 раз. **Наши замеры показывают разницу поскромнее, но всё равно огромную: `open()` (1560 нс) медленнее `getpid()` (179 нс) в 8.7 раз на горячем кэше**

1.  **Что делает `getpid()`**: Это один из самых простых syscall. Ядру нужно просто прочитать идентификатор процесса (PID) из структуры `task_struct`, которая уже находится в памяти и описывает текущий процесс. Это одна операция чтения из памяти.

2.  **Что делает `open()`**: Это сложный, многоэтапный процесс:

    - **Парсинг пути**: Ядро должно пройти по строке `/tmp/testfile`, отделяя компоненты (`tmp`, `testfile`).
    - **Поиск по файловой системе**: Для каждого компонента ядро обращается к драйверу ФС, чтобы найти соответствующий `inode`.
    - **Проверка прав**: На каждом шаге проверяются права доступа (можно ли войти в директорию `/tmp`? можно ли создать там файл?).
    - **Блокировки**: Ядро использует блокировки, чтобы избежать состояния гонки, если несколько процессов одновременно работают с одним и тем же путём.
    - **Выделение ресурсов**: В случае успеха ядро должно выделить процессу новый файловый дескриптор (число от 3 и выше) и создать для него запись в таблице открытых файлов процесса.
    - **Обращение к диску**: Если данных нет в кэше, ядро инициирует физическую операцию ввода-вывода, что на порядки медленнее работы с ОЗУ.

3.  **Как влияет `page cache`?**: **Наши данные из эксперимента с `drop_caches` это отлично иллюстрируют.** На горячем кэше, когда вся информация о директории `/tmp` уже в памяти, вызов занимает **~1560 нс**. После очистки кэша (`drop_caches`) ядру приходится в первый раз читать метаданные с диска, но это не сильно увеличило время (до ~1771 нс). Это связано с сохранением данных в кэше после первого обращения.

### Что такое vDSO и почему это важно?

1.  **Почему `gettimeofday()` всего в ~10 раз медленнее userspace функции?**: Наши замеры показывают, что `gettimeofday()` (23 нс) всего в 9.4 раза медленнее `dummy()` (2.4 нс), но при этом в 7.8 раз быстрее `getpid()` (179 нс). Это происходит потому, что `gettimeofday()` выполняется через **vDSO (Virtual Dynamic Shared Object)**.

2.  **Как vDSO избегает `context switch`?**: Ядро при запуске процесса отображает в его адресное пространство специальную страницу памяти, содержащую и данные (например, текущее время), и код для их чтения. Вызов `gettimeofday()` из `libc` перенаправляется не на инструкцию `syscall`, а на вызов функции на этой странице. Так как и код, и данные уже в пространстве процесса, вызов выполняется **полностью в user mode**, без дорогостоящего переключения контекста.

3.  **Какие ещё функции могут быть в vDSO?**: `time()`, `getcpu()`. В некоторых конфигурациях ядра через vDSO может быть оптимизирован даже `getpid()`, но, как показывают наши замеры, в данном случае `getpid()` остался полноценным системным вызовом.

1. Context Switches (Переключения контекста)
Количество: 20 переключений на 100,000 итераций

Анализ:

0.02% от общего числа операций - очень низкий показатель

Причина: Большинство операций выполняются в одном контексте процесса

Оптимизация: Современные планировщики минимизируют переключения для CPU-bound задач

2. Page Faults (Страничные нарушения)
Количество: 60 нарушений на 100,000 итераций

Анализ:

0.06% от общего числа операций - минимальное количество

Тип нарушений: В основном minor page faults (выделение памяти)

Отсутствие major faults указывает на эффективное кэширование

3. IPC (Instructions per Cycle)
Значение: 0.80 instructions per cycle

Оценка: НИЗКИЙ IPC-Он означает, что процессор больше простаивал, чем выполнял инструкции. Это характерно для I/O-bound задач, где программа постоянно ждёт завершения медленных операций (в данном случае — системных вызовов).
### Практические выводы

- **Как эти знания помогут оптимизировать код?**
  Главный вывод: **системные вызовы — это дорого**. Для оптимизации I/O-операций нужно минимизировать их количество. Вместо тысячи вызовов `write` по одному байту, нужно собрать мегабайт данных в буфер и сделать один `write`.

- **В каких ситуациях стоит избегать системных вызовов?**
  В любых критичных к производительности циклах (high-performance computing, game loops, обработка сетевых пакетов). Любой syscall в таком цикле немедленно станет "узким горлышком".

- **Когда буферизация важна?**
  **Всегда**, когда речь идёт о вводе-выводе. Буферизация позволяет накопить данные в user-space и совершить один дорогой syscall вместо множества. Именно поэтому стандартные библиотеки (`stdio` в C) всегда используют буферизацию. Это подтвердилось в Задании А, где мы не увидели вызовов `read` у `cat` — `libc` делала это за нас, читая файл большими кусками.

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

Системный вызов — это запрос программы к ядру операционной системы на выполнение привилегированной операции. Его ключевое отличие от обычной функции — **переход между режимами работы процессора**.

- **Обычная функция** выполняется полностью в пространстве пользователя (`user mode`), оперируя только данными своего процесса.
- **Системный вызов** инициирует переключение в пространство ядра (`kernel mode`), где ядро имеет полный доступ ко всем ресурсам системы (файлы, сеть, память). Этот переход необходим для безопасности и стабильности ОС.

### 2. Почему системный вызов медленнее обычной функции?

Системный вызов медленнее из-за высоких накладных расходов на **переключение контекста** (`context switch`) между режимом пользователя и режимом ядра.

Этот процесс включает в себя множество шагов, отсутствующих при вызове обычной функции:

- Сохранение текущего состояния процессора (регистры, указатель стека).
- Переключение на стек ядра.
- Проверка ядром аргументов системного вызова на корректность.
- Выполнение запрашиваемой операции ядром.
- Восстановление состояния пользовательского процесса.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

`LD_PRELOAD` — это переменная окружения, которая даёт инструкцию динамическому компоновщику (`ld.so`) загрузить указанную в ней библиотеку **перед всеми остальными**, включая стандартную библиотеку C (`libc`). Это позволяет эффективно "подменить" оригинальные функции своими реализациями-перехватчиками.

Механизм **не работает** в следующих случаях:

- **Статически скомпонованные программы**: В них нет этапа динамической компоновки при запуске, и `ld.so` не вызывается.
- **Программы с флагами `setuid`/`setgid`**: В целях безопасности ядро игнорирует `LD_PRELOAD` для таких программ, чтобы предотвратить выполнение вредоносного кода с повышенными привилегиями.
- **Прямые системные вызовы**: Если программа использует инструкцию `syscall` напрямую, а не через обёртки в `libc` (такие как `open`, `read`), перехватить вызов с помощью `LD_PRELOAD` невозможно.

### 4. Что такое vDSO и зачем он нужен?

**vDSO (Virtual Dynamic Shared Object)** — это механизм оптимизации, позволяющий выполнять некоторые системные вызовы без дорогостоящего переключения контекста в режим ядра.

Принцип работы:

- Ядро отображает в адресное пространство каждого процесса специальную страницу памяти, которая содержит и данные (например, текущее время), и функции для их чтения.
- Когда программа вызывает такой syscall (например, `gettimeofday()`), стандартная библиотека `libc` вместо реального системного вызова обращается к функции внутри vDSO.
- Эта функция выполняется полностью в `user mode`, напрямую читая данные, которые ядро для неё подготовило. Это так же быстро, как вызов обычной функции.

### 5. Почему open() медленнее getpid() на несколько порядков?

Вызов `open()` медленнее `getpid()` из-за колоссальной разницы в объёме и сложности работы, которую должно выполнить ядро.

- **`getpid()`**: Чрезвычайно быстрая операция. В большинстве случаев она реализуется через **vDSO**, то есть выполняется вообще без входа в ядро. Процесс просто читает свой ID из подготовленной ядром области памяти.
- **`open()`**: Сложный, многоступенчатый процесс, который может включать медленные операции ввода-вывода.
  - **Разбор пути**: Ядро должно пройти по каждому компоненту пути к файлу.
  - **Проверка прав доступа**: На каждом шаге проверяются права пользователя.
  - **Обращение к файловой системе**: Ядро взаимодействует с драйвером ФС.
  - **Дисковый ввод-вывод**: Если нужные данные не в кэше, происходит обращение к физическому диску, что на порядки медленнее доступа к ОЗУ.
  - **Выделение ресурсов**: Ядро должно выделить файловый дескриптор и другие структуры данных.

### 6. (Для задания C) Почему ptrace() так сильно замедляет программу?

Системный вызов `ptrace()` (основа `strace` и `gdb`) кардинально замедляет программу, потому что он принудительно останавливает её выполнение **дважды на каждый системный вызов**.

Этот механизм приводит к "буре" переключений контекста:

- **Остановка на входе (Syscall-Entry Stop)**: Перед выполнением системного вызова ядро останавливает программу и передаёт управление отладчику (`tracer`).
- **Остановка на выходе (Syscall-Exit Stop)**: После выполнения системного вызова ядро снова останавливает программу и отдаёт управление отладчику для анализа результата.
- **Двойные переключения**: Каждый из этих двух шагов требует минимум двух переключений контекста (с программы на отладчик и обратно), что в сумме даёт огромное замедление.

## Общие выводы

### Что нового узнали о работе syscalls?

Эта лабораторная работа позволила на практике увидеть и измерить то, что часто остаётся теорией. Мы узнали, что разница в производительности между вызовом функции, vDSO и системными вызовами огромна и измеряется десятками и сотнями раз. Стало очевидно, что даже простые утилиты (`grep`, `ls`) имеют неочевидную внутреннюю логику: `grep` анализирует собственную память, а `ls` использует не стандартные `open`/`read`, а более специфичные syscalls. Наконец, эксперименты наглядно продемонстрировали мощь буферизации ввода-вывода.

### Какие инструменты показались наиболее полезными?

- **`perf stat`**: Оказался самым мощным инструментом для анализа. Он не просто измеряет время, а даёт глубокое понимание происходящего: соотношение времени `user`/`sys` сразу показывает, где выполняется основная работа, а низкий IPC прямо указывает на "бутылочное горлышко" в виде ожидания I/O.
- **`LD_PRELOAD`**: Очень полезный и гибкий механизм для отладки и "исследования" программ без необходимости иметь их исходный код. Позволил заглянуть "под капот" стандартных утилит.
- **`__rdtsc()`**: Для микро-бенчмарков это идеальный инструмент, дающий точность до такта процессора.

### Какие трудности возникли?
Сложно было интерпретировать результаты.Также было достаточно муторно возиться с кодом.
### Как понимание границы userspace↔kernel поможет в дальнейшем изучении Linux?

Это фундаментальное знание. Оно лежит в основе:

- **Оптимизации производительности**: Теперь при анализе медленной программы первый вопрос будет: "Не упирается ли она в системные вызовы?".
- **Проектирования систем**: Понимание цены I/O заставляет с самого начала закладывать в архитектуру правильные паттерны (буферизация, асинхронность, batching).
- **Безопасности**: Осознание того, что ядро — это строгий контролёр, даёт понимание, как работают права доступа, `capabilities` и механизмы вроде `seccomp`.
- **Дальнейшего обучения**: Это необходимая база для изучения более сложных тем, таких как eBPF, работа с сетью на низком уровне, разработка драйверов или модулей ядра.

## Использование AI
AI использовался для написания программ и генерации отчёта.