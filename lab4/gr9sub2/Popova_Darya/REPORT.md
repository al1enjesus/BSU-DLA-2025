# Лабораторная 4 — Системные вызовы: граница между программой и ядром

Курс: Проектирование приложений под Linux (DLA, 4 курс)

Номер в журнале: 20
Номер в списке % 4 = 0 → программы для анализа (задание A): ls, cat, grep

Цель работы: исследовать механизм системных вызовов в Linux, реализовать перехват вызовов через LD_PRELOAD, измерить накладные расходы системных вызовов и проанализировать полученные данные.

* Среда: виртуальная машина

Содержимое репозитория (структура):

```
lab4/
  gr<группа>sub<подгруппа>/
    ФАМИЛИЯ_ИМЯ/
      REPORT.MD
      README.md
      src/
        syscall_spy.c
        benchmark.c
      Makefile
      logs/
        ls.log
        cat.log
        grep.log
```

1. Сборка и запуск (коротко)

* Сборка библиотеки:
  gcc -shared -fPIC -o libsyscall_spy.so src/syscall_spy.c -ldl
* Сборка бенчмарка:
  make (или gcc -O2 -o benchmark src/benchmark.c)
* Запуск перехвата:
  LD_PRELOAD=./libsyscall_spy.so ls -la > /dev/null 2> logs/ls.log
  LD_PRELOAD=./libsyscall_spy.so cat /etc/hosts > /dev/null 2> logs/cat.log
  LD_PRELOAD=./libsyscall_spy.so grep -R "main" /usr/include > /dev/null 2> logs/grep.log
* Запуск бенчмарка:
  ./benchmark > logs/benchmark.log

2. Описание реализованного кода

syscall_spy.c

* Перехватываются функции: open, openat, read, write, close.
* Для open/openat декодируются флаги (O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_TRUNC, O_APPEND).
* Для write при записи в stdout (fd 1) и небольшом размере буфера выводится содержимое (ограничено).
* Логи пишутся на stderr, чтобы основная программа могла работать как обычно; при логировании в write стоит исключение для fd=2 (stderr) чтобы избежать рекурсии.
* Оригинальные функции вызываются через dlsym(RTLD_NEXT, "...").

benchmark.c

* Выполняется ITERATIONS = 1 000 000 итераций:

  * Измерение времени выполнения syscall SYS_getpid через syscall(SYS_getpid) с использованием clock_gettime(CLOCK_MONOTONIC).
  * Измерение времени выполнения простой функции (volatile increment) с тем же методом.
* В конце выводятся средние значения времени в наносекундах для syscall и для функции.

Makefile

* Цель all: собирает benchmark.
* Цель run: запускает benchmark.
* CFLAGS = -Wall -O2.

3. Эксперимент A — LD_PRELOAD (перехват)

Цель: получить полные логи системных вызовов, сгенерированные библиотекой spy, для программ ls, cat, grep.

Команды для воспроизведения:
LD_PRELOAD=./libsyscall_spy.so ls -la > /dev/null 2> logs/ls.log
LD_PRELOAD=./libsyscall_spy.so cat /etc/hosts > /dev/null 2> logs/cat.log
LD_PRELOAD=./libsyscall_spy.so grep -R "main" /usr/include > /dev/null 2> logs/grep.log

Ожидаемые элементы логов:
[SPY] openat(AT_FDCWD, "/etc/ld.so.cache", flags=O_RDONLY) = 3
[SPY] read(fd=3, buf=0x..., count=832) = 832
[SPY] close(fd=3) = 0
[SPY] openat(AT_FDCWD, ".", flags=O_RDONLY|O_NONBLOCK) = 3

Комментарии по интерпретации:

* `ls` обычно делает много openat() для чтения директорий и файлов, mmap/fstat для метаданных, read для чтения каталогов (getdents), write для вывода на stdout.
* `cat` — минимум открытий (одно открытие файла), много read() и write() (чтение файла и вывод).
* `grep` при рекурсивном поиске (`-R`) делает много openat() и read() — будет много файлов и буферных операций.

Проверка на статически слинкованной программе:

* gcc -static -o hello_static hello.c
* LD_PRELOAD=./libsyscall_spy.so ./hello_static
  Ожидаемый результат: перехвата не будет (линейная загрузка библиотек происходит при статическом связывании — LD_PRELOAD не работает).

Обоснование: LD_PRELOAD действует на динамическую загрузку библиотек: динамический загрузчик помещает указанные библиотеки в цепочку разрешения символов. В статически слинкованных исполняемых файлах все функции libc уже встроены, поэтому заменить символы через динамический линкер нельзя.

4. Эксперимент B — Benchmark системных вызовов

Методика

* Для корректности измерений необходимо:

  * Запустить с governor = performance или убедиться, что CPU не снижает частоту в ходе измерений.
  * Сделать warmup (первые N итераций отбросить), чтобы исключить эффекты cold cache.
  * Использовать clock_gettime(CLOCK_MONOTONIC) с nanosecond resolution (как в коде).
  * Обратить внимание: clock_gettime сама может использовать vDSO и не производить syscall; это хорошо — методика измеряет время блока кода, а не накладные расходы измерителя.

Команда:
./benchmark > logs/benchmark.log

Вывод:
Benchmarking system calls vs regular functions
Average syscall time: <A> ns
Average regular function time: <B> ns

Интерпретация результатов

* Ожидаемый результат: среднее время syscall значительно больше времени простой функции в userspace. Типично getpid через syscall может занимать от сотен до нескольких сотен наносекунд на современной системе, тогда как простая инкрементация — единицы или десятки наносекунд.
* Отношение (A / B) показывает, во сколько раз системный вызов медленнее функции.


* Почему syscall медленнее:

  * Переключение контекста привода (user → kernel → user), сохранение/восстановление регистров, проверка прав, обработка со стороны ядра.
* Почему getpid быстрее open:

  * getpid просто читает значение в структуре процесса (в ядре/в кэше) — минимальная работа.
  * open требует парсинга пути, взаимодействия с файловой системой, возможно доступ к диску/metadata — намного больше операций.
* Что такое vDSO:

  * vDSO — область памяти, предоставленная ядром процессу, в которой реализованы часто используемые функции (например, gettimeofday) без перехода в ядро; это даёт ускорение для таких вызовов.
* Анализ perf stat:

  * Контекстные переключения на миллион итераций могут быть не равны 1 000 000 — perf покажет реальные значения; в отчёте интерпретировать эти числа.

6. Ответы на обязательные вопросы (формат для вставки в отчет)

7. Что такое системный вызов и чем он отличается от обычной функции?
   Системный вызов — это механизм, с помощью которого процесс запрашивает услуги у ядра операционной системы (например, доступ к файловой системе, создание процесса, сетевые операции). В отличие от обычной функции в пользовательском пространстве, системный вызов приводит к переходу в привилегированный режим (kernel mode), где выполняется код ядра с доступом к аппаратуре и защищённым ресурсам. Это обеспечивает безопасность и контроль, но добавляет накладные расходы.

8. Почему системный вызов медленнее обычной функции?
   Потому что происходит переключение из user mode в kernel mode и обратно, требуется сохранение и восстановление контекстов, дополнительные проверки прав доступа, выполнение кода ядра и возможно доступ к внешним устройствам. Все эти операции стоят процессорного времени и увеличивают задержку.

9. Как работает LD_PRELOAD и в каких случаях он НЕ работает?
   LD_PRELOAD указывает динамическому загрузчику подгрузить указанные .so-библиотеки первыми и использовать их символы при разрешении. Не работает на статически слинкованных бинарниках, а также может быть отключён для безопасных механизмов (например, setuid/setgid исполняемые файлы или sudo обычно игнорирует LD_PRELOAD).

10. Что такое vDSO и зачем он нужен?
    vDSO — виртуальная библиотека, предоставляемая ядром в адресное пространство процесса, реализующая некоторые часто вызываемые функции (например, gettimeofday, clock_gettime) на стороне пользователя, избегая перехода в ядро. Это снижает накладные расходы для частых запросов времени.

11. Почему open() медленнее getpid() на несколько порядков?
    getpid — простая операция чтения уже известного PID процесса; open() включает разбор пути, запросы к файловой системе, проверку прав доступа, работу с inode / dentry, возможные обращения к диску и блокировки. Поэтому open требует многократных операций в ядре и работе с подсистемой файлов, что существенно медленнее.

12. Выводы и практические рекомендации

* Для микропроизводительности важно минимизировать число системных вызовов; буферизация операций ввода-вывода и агрегация операций (batching) помогают снизить накладные расходы.
* vDSO и использование пользователейpace-оптимизаций (например, mmap вместо множества read) дают выигрыш.
* LD_PRELOAD — удобный инструмент для динамического мониторинга и инструментов отладки, но не годится для статических бинарников.
* ptrace/strace очень полезны, но дорого стоят в плане производительности (каждый syscall может кардинально замедляться при трассировке).

