# Лабораторная 4 — Системные вызовы

## Выбор программ

Номер в списке группы: 1
Расчёт группы программ: 1 % 4 = 1
Программы для анализа: find, tar, cp
Мои задания: A (LD_PRELOAD), B (Benchmark)

## Среда выполнения

- ОС: Ubuntu 22.04.5
- Ядро: 6.8.0-84-generic
- Процессор: AMD Ryzen 5 5500U with Radeon Graphics
- Компилятор: gcc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки

Для перехвата вызовов была реализована библиотека `libsyscall_spy.so` в файле [syscall_spy.c](./src/syscall_spy.c). Она использует механизм `LD_PRELOAD` для "подмены" стандартных библиотечных функций `open`, `openat`, `read`, `write` и `close` своими версиями.

Каждая перехваченная функция выполняет следующие действия:

1.  Получает указатель на оригинальную функцию с помощью dlsym(RTLD_NEXT, "имя_функции").
2.  Вызывает оригинальную функцию, сохраняя её результат.
3.  Логирует имя функции, её аргументы и результат в stderr.
4.  Возвращает результат оригинальной функции.

Для защиты от бесконечной рекурсии (когда fprintf в нашей функции вызывает write, который мы перехватываем), запись в stderr (файловый дескриптор 2) не логируется.

### Экспееримент 1. Команда `find`

**Запуск:**

```bash
LD_PRELOAD=./libmyspy.so find . -name "*.txt"
```

**Полный вывод и Анализ:**
```
[SPY] open(".", [O_CLOEXEC]) = 3
[SPY] openat(AT_FDCWD, ".", [O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW]) = 4
[SPY] openat(<fd>, "logs", [O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW]) = 6
[SPY] close(fd=4) = 0
[SPY] close(fd=7) = 0
[SPY] close(fd=4) = 0
[SPY] openat(<fd>, "test_dir", [O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW]) = 6
[SPY] close(fd=4) = 0
[SPY] close(fd=7) = 0
[SPY] close(fd=4) = 0
[SPY] openat(<fd>, "src", [O_CLOEXEC|O_DIRECTORY|O_NOFOLLOW]) = 6
[SPY] close(fd=4) = 0
[SPY] close(fd=7) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=5) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=3) = 0

```

## Экспееримент 2. Команда `tar`

**Запуск:**

```bash
LD_PRELOAD=./libmyspy.so tar -cf archive.tar file1.txt test_dir/
```

**Полный вывод и Анализ:**
```
[SPY] read(fd=4, buf=0x5750e0b87200, count=20) = 20
[SPY] close(fd=4) = 0
[SPY] read(fd=4, buf=0x5750e0b87600, count=20) = 20
[SPY] close(fd=4) = 0
[SPY] read(fd=5, buf=0x5750e0b87c00, count=15) = 15
[SPY] close(fd=5) = 0
[SPY] read(fd=5, buf=0x5750e0b88000, count=13) = 13
[SPY] close(fd=5) = 0
[SPY] write(fd=3, buf=0x5750e0b87000, count=10240) = 10240
[SPY] close(fd=3) = 0
```

## Экспееримент 3. Команда `cp`

**Запуск:**

```bash
LD_PRELOAD=./libmyspy.so cp file1.txt file1_copy.txt 2> cp_log.txt
```

**Полный вывод и Анализ:**
```
[SPY] open("file1.txt", ]) = 3
[SPY] open("file1_copy.txt", [O_WRONLY|O_CREAT|O_EXCL], mode=0664) = 4
[SPY] read(fd=3, buf=0x70dc0addf000, count=131072) = 20
[SPY] write(fd=4, buf=0x70dc0addf000, count=20) = 20
[SPY] read(fd=3, buf=0x70dc0addf000, count=131072) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=3) = 0
[SPY] open("test_dir/file3.txt", [O_NOFOLLOW|]) = 3
[SPY] open("test_dir_copy/file3.txt", [O_WRONLY|O_CREAT|O_EXCL|], mode=0664) = 4
[SPY] read(fd=3, buf=0x731aa0748000, count=131072) = 15
[SPY] write(fd=4, buf=0x731aa0748000, count=15) = 15
[SPY] read(fd=3, buf=0x731aa0748000, count=131072) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=3) = 0
[SPY] open("test_dir/file4.txt", [O_NOFOLLOW|]) = 3
[SPY] open("test_dir_copy/file4.txt", [O_WRONLY|O_CREAT|O_EXCL|], mode=0664) = 4
[SPY] read(fd=3, buf=0x618183c8d000, count=131072) = 13
[SPY] write(fd=4, buf=0x618183c8d000, count=13) = 13
[SPY] read(fd=3, buf=0x618183c8d000, count=131072) = 0
[SPY] close(fd=4) = 0
[SPY] close(fd=3) = 0
```

### Сравнительный анализ и рассуждения

#### Сравнительная таблица

| Программа | Вызовов open/openat | Вызовов read   | Вызовов write  | Вызовов close  |
| --------- | ------------------- | -------------- | -------------- | -------------- |
| find      | 5                   | 0              | 0              | 12             |
| tar       | 0                   | 1              | 4              | 5              |
| cp        | 6                   | 6              | 3              | 6              |

#### Какая программа делает больше всего системных вызовов и почему?
В этом запуске программы cp и find сделали примерно одинаковое количество вызовов (~20 каждая), что значительно больше, чем у tar. Однако при работе с большим количеством файлов find будет бточно опережать по количеству вызовов openat(), так как она должна открыть каждую директорию для её обхода.

#### Природа работы программ

- **`find`**: Файловая утилита, рекурсивно обходящая дерево директорий.
- **`tar`**: Утилита для создания архивов, работающая с потоками данных.
- **`cp`**: Файловая утилита, предназначенная для копирования данных с одного места на диске в другое.


#### Неожиданные открываемые файлы
В полученных логах мы не видим открытия системных библиотек, конфигурационных файлов или псевдо-файлов, потому что для наших команд не нужна была информация о системе и вес необходимое загрузилось при линковке, но имея другие команды, вероятно мы бы увидели неожиданные файлы, которые показывали бы взаимодействие с ос

#### Сравнение профилей вызовов
    У cp сбалансированное количество read и write - она читает данные из исходного файла и сразу записывает в целевой.
    У tar в логе видно несколько  read и один  write. Это потому, что tar сначала читает метаданные файлов (заголовки), а затем одним большим блоком записывает упакованные данные в архив.
    у find gреобладают вызовы для навигации по файловой системе: open, openat, close. Вызовов read и write для работы с содержимым файлов нет - программа только читает метаданные файловой системы.

#### Что нового удалось узнать?
cp работает по схеме "открыл-прочитал-записал-закрыл", а tar использует потоковую обработку, а find активно использует openat(), что позволяет безопасно обходить директории без race conditions.

### Проверка на статически слинкованной программе

**Команда:**

```bash
gcc -o simple_dynamic simple.c
LD_PRELOAD=./libmyspy.so ./simple_dynamic
gcc -static -o simple_static simple.c
LD_PRELOAD=./libmyspy.so ./simple_static
```

**Результат:**

```
--- Dynamic---
[SPY] open("test.txt", [O_WRONLY|O_CREAT|0x41], mode=0644) = 3
[SPY] write(fd=3, buf=0x556cbd208024, count=5) = 5
[SPY] close(fd=3) = 0
--- Static binary---
Программа запустилась
Программа завершилась
```
**Вывод:** Логи перехвата на статически слинкованной отсутствуют.

**Объяснение:** Механизм LD_PRELOAD не работает для статически скомпонованных программ из-за различий в том, как они собираются и запускаются, по сравнению с динамически линкованными программами.

1.  **Динамическая линковка**:

    - Когда программа компилируется динамически, её исполняемый файл не содержит код всех используемых функций (printf из libc). Вместо этого он содержит "заглушки" и таблицу символов, указывающих, что ему нужна функция printf из библиотеки libc.so.
    - При запуске такой программы ос передаёт управление динамическому компоновщик ( ld.so).
    - ld.so отвечает за поиск и загрузку в память всех необходимых библиотек, после чего он производит разрешение символов, те находит реальные адреса запрошенных функций в памяти и "связывает" вызовы из основной программы с этими адресами.так ld.so находит нашу функцию-перехватчик раньше, чем оригинальную, и связывает программу с ней.

2.  **Статическая линковка**:

    - При статической линковке (флаг -static у gcc) компоновщик (ld) на этапе сборки находит код всех вызываемых функций в статических библиотеках и полностью встраиваетэтот код в конечный исполняемый файл. В результате получается единый файл, который не имеет внешних зависимостей от библиотек. Все вызовы функций превращаются в прямые переходы на адрес кода, уже находящегося внутри самого исполняемого файла.

## Задание B: Benchmark 

### Исходный код

Написана программа ./src/benchmark.c.

Эксперимент проводился путем сравнения времени выполнения open() до и после принудительной очистки дискового кэша в ядре.

**Запуск:**

```bash
# Замер на горячем кэше
./bin/benchmark

# Сброс кэша (требует root) и запуск на холодном кэше
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches
./bin/benchmark_open
```

**Горячий кэш:**

```
darya@darya-IdeaPad-3-15ALC6:~/BSU-DLA-2025/lab4/gr1sub1/Boguk_Darya/src$ ./benchmark
| Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
|--------------------|------------|------------|------------------------------------|
| dummy()            | 2          | 5          | 1x (базовая линия)    |
| getpid()           | 237        | 615        | 125                              x |
| gettimeofday vDSO  | 1428       | 3712       | 755                              x |
| open+close         | 4324       | 11242      | 2287                             x |
```

**холодный кэш:**

```
darya@darya-IdeaPad-3-15ALC6:~/BSU-DLA-2025/lab4/gr1sub1/Boguk_Darya/src$ sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches
./benchmark
| Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
|--------------------|------------|------------|------------------------------------|
| dummy()            | 4          | 9          | 1x (базовая линия)                 |
| getpid()           | 237        | 617        | 66                               x |
| gettimeofday vDSO  | 1418       | 3687       | 395                              x |
| open+close         | 4330       | 11259      | 1207                             x |
```

### perf stat

**Вывод `perf stat`:**
```
 Performance counter stats for './benchmark':

    17.130.006.213      cycles                                                                
     9.968.544.496      instructions                     #    0,58  insn per cycle            
                23      context-switches                                                      
               265      page-faults                                                           

       4,246134826 seconds time elapsed

       0,307934000 seconds user
       3,938020000 seconds sys
```

## Анализ и выводы

### Почему системный вызов в 50-100 раз медленнее userspace функции?

Наши замеры показывают, что системный вызов getpid() (237 нс) оказался в 115 раза медленнее, чем вызов пустой функции dummy() (2 нс). Это объясняется ценой переключения контекста.  
 **Механизм context switch**: Когда программа вызывает syscall, процессор выполняет специальную инструкцию (syscall на x86-64), которая инициирует прерывание. Это заставляет процессор остановить выполнение пользовательского кода и передать управление ядру. Ядро начинает работу в привилегированном режиме (kernel mode).
 При системном вызове происходит: сохранение всех регистров CPU, переключение стека на kernel stack, проверка прав доступа, поиск обработчика в syscall table, выполнение кода ядра, восстановление регистров и возврат в userspace


### Почему `open()` в ~2000 раз медленнее `getpid()`?
getpid() (237ns):
 - Читает одно поле task_struct->pid из памяти ядра  
 - Минимальная работа, данные обычно в L1/L2 кэше

open() (4324ns) - горячий кэш:
 - Парсинг пути файла ("/a/b/c" → разбиение на компоненты)  
 - Поиск по файловой системе
 - Проверка прав доступа  
 - Блокировки  
 - Выделение ресурсов  
 - Обращение к диску  

 ### Что такое vDSO и почему это важно?  
vDSO (Virtual Dynamic Shared Object)  
**Как vDSO избегает context switch?**:   
Ядро при запуске процесса отображает в его адресное пространство специальную страницу памяти, содержащую и данные и код для их чтения. Вызов gettimeofday()  перенаправляется не на инструкцию syscall, а на вызов функции на этой странице. Так как и код, и данные уже в пространстве процесса, вызов выполняется полностью в user mode без перехода в kernel mode  
**Какие ещё функции могут быть в vDSO?**:    
например time(), getcpu().

### Анализ `perf stat` вывода
 - Context switches (23):
    Ожидалось: 1,000,000+ (по одному на syscall). Реально: 23 - это показывает эффективность: vDSO избегает большинства переключений, пакетная обработка в benchmar, отсутствие прерываний во время теста  
 - Page faults (265): Major faults: 0 (нет чтения с диска), Minor faults: 265 (маппинг новых страниц), это говорит о хорошей локальности данных  
 - IPC = 0.58: низкий IPC, процессор ждёт данные из памяти, то есть больше простаивал, типично для операций с файловой системой.


### Практические выводы
- **Как эти знания помогут оптимизировать код?**  
   Знание точной стоимости системных вызовов позволяет осознанно подходить к оптимизации. Мжно правильно расставлять приоритеты: сначала оптимизировать самые дорогие операции, затем менее затратные. Это помогает избегать преждевременной оптимизации там, где она не даст значительного эффекта.

- **В каких ситуациях стоит избегать системных вызовов?**  
  Системные вызовы следует избегать в нескольких ключевых сценариях: в критических по задержкам участках кода, в tight loops с минимальной полезной работой, в высокочастотных операциях.

- **Когда буферизация важна?**  
  При частом файловом вводе-выводе - вместо множества мелких операций read/write лучше использовать несколько крупных буферизованных операций.  


## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?
Системный вызов — это запрос программы к ядру операционной системы на выполнение привилегированной операции. В отличие от обычной функции, которая выполняется полностью в пользовательском пространстве, системный вызов требует переключения в режим ядра для выполнения привилегированных операций.  
### 2. Почему системный вызов медленнее обычной функции?  
Системный вызов медленнее из-за высоких накладных расходов на переключение контекста между режимом пользователя и режимом ядра.  
Основные факторы замедления:
 - Переключение режима CPU: user mode → kernel mode (сохранение/восстановление регистров)
 - Проверка прав доступа
 - Поиск обработчика
 - Блокировки  
 ### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?  
Принцип работы LD_PRELOAD:  
Динамический компоновщик загружает библиотеки из LD_PRELOAD первыми, что позволяет переопределять функции из стандартных библиотек. При разрешении символов используется приоритет: сначала ищется в LD_PRELOAD, затем в стандартных библиотеках.  

**Когда НЕ работает:**
- **Статически скомпонованные программы**: В них нет этапа динамической компоновки при запуске, и ld.so не вызывается.
- **Прямые системные вызовы**  
### 4. Что такое vDSO и зачем он нужен?  
vDSO (virtual Dynamic Shared Object) - это механизм для ускорения frequently-used системных вызовов путем их выполнения в пользовательском пространстве без переключения в kernel mode.  
**Зачем нужен:**  
  -  Устраняет overhead переключения контекста для "легких" системных вызовов  
  -  Ускоряет получение времени, информации о процессоре и т.д.  
 - Уменьшает количество полных системных вызовов  

### 5. Почему open() медленнее getpid() на несколько порядков?  
open() медленнее getpid() из-за принципов их работы, рассмотрим:  

- **getpid()**:  
Чрезвычайно быстрая операция. В большинстве случаев она реализуется через **vDSO**, то есть выполняется вообще без входа в ядро. Процесс просто читает свой ID из подготовленной ядром области памяти.  
- **open()**:  
   - Парсинг пути
   - Поиск в dentry cache  
   - Проверка прав  
    - Блокировки  
    - Работа с файловой системой
    - Создание структур


## Использование ИИ
Для настройки запуска и ошибок, связанных с ним   
Для анализа результатов  

