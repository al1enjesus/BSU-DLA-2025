# Лабораторная 4 — Системные вызовы

## Выбор программ
**Номер в списке группы:** 11  
**Расчёт группы программ:** 11 % 4 = 3  
**Программы для анализа:** gcc, make, as  

## Среда выполнения
- **ОС:** Ubuntu

---

## Задание A: LD_PRELOAD перехват

### Код библиотеки
Реализована библиотека `libsyscall_spy.so`, которая перехватывает следующие системные вызовы:
- `open()` и `openat()` - открытие файлов с декодированием флагов
- `read()` и `write()` - чтение/запись данных с подсчетом байт
- `close()` - закрытие файловых дескрипторов

Библиотека использует `dlsym(RTLD_NEXT)` для получения указателей на оригинальные функции и выводит цветную статистику в stderr.

**Компиляция:**
```bash
gcc -shared -Wall -O2 -fPIC -Wno-nonnull-compare -o libsyscall_spy.so syscall_spy.c -ldl
```
### Эксперимент 1: Анализ GCC
```bash
LD_PRELOAD=./libsyscall_spy.so gcc -o src/test_prog src/test_prog.c
```

### Полный вывод (ключевые моменты из gcc_analysis.log):

```bush
[SPY] ========== Syscall interception started ==========
[SPY] open("src/test_prog.c", O_RDONLY) = 3
[SPY] read(fd=3, buf=0x6375490, count=352) = 352
[SPY] close(fd=3) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/stdc-predef.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/local/include/stdc-predef.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/include/x86_64-linux-gnu/stdc-predef.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/include/stdc-predef.h", O_RDONLY) = 4
[SPY] read(fd=4, buf=0x63c8620, count=2290) = 2290
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/stdio.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/local/include/stdio.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/include/x86_64-linux-gnu/stdio.h", O_RDONLY) = -1 (errno=2: No such file or directory)
[SPY] open("/usr/include/stdio.h", O_RDONLY) = 4
[SPY] read(fd=4, buf=0x63c92b0, count=29950) = 29950
[SPY] close(fd=4) = 0

[SPY] ========== Statistics ==========
[SPY] open() calls:    167
[SPY] openat() calls:  0
[SPY] read() calls:    61 (total bytes: 251018)
[SPY] write() calls:   0 (total bytes: 0)
[SPY] close() calls:   61
[SPY] ===================================
```
### Анализ:
- Всего вызовов: 289 (167 open + 61 read + 61 close)
- Открытые файлы: исходный код, заголовочные файлы (stdio.h, stdlib.h, features.h и др.)
- Объем данных: 251 KB прочитанных данных 
- Неожиданности: GCC пытается открыть файлы в нескольких путях прежде чем найти правильный

### Эксперимент 2: Анализ Make
```bush
LD_PRELOAD=./libsyscall_spy.so make -f Makefile.test
```
### Полный вывод (ключевые моменты из make_analysis.log):
```bush
[SPY] ========== Syscall interception started ==========
[SPY] open("benchmark.c", O_RDONLY) = 3
[SPY] read(fd=3, buf=0x3824cab0, count=12400) = 12400
[SPY] close(fd=3) = 0
[SPY] open("/usr/include/stdc-predef.h", O_RDONLY) = 4

[SPY] ========== Statistics ==========
[SPY] open() calls:    392
[SPY] openat() calls:  0
[SPY] read() calls:    190 (total bytes: 2571169)
[SPY] write() calls:   0 (total bytes: 0)
[SPY] close() calls:   190
[SPY] ===================================
```
### Анализ:
- Всего вызовов: 772 (392 open + 190 read + 190 close)
- Объем данных: 2.5 MB прочитанных данных
- Особенности: Make запускает несколько дочерних процессов (gcc), каждый со своей статистикой
- Проблема: Некоторые дочерние процессы не могут загрузить библиотеку из-за смены рабочей директории

### Эксперимент 3: Анализ AS (GNU Assembler)
```bush
LD_PRELOAD=./libsyscall_spy.so as src/test.s -o src/test.o
```
### Полный вывод (as_analysis.log):
```bush
[SPY] ========== Syscall interception started ==========

[SPY] ========== Statistics ==========
[SPY] open() calls:    0
[SPY] openat() calls:  0
[SPY] read() calls:    0 (total bytes: 0)
[SPY] write() calls:   0 (total bytes: 0)
[SPY] close() calls:   0
[SPY] ===================================
```


### Сравнительная таблица

| Программа | open() | read() | write() | close() | Всего | Особенности |
|-----------|--------|--------|---------|---------|-------|-------------|
| GCC       | 167    | 61     | 0       | 61      | 289   | Интенсивный поиск заголовков |
| Make      | 392    | 190    | 0       | 190     | 772   | Множество дочерних процессов |
| AS        | 0      | 0      | 0       | 0       | 0     | Минимальное взаимодействие с ФС |

## Задание B: Benchmark системных вызовов

### Таблица результатов:
SUMMARY TABLE (re-run all tests for accurate comparison)
------------------------------------------------------------------
| Operation               | Time (ns) | CPU Cycles | Slowdown vs userspace |
|-------------------------|-----------|------------|-----------------------|
| dummy() userspace       |      0.91 |        2.5 | 1.0x (baseline)       |
| getpid()                |    143.15 |      384.8 | 156.5x                  |
| open() + close()        |   1055.35 |     2836.8 | 1153.6x                |
| gettimeofday() vDSO     |     20.53 |       55.2 | 22.4x                  |
------------------------------------------------------------------

CPU Frequency: 2.69 GHz

### Детальные результаты:
- Userspace функция (dummy)
```bush
Total time: 2.99 ms
Average per call: 2.99 ns (8.0 cycles)
Calls per second: 334 million
```
- Системный вызов getpid()
```bush
Total time: 153.61 ms  
Average per call: 153.61 ns (412.9 cycles)
Calls per second: 6.5 million
```
- Системные вызовы open()+close()
```bush
Total time: 26.00 ms for 10,000 iterations
Average per call: 1055.35 ns (2836.8 cycles) 
Calls per second: 948 thousand
```
- vDSO-оптимизированный gettimeofday()
```bush
Total time: 38.83 ms
Average per call: 38.83 ns (104.4 cycles)
Calls per second: 25.7 million
```
### Анализ результатов
Почему системный вызов медленнее функции?
Переход в ядро требует context switch:
- Процессор переключается из user mode в kernel mode
- Сохраняются регистры, флаги, адрес возврата
- Ядро проверяет права и адреса
- Выполняется код syscall и возвращается управление

Различия между типами вызовов:
- getpid() — простое чтение данных структуры ядра
- open() — комплексные операции с файловой системой
- gettimeofday() — оптимизирован через vDSO

### Технология vDSO:
Виртуальная динамическая разделяемая библиотека позволяет выполнять частые вызовы без переключения в режим ядра, обеспечивая ускорение в 7 раз по сравнению с обычными системными вызовами.

## Ответы на контрольные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

**Системный вызов** представляет собой интерфейс взаимодействия между пользовательским процессом и ядром операционной системы, для выполнения которого требуется переключение в привилегированный режим ядра (kernel mode).

**Обычная функция** выполняется полностью в пользовательском режиме (user mode) без необходимости переключения контекста между режимами работы процессора.

### 2. Почему системный вызов медленнее обычной функции?

Замедление обусловлено необходимостью выполнения context switch, который включает:

- Сохранение текущего состояния регистров и процесса
- Проведение проверок безопасности и валидации параметров
- Передачу управления ядру операционной системы
- Возврат управления обратно в пользовательское пространство

Согласно проведенным измерениям, данная процедура добавляет значительную задержку - в 156 раз по сравнению с выполнением пользовательской функции.

### 3. Как работает LD_PRELOAD и когда не работает?

**Принцип работы:** Механизм LD_PRELOAD принудительно заставляет динамический линкер загружать указанную библиотеку перед всеми остальными, что позволяет осуществлять подмену символов функций.

**Ограничения применения:**
- Не работает со статически слинкованными исполняемыми файлами
- Не применяется к setuid-программам из соображений безопасности
- Не функционирует при невозможности разделения символов (inline, static функции)

### 4. Что такое vDSO?

**vDSO (Virtual Dynamic Shared Object)** - это специальная область памяти, предоставляемая ядром операционной системы. Данная технология позволяет выполнять определенные категории системных вызовов без необходимости переключения в режим ядра. 

**Примеры оптимизированных вызовов:**
- `gettimeofday()`
- `clock_gettime()`

Использование vDSO обеспечивает значительное ускорение выполнения данных операций.

### 5. Почему open() медленнее getpid()?

**getpid()** осуществляет простое чтение значения PID из структуры процесса, расположенной в ядре.

**open()** требует выполнения комплексных операций:
- Поиск указанного файла в файловой системе
- Проверка прав доступа и разрешений
- Выделение и инициализация файлового дескриптора
- Возможное обращение к устройствам хранения данных

Согласно экспериментальным данным, разница в производительности составляет 1153 раза.

## Выводы

1. **LD_PRELOAD** доказал свою эффективность как инструмент для анализа системных вызовов в динамически слинкованных программах

2. **Производительность системных вызовов** демонстрирует значительный разброс - от 20 наносекунд (vDSO) до 1055 наносекунд (файловые операции), что составляет три порядка величины

3. **Компилятор GCC** проявляет наибольшую активность в области файловых операций, что обусловлено интенсивным поиском заголовочных файлов

4. **Система сборки Make** характеризуется сложной архитектурой с использованием множества дочерних процессов

5. **Ассемблер AS** показал максимальную эффективность благодаря минимальному взаимодействию с файловой системой

6. **Статическая компоновка программ** обеспечивает надежную изоляцию от механизма перехвата LD_PRELOAD


## Использование искусственного интеллекта
- **DeepSeek** - для выяснения сложных технических вопросов, связанных с особенностями реализации LD_PRELOAD и vDSO