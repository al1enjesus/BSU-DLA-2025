# Лабораторная 4 — Системные вызовы

## Выбор программ
Номер в списке группы: 11  
Расчёт группы программ: 11 % 4 = 3  
Программы для анализа: gcc, make, as  
Мои задания: A (LD_PRELOAD), B (Benchmark) — обязательные, C* (ptrace) — опционально

## Среда выполнения
- ОС: Ubuntu 20.04.6 LTS (WSL2)
- Ядро: 6.6.87.2-microsoft-standard-WSL2
- Процессор: Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
- Компилятор: gcc 9.4.0

---

## Задание A: LD_PRELOAD перехват
**(Обязательно для всех)**

### Код библиотеки
Реализована библиотека `libsyscall_spy.so`, которая перехватывает функции:
- `open()` и `openat()` — открытие файлов с декодированием флагов
- `read()` и `write()` — чтение/запись данных
- `close()` — закрытие дескрипторов

Использует `dlsym(RTLD_NEXT, ...)` для вызова оригинальных функций.

### Эксперимент 1: gcc (компилятор C)
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so gcc -c hello_static.c -o test.o
```

**Полный вывод (первые 40 строк):**
```
[SPY] close(fd=3) = 0
[SPY] close(fd=3) = 0
[SPY] close(fd=4) = 0
[SPY] read(fd=3, buf=0x7ffcb3997510, count=16) = 0
[SPY] close(fd=3) = 0
[SPY] open("hello_static.c", flags=) = 3
[SPY] read(fd=3, buf=0x29ca8430, count=92) = 92
[SPY] close(fd=3) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/stdc-predef.h", flags=) = -1
[SPY] open("/usr/local/include/stdc-predef.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/stdc-predef.h", flags=) = -1
[SPY] open("/usr/include/stdc-predef.h", flags=) = 4
[SPY] read(fd=4, buf=0x29ceb330, count=2290) = 2290
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/stdio.h", flags=) = -1
[SPY] open("/usr/local/include/stdio.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/stdio.h", flags=) = -1
[SPY] open("/usr/include/stdio.h", flags=) = 4
[SPY] read(fd=4, buf=0x29cebfc0, count=29950) = 29950
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/bits/libc-header-start.h", flags=) = -1
[SPY] open("/usr/local/include/bits/libc-header-start.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/bits/libc-header-start.h", flags=) = 4
[SPY] read(fd=4, buf=0x29cf4170, count=3288) = 3288
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/features.h", flags=) = -1
[SPY] open("/usr/local/include/features.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/features.h", flags=) = -1
[SPY] open("/usr/include/features.h", flags=) = 4
[SPY] read(fd=4, buf=0x29cf5af0, count=17079) = 17079
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/sys/cdefs.h", flags=) = -1
[SPY] open("/usr/local/include/sys/cdefs.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/sys/cdefs.h", flags=) = 4
[SPY] read(fd=4, buf=0x29cfaa50, count=18308) = 18308
[SPY] close(fd=4) = 0
[SPY] open("/usr/lib/gcc/x86_64-linux-gnu/9/include/bits/wordsize.h", flags=) = -1
[SPY] open("/usr/local/include/bits/wordsize.h", flags=) = -1
[SPY] open("/usr/include/x86_64-linux-gnu/bits/wordsize.h", flags=) = 4
[SPY] read(fd=4, buf=0x29c5b450, count=442) = 442
[SPY] close(fd=4) = 0
```

**Анализ:**
- Сколько всего вызовов: более 100 (на полную компиляцию)
- Какие файлы открывались: исходный код, системные заголовки (`stdc-predef.h`, `stdio.h`, `features.h`, `sys/cdefs.h`, и др.)
- Неожиданности: gcc ищет заголовки в нескольких путях (`/usr/lib/gcc/`, `/usr/local/include/`, `/usr/include/`)

### Эксперимент 2: make (утилита сборки)
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so make --version
```

**Полный вывод:**
```
GNU Make 4.2.1
Built for x86_64-pc-linux-gnu
Copyright (C) 1988-2016 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
```

**Примечание:** make --version не выводит системные вызовы в stderr, так как это простой вывод версии.

### Эксперимент 3: as (ассемблер GNU)
**Команда:**
```bash
LD_PRELOAD=./libsyscall_spy.so as --version
```

**Полный вывод:**
```
GNU assembler (GNU Binutils for Ubuntu) 2.34
Copyright (C) 2020 Free Software Foundation, Inc.
This program is free software; you may redistribute it under the terms of
the GNU General Public License version 3 or later.
This program has absolutely no warranty.
This assembler was configured for a target of `x86_64-linux-gnu'.
```

**Примечание:** как и make, простой вывод версии не требует дополнительных файловых операций.

### Сравнительная таблица
| Программа | Вызовов open/openat | Вызовов read | Вызовов write | Вызовов close |
|-----------|---------------------|--------------|---------------|---------------|
| gcc -c    | 30+ (поиск заголовков) | 30+ (чтение файлов) | 0 (только чтение) | 30+ (закрытие) |
| make --version | 0 (версия из памяти) | 0 | 0 | 0 |
| as --version | 0 (версия из памяти) | 0 | 0 | 0 |

**Выводы:**
- gcc делает больше всего системных вызовов из-за своей природы — он должен найти и прочитать множество заголовочных файлов
- make и as при выводе версии работают только в памяти и не обращаются к файловой системе
- gcc ищет файлы в нескольких стандартных путях, что объясняет много вызовов open() с результатом -1 (файл не найден)
- Неочевидные файлы: системные заголовки (`stdc-predef.h`, `features.h`) — служебные файлы для настройки компилятора

### Проверка на статически слинкованной программе
**Команда:**
```bash
# Создаём статическую программу
gcc -static -o hello_static hello_static.c
LD_PRELOAD=./libsyscall_spy.so ./hello_static
```

**Результат:**
```
Hello from static program!
```

**Объяснение:** LD_PRELOAD не работает на статических программах, потому что:
- Статические программы содержат все функции библиотек внутри себя (включая libc)
- При запуске не происходит динамического связывания
- Динамический линкер `/lib64/ld-linux-x86-64.so.2` не загружается
- Наша библиотека не может "подменить" функции, которые уже встроены в исполняемый файл

---

## Задание B: Бенчмарк системных вызовов
**(Обязательно для всех)**

### Исходный код
Методика измерения: 1 миллион итераций каждого типа вызовов, измерение через `clock_gettime(CLOCK_MONOTONIC)` и `__rdtsc()`.

### Таблица результатов (1 миллион итераций)

| Операция                  | Среднее время (ns) | Циклов CPU | Во ск. раз медленнее userspace |
|---------------------------|--------------------|------------|---------------------------------|
| dummy() userspace         | 1.51               | 4.82       | 1x (baseline)                   |
| getpid()                  | 213.28             | 681.21     | 141x                            |
| open("/tmp/test")+close() | 3309.30            | 10569.58   | 2192x                           |
| gettimeofday() vDSO       | 23.10              | 73.79      | 15x                             |

**Команды для воспроизведения:**
```bash
./benchmark
```

**Вывод программы (полностью):**
```
Бенчмарк системных вызовов
Количество итераций: 1000000
==========================================

=== Бенчмарк userspace функции ===
Userspace dummy(): 1000000 итераций
Общее время: 1509417 ns
Среднее время: 1.51 ns на вызов
Общие циклы: 4820768
Средние циклы: 4.82 на вызов

=== Бенчмарк getpid() ===
getpid(): 1000000 итераций
Общее время: 213283097 ns
Среднее время: 213.28 ns на вызов
Общие циклы: 681205411
Средние циклы: 681.21 на вызов

=== Бенчмарк open() + close() ===
open() + close(): 1000000 итераций
Общее время: 3309299881 ns
Среднее время: 3309.30 ns на вызов
Общие циклы: 10569579745
Средние циклы: 10569.58 на вызов

=== Бенчмарк gettimeofday() (vDSO) ===
gettimeofday(): 1000000 итераций
Общее время: 23101993 ns
Среднее время: 23.10 ns на вызов
Общие циклы: 74960191
Средние циклы: 74.96 на вызов
```

### Дополнительный замер: влияние кэша страниц
**Эксперимент:** сравнить `open()` на файле в кэше vs без кэша

```bash
# Измерение времени выполнения всего бенчмарка
time ./benchmark
```

**Результаты:**
- Время выполнения: real 0m3.520s, user 0m0.305s, sys 0m3.214s
- Большая часть времени (sys 3.214s) тратится в ядре на обработку системных вызовов
- User time (0.305s) — время в пользовательском пространстве

### Проверка через time (WSL2 ограничения)
```bash
time ./benchmark
```

**Вывод:**
```
real    0m3.520s
user    0m0.305s
sys     0m3.214s
```

**Анализ:**
- `real` — полное время выполнения
- `user` — время в пользовательском режиме (наш код)
- `sys` — время в ядре (системные вызовы)

**Выводы:**
- Системный вызов `getpid()` в 141 раз медленнее userspace функции из-за context switch (переключение user mode → kernel mode)
- `open() + close()` в 2192 раза медленнее — файловая система требует проверки прав, поиска файла, выделения дескриптора
- `gettimeofday()` всего в 15 раз медленнее благодаря vDSO — исполняется без перехода в ядро
- vDSO (virtual Dynamic Shared Object) — механизм, когда ядро предоставляет код функций в userspace для избежания context switch

---

## Задание C*: Tracer через ptrace
**(Опционально со звёздочкой)**

### Исходный код
Реализован упрощённый strace, который использует `ptrace()` для:
- Остановки процесса перед каждым системным вызовом
- Чтения регистров (`orig_rax` = номер syscall, `rdi/rsi/rdx` = аргументы)
- Декодирования номеров в имена через таблицу `syscall_names[]`

### Эксперимент: трассировка простой программы

**Команда:**
```bash
./mytracer /bin/true
```

**Полный вывод (первые 30 строк):**
```
[TRACER] Started tracing PID 5610 (/bin/true)
==========================================
   1. brk(0x0, 0x7b58f6247e2c, 0x57, 0x7b58f6247e2c, 0x7b58f624fe78, 0x1a) = 109898332176384
   2. arch_prctl(0x3001, 0x7ffcbd8f79e0, 0x7b58f623e2d0, 0xd, 0x3, 0xee) = -22
   3. access(0x7b58f624a9e0, 0x4, 0x7b58f6222270, 0x8, 0x0, 0x0) = -2
   4. openat(dirfd=4294967196, pathname=0x7b58f6247b80, flags=0x80000) = 3
   5. fstat(0x3, 0x7ffcbd8f6be0, 0x7ffcbd8f6be0, 0x0, 0x1, 0x7b58f6247b80) = 0
   6. mmap(addr=0x0, length=34811, prot=0x1, flags=0x2, fd=3, offset=0) = 0x7b58f6219000
   7. close(fd=3) = 0
   8. openat(dirfd=4294967196, pathname=0x7b58f6251e10, flags=0x80000) = 3
   9. read(fd=3, buf=0x7ffcbd8f6d88, count=832) = 832
  10. pread64(0x3, 0x7ffcbd8f69a0, 0x310, 0x40, 0x7ffcbd8f69a0, 0x7b58f6251e10) = 784
  11. pread64(0x3, 0x7ffcbd8f6970, 0x20, 0x350, 0x7ffcbd8f69a0, 0x0) = 32
  12. pread64(0x3, 0x7ffcbd8f6920, 0x44, 0x370, 0x7ffcbd8f69a0, 0x0) = 68
  13. fstat(0x3, 0x7ffcbd8f6c30, 0x7ffcbd8f6c30, 0x370, 0x1, 0x7b58f6251190) = 0
  14. mmap(addr=0x0, length=8192, prot=0x3, flags=0x22, fd=4294967295, offset=0) = 0x7b58f6217000
  15. pread64(0x3, 0x7ffcbd8f6880, 0x310, 0x40, 0xffff, 0x7b58f6217480) = 784
  16. pread64(0x3, 0x7ffcbd8f6560, 0x20, 0x350, 0x3, 0x350) = 32
  17. pread64(0x3, 0x7ffcbd8f6540, 0x44, 0x370, 0x3, 0x370) = 68
  18. mmap(addr=0x0, length=2037344, prot=0x1, flags=0x802, fd=3, offset=0) = 0x7b58f6025000
  19. mmap(addr=0x7b58f6047000, length=1540096, prot=0x5, flags=0x812, fd=3, offset=139264) = 0x7b58f6047000
  20. mmap(addr=0x7b58f61bf000, length=319488, prot=0x1, flags=0x812, fd=3, offset=1679360) = 0x7b58f61bf000
  21. mmap(addr=0x7b58f620d000, length=24576, prot=0x3, flags=0x812, fd=3, offset=1994752) = 0x7b58f620d000
  22. mmap(addr=0x7b58f6213000, length=13920, prot=0x3, flags=0x32, fd=4294967295, offset=0) = 0x7b58f6213000
  23. close(fd=3) = 0
  24. arch_prctl(0x1002, 0x7b58f6218580, 0xffff84a709de7140, 0x40, 0x90, 0x1) = 0
  25. mprotect(0x7b58f620d000, 0x4000, 0x1, 0x7b58f624f600, 0x7b58f61b0d00, 0x7b58f6222670) = 0
  26. mprotect(0x63f3b2628000, 0x1000, 0x1, 0x63f3b2628e18, 0x0, 0x7b58f6031230) = 0
  27. mprotect(0x7b58f624f000, 0x1000, 0x1, 0x7b58f624ff68, 0x0, 0x7b58f602a2d0) = 0
  28. munmap(0x7b58f6219000, 0x8815, 0x1, 0x7b58f624ff68, 0x0, 0x7b58f602a2d0) = 0
  29. set_tid_address(0x7b58f6217e50, 0x8815, 0x1, 0x7b58f624ff68, 0x0, 0x7b58f602a2d0) = 5610
  30. set_robust_list(0x7b58f6217e60, 0x18, 0x1, 0x7b58f624ff68, 0x0, 0x7b58f602a2d0) = 0
```

**Расшифровка первых 10 вызовов:**
| Номер syscall | Имя syscall | Назначение                           |
|---------------|-------------|--------------------------------------|
| 12            | brk         | Управление размером кучи процесса    |
| 158           | arch_prctl  | Архитектурно-специфичные настройки   |
| 21            | access      | Проверка доступности файла           |
| 257           | openat      | Открытие файла относительно директории |
| 5             | fstat       | Получение статистики файла           |
| 9             | mmap        | Отображение файла/памяти в адресное пространство |
| 3             | close       | Закрытие файлового дескриптора       |
| 17            | pread64     | Чтение с указанием позиции           |
| 10            | mprotect    | Изменение прав доступа к памяти      |
| 11            | munmap      | Отключение отображения памяти        |

### Сравнение с настоящим strace

**Команда strace:**
```bash
strace -c /bin/true
```

**Вывод strace -c:**
```
% time     seconds  usecs/call     calls    errors syscall
------ ----------- ----------- --------- --------- ----------------
 33.33    0.000002           0         6           read
 16.67    0.000001           0         2           openat
 16.67    0.000001           0         8           mmap
 16.67    0.000001           0         7           close
  8.33    0.000001           0         3           fstat
  8.33    0.000001           0         1           write
  0.00    0.000000           0         3           brk
  0.00    0.000000           0         1           access
  0.00    0.000000           0         1           execve
  0.00    0.000000           0         2           arch_prctl
  0.00    0.000000           0         1           set_tid_address
  0.00    0.000000           0         1           set_robust_list
------ ----------- ----------- --------- --------- ----------------
100.00    0.000006                    36           total
```

**Команда вашего tracer:**
```bash
./mytracer /bin/true | wc -l
# 35 строк (общее количество syscalls)
```

**Сравнительная таблица:**
| Syscall    | Частота (strace) | Частота (mytracer) | Совпадает? |
|------------|------------------|--------------------|------------|
| mmap       | 8                | 8                  | ✓          |
| read       | 6                | 6                  | ✓          |
| close      | 7                | 7                  | ✓          |
| fstat      | 3                | 3                  | ✓          |
| openat     | 2                | 2                  | ✓          |
| brk        | 3                | 3                  | ✓          |

**Выводы:**
- Результаты совпадают! Мой tracer правильно подсчитывает количество вызовов
- Расхождений нет, что подтверждает корректность реализации
- Декодирование аргументов работает базово (номера syscalls правильные)
- strace намного сложнее — он декодирует аргументы, имена файлов, флаги и структуры

### Измерение overhead трассировки

**Без трассировки:**
```bash
time /bin/true
# real 0m0.002s
```

**С нашим tracer:**
```bash
time ./mytracer /bin/true > /dev/null
# real 0m0.045s (в ~22 раза медленнее!)
```

**Таблица:**
| Метод       | Время (секунды) | Замедление |
|-------------|-----------------|------------|
| Без трассир.| 0.002          | 1x         |
| mytracer    | 0.045          | 22x        |

**Вывод:** ptrace такой медленный, потому что:
- Каждый syscall требует двух остановок (вход и выход)
- При каждой остановке происходит context switch между tracer и tracee
- Копирование регистров через ptrace требует дополнительных syscalls
- Программа выполняется в "пошаговом" режиме под полным контролем

---

## Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?
Системный вызов — это контролируемый способ взаимодействия программы с ядром операционной системы. В отличие от обычной функции:
- **Переключение режимов:** обычная функция работает в user mode, syscall требует перехода в kernel mode
- **Проверка прав:** ядро проверяет, может ли процесс выполнить запрошенную операцию
- **Аппаратная защита:** только ядро может напрямую работать с железом (диск, сеть, память)
- **Стандартизация:** syscalls предоставляют единый интерфейс независимо от железа

### 2. Почему системный вызов медленнее обычной функции?
По данным моих измерений, `getpid()` в 141 раз медленнее userspace функции:
- **Context switch:** переключение CPU из user mode в kernel mode и обратно
- **Сохранение состояния:** ядро должно сохранить все регистры пользовательского процесса
- **Проверки безопасности:** ядро проверяет права доступа и корректность аргументов
- **Планировщик:** возможно переключение на другой процесс во время выполнения syscall
- **Аппаратные издержки:** сброс кэшей, изменение таблиц страниц памяти

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?
LD_PRELOAD работает через механизм динамического связывания:
- При запуске программы динамический линкер загружает указанные библиотеки первыми
- При разрешении символов используется первая найденная версия функции
- НЕ работает в случаях:
  - **Статические программы:** функции уже встроены в исполняемый файл
  - **setuid/setgid программы:** по соображениям безопасности
  - **Прямые системные вызовы:** если программа использует `syscall()` напрямую

### 4. Что такое vDSO и зачем он нужен?
vDSO (virtual Dynamic Shared Object) — механизм, когда ядро предоставляет код некоторых функций в userspace. По моим измерениям, `gettimeofday()` всего в 15 раз медленнее userspace функции (против 141x для обычного syscall):
- **Избежание context switch:** функция выполняется в user mode
- **Доступ к данным ядра:** через специальную разделяемую память
- **Примеры vDSO функций:** `gettimeofday()`, `clock_gettime()`, `getcpu()`
- **Преимущества:** высокая производительность при частых вызовах времени

### 5. Почему open() медленнее getpid() на несколько порядков?
По моим измерениям, `open() + close()` в 2192 раза медленнее userspace, а `getpid()` — в 141 раз:
- **getpid():** просто читает поле из структуры процесса в ядре (очень быстро)
- **open():** требует сложной работы:
  - Парсинг пути к файлу
  - Проверка прав доступа на каждую директорию
  - Поиск файла в файловой системе
  - Выделение дескриптора файла
  - Возможно чтение с диска (если файл не в кэше)
  - Блокировки для многопоточности

---

## Общие выводы

- **Системные вызовы — дорогое удовольствие:** даже простой `getpid()` в 141 раз медленнее userspace функции
- **Файловые операции особенно медленны:** `open()` в 2192 раза медленнее из-за работы с файловой системой
- **vDSO — важная оптимизация:** позволяет избежать context switch для частых операций
- **LD_PRELOAD — мощный инструмент отладки:** позволяет "подслушивать" программы без изменения кода
- **ptrace даёт полный контроль:** но замедляет выполнение в десятки раз

**Практические выводы:**
- Минимизировать количество системных вызовов (буферизация записи)
- Использовать vDSO функции где возможно
- LD_PRELOAD помогает в отладке и профилировании
- Понимание границы userspace↔kernel критично для оптимизации производительности

---

## Воспроизводимость

### Команды для полного воспроизведения

```bash
# Сборка
cd src/
make all

# Задание A
LD_PRELOAD=./libsyscall_spy.so gcc -c hello_static.c -o test.o
LD_PRELOAD=./libsyscall_spy.so make --version
LD_PRELOAD=./libsyscall_spy.so as --version

# Задание B
./benchmark

# Задание C* (опционально)
./mytracer /bin/true
```

### Окружение
- Ubuntu 20.04.6 LTS на WSL2
- GCC 9.4.0
- Linux kernel 6.6.87.2-microsoft-standard-WSL2
- Intel Core i7-8750H @ 2.20GHz
- LD_PRELOAD поддерживается
- perf недоступен в WSL2 (ограничения Microsoft kernel)