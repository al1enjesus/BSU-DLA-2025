# Лабораторная 4 — Системные вызовы: граница между программой и ядром
Среда выполнения: wsl ubuntu
## Цели лабораторной

- Понять, что такое системный вызов и как он работает изнутри.
- Увидеть **все** системные вызовы, которые делает программа (даже те, что скрыты библиотеками).
- Измерить **накладные расходы** (overhead) — сколько времени тратится на переход в ядро и обратно.
- Научиться **перехватывать** вызовы без изменения кода программы через `LD_PRELOAD`.
- Понять разницу между работой в userspace и kernel space.


```markdown
Номер в списке: 17
Программы: 17 % 4 = 1 → `find`, `tar`, `cp`
```

### A) LD_PRELOAD: перехват функций библиотеки (обязательно для всех)

**1. Код и компиляция:**
- Код библиотеки находится в файле syscall_spy.cpp
- Команды компиляции и проверки:
    есть makefile, поэтому через make собираем саму библиотеку
    Проверки: file libsyscall_spy.so
    ldd libsyscall_spy.so

**2. Эксперименты на выбранных программах:**
- Запуск на всех 3 программах выполняется через:
    chmod +x run_all.sh
    ./run_all.sh
- Логи сохраняются в папку /logs отдельно для каждой программы
- **Сравнительная таблица** вызовов по программам. \

| Программа | open/openat | read | write | close | Всего вызовов |
|-----------|-------------|------|-------|-------|--------|
| cp        | 22          | 22   | 11    | 22    | 77        |
| find      | 7           | -    | -     | 18    | 25           |
| tar       | 1           | 31   |       | 1     | 33            |


## 3. АНАЛИЗ И РАССУЖДЕНИЯ

### Какая программа делает больше всего системных вызовов и почему

| Программа | Основные системные вызовы        | Причина высокой активности |
|-----------|----------------------------------|---------------------------|
| `cp`      | `open`, `read`, `write`, `close` | Копирует файлы. Каждое открытие, чтение, запись и закрытие создаёт syscalls. |
| `find`    | `open/openat`, `close`           | Рекурсивно обходит дерево директорий, проверяет права доступа и метаданные файлов. Много `openat()` для перехода по папкам. |
| `tar`     | `open`, `read`, `close`          | Читает архив и файлы внутри. Много последовательных `read()` для извлечения содержимого. |

> **Вывод:** наибольшее число вызовов создают `cp` и `find`, но разного типа: `cp` — в основном I/O операции, `find` — операции для провдвижения по файловой структуре


### Какие неожиданные файлы открываются

- **Системные библиотеки** (`/lib/x86_64-linux-gnu/libc.so.6`)  
  Используются для реализации базовых функций C (например, `open`, `read`, `printf`)

- **Конфигурационные файлы** (`/etc/ld.so.cache`)  
  Кэш путей динамических библиотек, ускоряет загрузку библиотек при запуске программ.

- **Псевдо-файлы** (`/proc/filesystems`, `/sys/...`)  
  Интерфейс ядра для получения информации о файловой системе, процессах и оборудовании.

### Сравнение профилей вызовов

| Программа | Почему много `read()` | Почему много `write()` |
|-----------|----------------------|------------------------|
| `cp`      | Читает исходные файлы | Пишет в файлы          |
| `find`    | Практически нет      | Практически нет        |
| `tar`     | Читает архив и файлы внутри | Практически нет        |

> **Вывод:** I/O операции зависят от программы. `cp` активно работает с диском, `find` — с метаданными, `tar` — с архивами.

### Что узнали нового о работе программ

- `find` активно использует `openat()` для обхода директорий, показывая, как ядро обрабатывает файловую структуру.
- `cp` делает много мелких `read()` и `write()`, даже для небольших файлов.
- `tar` выполняет много последовательных `read()`, особенно для больших архивов.
- Динамическая линковка добавляет системные вызовы на загрузку библиотек.
- **Практическое применение:**
    - Отладка работы с файловой системой.
    - Оптимизация дискового I/O (уменьшение количества открытий/закрытий файлов).
    - Анализ поведения программ до и после изменений кода.

### 4. Статитечская программа
 > g++ -static static.cpp -o static \
 > LD_PRELOAD=$PWD/libsyscall_spy.so ./static 
 
 Результат: логи о перехватах отсутствуют
 Все функции из libc и других библиотек встраиваются прямо в исполняемый файл.
 На этапе запуска нет динамического линкера, который бы проверял LD_PRELOAD.
 Символы функций (open, read, write, close) уже привязаны к конкретным адресам.
 Поэтому библиотека libsyscall_spy.so просто не загружается и не может перехватывать системные вызовы.


### B) Benchmark: сколько стоит системный вызов? (обязательно)

**1. Код и результаты:**
- Сама программа находится в файле benchmark.cpp
- Таблица с результатами(в наносекундах и тактах CPU):

| Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
|--------------------|------------|------------|------------------------------------|
dummy()              |    6.11 ns |    18.3 cycles |   1.0x
getpid()             |   77.34 ns |   232.0 cycles |  12.7x
open+close           | 1269.63 ns |  3808.9 cycles | 207.8x
gettimeofday vDSO    |   18.63 ns |    55.9 cycles |   3.0x

**2. Эксперименты:**
- **Эксперимент с кэшем**: запустите бенчмарк `open()` дважды — со сбросом кэша (`echo 3 > /proc/sys/vm/drop_caches`) и без. \
**С кэшем:**

| Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
|--------------------|------------|------------|------------------------------------| 
dummy()              |    6.39 ns |    19.2 cycles |   1.0x
getpid()             |   94.08 ns |   282.3 cycles |  14.7x
open+close           | 1041.85 ns |  3125.5 cycles | 163.0x
gettimeofday vDSO    |   15.94 ns |    47.8 cycles |   2.5x

**После очистки:**

| Операция           | Время (ns) | Циклов CPU | Во сколько раз медленнее userspace |
|--------------------|------------|------------|------------------------------------|
dummy()              |    6.33 ns |    19.0 cycles |   1.0x
getpid()             |   76.64 ns |   229.9 cycles |  12.1x
open+close           | 1088.38 ns |  3265.2 cycles | 172.1x
gettimeofday vDSO    |   17.15 ns |    51.5 cycles |   2.7x

- **Вывод `perf stat`** (ОБЯЗАТЕЛЬНО): \
У меня wsl, поэтому perf не удалось, продекмонстрирую вывод команды `strace -c ./benchmark`
 
 | % time | seconds    | usecs/call | calls  | errors | syscall       |
  |--------|------------|------------|--------|--------|---------------|
  | 99.97  | 7.569601   | 19         | 382692 |        | getpid        |
  | 0.01   | 0.000625   | 28         | 22     |        | mmap          |
  | 0.01   | 0.000479   | 11         | 43     | 38     | openat        |
  | 0.00   | 0.000189   | 27         | 7      |        | mprotect      |
  | 0.00   | 0.000148   | 4          | 32     | 30     | stat          |
  | 0.00   | 0.000124   | 20         | 6      |        | pread64       |
  | 0.00   | 0.000098   | 19         | 5      |        | close         |
  | 0.00   | 0.000098   | 19         | 5      |        | fstat         |
  | 0.00   | 0.000083   | 20         | 4      |        | read          |
  | 0.00   | 0.000043   | 14         | 3      |        | brk           |
  | 0.00   | 0.000028   | 28         | 1      |        | munmap        |
  | 0.00   | 0.000022   | 11         | 2      | 1      | arch_prctl    |
  | 0.00   | 0.000000   | 0          | 1      | 1      | access        |
  | 0.00   | 0.000000   | 0          | 1      |        | execve        |
  | 100.00 | 7.571538   |            | 382824 | 70     | total         |

### Почему системный вызов в 50-100 раз медленнее userspace функции?

Системный вызов требует перехода из **user mode → kernel mode** (context switch).

#### Механизм context switch:
1. Процесс в **user mode** вызывает функцию вроде `getpid()` или `open()`.
2. CPU выполняет переход в **kernel mode**, чтобы ядро могло безопасно обработать запрос.
3. Ядро проверяет права доступа, параметры вызова и выполняет необходимые действия.
4. После выполнения syscall происходит возврат в **user mode**.

#### Что происходит с регистрами CPU:
- Сохраняются все регистры текущего процесса.
- Загружаются регистры ядра, выполняется обработка syscall.
- После завершения syscall регистры ядра сохраняются, а регистры user-space восстанавливаются.
- Эти операции требуют дополнительных инструкций, что увеличивает задержку.

#### Почему ядро проверяет права доступа:
Потому что в противном случае любой имел бы полный доступ к памяти и устройствам, то есть по сути это вынужденные меры для поддержания безопсаности и стабильности работы ОС

#### Конкретные числа из замеров:

| Операция  | Время (ns) | Циклы CPU | Медленнее userspace |
|-----------|------------|-----------|-------------------|
| dummy()   | 6.39 ns    | 19.2      | 1x (базовая линия) |
| getpid()  | 94.08 ns   | 282.3     | 14.7x             |

**Вывод:** даже простой syscall `getpid()` выполняется почти в **15 раз медленнее**, чем обычная функция user-space, из-за **контекстного переключения, сохранения регистров и проверки прав ядра**.

- **Почему `open()` в ~2000 раз медленнее `getpid()`?**
  - Что делает `getpid()`: просто читает поле структуры в ядре
  - Что делает `open()`: файловая система, парсинг пути, проверка прав, блокировки, возможно обращение к диску \
Как раз из-за функционала описанного выше и возникает такая разница в скорости выполнения
  - Как влияет кэш page cache? (используйте данные из эксперимента с `drop_caches`) \
При очистке кэша время на чтение и открытие файла значительно повышается, это мы видим и в резлуьтатх эскперимента с кэшем 

- **Что такое vDSO и почему это важно?**
**`vDSO`** (virtual Dynamic Shared Object) — это специальная библиотека, которую ядро **отображает в адресное пространство процесса**, чтобы некоторые системные вызовы выполнялись без перехода в kernel mode.
  - Почему `gettimeofday()` всего в 10 раз медленнее userspace функции? \
    `gettimeofday()` через vDSO выполняется **в user mode**, поэтому всего в ~10 раз медленнее простой функции `dummy()`
  - Как vDSO избегает context switch? \
    Процесс получает доступ к данным ядра (например, к текущему времени) через отображённую в память библиотеку, не переходя в kernel mode.
  - Какие ещё функции могут быть в vDSO? (подумайте о часто используемых syscalls) \
  `clock_gettime()` \
  `time()` 

- **Анализ `perf stat` вывода:** \
К сожалению, не смогу провести анализ, так ка выполня. на wsl ubuntu, а здесь проблемы с perf

- **Практические выводы:**
- **Оптимизация кода:** уменьшение числа системных вызовов снижает накладные расходы, ускоряет выполнение.
- **Избегание syscalls:** полезно для часто повторяющихся операций, особенно в циклах; чтение/запись больших данных лучше объединять.
- **Буферизация:** критична при работе с файлами и сетью — позволяет сократить количество `read()`/`write()` и тем самым повысить производительность.


## Вопросы для отчёта

1. **Что такое системный вызов и чем он отличается от обычной функции?**  
   Системный вызов — это запрос программы к ядру ОС для выполнения защищённых операций (файлы, сеть, процессы). В отличие от обычной функции, происходит переход из user mode в kernel mode.

2. **Почему системный вызов медленнее обычной функции?**  
   Требуется context switch, сохранение/восстановление регистров, проверка прав доступа и других условий безопасности ядра.

3. **Как работает LD_PRELOAD и в каких случаях он НЕ работает?**  
   LD_PRELOAD загружает библиотеку перед основной при динамической линковке, позволяя переопределять функции. Не работает для статических программ и напрямую встроенных вызовов.

4. **Что такое vDSO и зачем он нужен?**  
   vDSO — виртуальная динамическая библиотека ядра в памяти процесса, которая позволяет выполнять быстрые системные вызовы (например, `gettimeofday()`) без context switch.

5. **Почему `open()` медленнее `getpid()` на несколько порядков?**  
   `open()` требует обращения к файловой системе, проверки прав, возможного чтения с диска и блокировок, тогда как `getpid()` просто читает поле структуры процесса в ядре.

## Как использовался ИИ 
- Для анализа результатов
- Для увеличения числа логов при перехвате вызовов
- С целью получения информации при ответе на вопросы