# Лабораторная 4 — Системные вызовы

## Выбор программ
Номер в списке группы: 6
Расчёт группы программ: 6 % 4 = 2
Программы для анализа: ```curl, wget```
Мои задания: A (LD_PRELOAD), B (Benchmark) — обязательные

## Среда выполнения
- ОС: Ubuntu 24.04 LTS
- Ядро: 6.14.0-29-generic
- Процессор: AMD Ryzen 3 5300U with Radeon Graphics
- Компилятор: gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0

---

## Задание A: LD_PRELOAD перехват
**(Обязательно для всех)**

### Код библиотеки
Библиотека `libsyscall_spy.so` перехватывает библиотечные функции **open/openat**, **read/write**, и **close**.
Для вызова оригинальных функций используется **dlsym(RTLD_NEXT, "имя_функции")**.
**Особенности реализации:**
1.  **Защита от рекурсии:** В функции `write()` добавлена проверка `if (fd != 2)` для предотвращения бесконечной рекурсии при логировании на `stderr` (дескриптор 2).
2.  **Логирование контекста:** Используются `clock_gettime()` и `syscall(SYS_gettid)` для вывода PID, TID и точного времени.
3.  **Улучшенная читаемость:** Реализована простая внутренняя карта **`fd_map_path`** для связывания файлового дескриптора (`fd`) с именем файла/путем, что делает логи `read/write/close` более информативными.
4.  **Обработка аргументов:** Использована **`va_list`** для корректной передачи опционального аргумента `mode` при вызове `open()` с флагом `O_CREAT`.

### Эксперимент 1: Программа curl
**Команда:**
```bash
LD_PRELOAD=../libsyscall_spy.so curl -vI [https://example.com](https://example.com) 2> ../logs/curl_spy.log
```
Полный вывод (Первые 30-50 строк из ../logs/curl_spy.log):
```
[1760961360.215] pid=150568 tid=150568 [SPY] open("/proc/sys/crypto/fips_enabled", 0x0) = -1 errno=2 (No such file or directory)
[1760961360.216] pid=150568 tid=150568 [SPY] open("/home/anna/.curlrc", 0x0) = -1 errno=2 (No such file or directory)
[1760961360.216] pid=150568 tid=150568 [SPY] open("/home/anna/.config/curlrc", 0x0) = -1 errno=2 (No such file or directory)
[1760961360.216] pid=150568 tid=150568 [SPY] open("/home/anna/.curlrc", 0x0) = -1 errno=2 (No such file or directory)
[1760961360.216] pid=150568 tid=150568 [SPY] close(fd=5) = 0
[1760961360.217] pid=150568 tid=150569 [SPY] write(fd=6, count=1) = 1
[1760961360.217] pid=150568 tid=150568 [SPY] close(fd=6) = 0
[1760961360.217] pid=150568 tid=150568 [SPY] close(fd=5) = 0
* Host example.com:443 was resolved.
... (остальная часть лога, не содержащая SPY-выводов)
* Connected to example.com (23.220.75.232) port 443
...
[1760961361.100] pid=150568 tid=150568 [SPY] close(fd=3) = 0
[1760961361.100] pid=150568 tid=150568 [SPY] close(fd=4) = 0
[1760961361.101] pid=150568 tid=150568 [SPY] close(fd=5) = 0
```
**Выводы:**
Всего было $\mathbf{10}$ вызовов (open/close/write) в логе SPY, при этом были открыты следующие файлы: /proc/sys/crypto/fips_enabled, /home/anna/.curlrc, /home/anna/.config/curlrc. Все попытки open закончились ошибкой errno=2 (No such file or directory). НО! /proc/sys/crypto/fips_enabled — псевдо-файл, показывающий проверку криптографических стандартов системой перед установкой HTTPS-соединения. Мы не видим активных read/write на сокет, так как большая часть I/O происходит внутри TLS-библиотеки, а мы использовали curl -vI, вывод которого может смешиваться.


### Эксперимент 2: Программа wget
**Команда:**
```bash
LD_PRELOAD=../libsyscall_spy.so wget -O - https://example.com 2> ../logs/wget_spy.log
```
Полный вывод (Первые 30-50 строк из ../logs/wget_spy.log):
```
--2025-10-20 14:56:01--  https://example.com/
[1760961361.145] pid=150570 tid=150570 [SPY] open("/proc/sys/crypto/fips_enabled", 0x0) = -1 errno=2 (No such file or directory)
Resolving example.com (example.com)... 23.215.0.138, 23.220.75.232, 23.192.228.80, ...
Connecting to example.com (example.com)|23.215.0.138|:443... connected.
[1760961361.407] pid=150570 tid=150570 [SPY] write(fd=3, count=405) = 405
[1760961361.407] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = -1 errno=11 (Resource temporarily unavailable)
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=122) = 122
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=1) = 1
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=37) = 37
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.714] pid=150570 tid=150570 [SPY] read(fd=3, count=2367) = 2367
[1760961361.770] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.770] pid=150570 tid=150570 [SPY] read(fd=3, count=95) = 95
[1760961361.771] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961361.771] pid=150570 tid=150570 [SPY] read(fd=3, count=69) = 69
[1760961361.771] pid=150570 tid=150570 [SPY] write(fd=3, count=80) = 80
[1760961361.771] pid=150570 tid=150570 [SPY] write(fd=3, count=148) = 148
HTTP request sent, awaiting response... [1760961361.771] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = -1 errno=11 (Resource temporarily unavailable)
[1760961362.002] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961362.002] pid=150570 tid=150570 [SPY] read(fd=3, count=282) = 282
[1760961362.002] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961362.002] pid=150570 tid=150570 [SPY] read(fd=3, count=282) = 282
[1760961362.002] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = -1 errno=11 (Resource temporarily unavailable)
[1760961362.328] pid=150570 tid=150570 [SPY] read(fd=3, count=5) = 5
[1760961362.328] pid=150570 tid=150570 [SPY] read(fd=3, count=845) = 845
```
**Выводы:**
Всего было $\mathbf{24}$ вызова (open/read/write). Открылись только /proc/sys/crypto/fips_enabled (не найден). wget не ищет .wgetrc в логе, но активно работает с сокетом. Но! У wget мы видим очень активный обмен данными через read(fd=3, count=...). Это серия TLS-фреймов и HTTP-заголовков. Многократные ошибки errno=11 (Resource temporarily unavailable) показывают, что сокет работает в неблокирующем режиме, и программа делает частые, но неудачные, попытки чтения в ожидании данных.

**Сравнительная таблица**
### Сравнительная таблица

| Программа | Вызовов open/openat | Вызовов read | Вызовов write | Вызовов close | Общее I/O (read+write) |
|:---|:---|:---|:---|:---|:---|
| **curl** (HEAD-запрос) | 4 (все -1) | 0 (не в логе SPY) | 1 | 6 | $\approx 1$ |
| **wget** (GET-запрос) | 1 (неудачный) | $\mathbf{18}$ | $\mathbf{3}$ | 0 | $\mathbf{21}$ |

**Выводы:**
- **Какая программа делает больше всего системных вызовов? Почему?**
  Наш лог показал, что **`wget`** выполнил $\mathbf{21}$ операцию I/O (`read`/`write`) на сокет, в то время как `curl -vI` показал только одну операцию `write` (отправку запроса). Это объясняется тем, что `wget` в данном режиме (GET-запрос) активно читает данные ответа, делая множество маленьких `read` (5, 122, 1 байт), что отражает работу протокола TLS/SSL и буферизации на низком уровне.
- **Какие неожиданные файлы открываются?**
  Самый неочевидный файл — это псевдо-файл ядра **`/proc/sys/crypto/fips_enabled`**. Его открытие обеими программами говорит о том, что базовая криптографическая библиотека (например, OpenSSL) проверяет системные настройки безопасности (режим FIPS), прежде чем начать TLS-рукопожатие. Также обе программы ищут пользовательские конфигурационные файлы (`.curlrc`), что является стандартной, но требующей `open()` и `close()` операцией.
- **Сравните профили вызовов:**
  Сетевые утилиты (`curl`, `wget`) имеют профиль, **резко отличающийся** от файловых:
    1.  **Мало `open`/`close`**: Они открывают только свои конфиги (неудачно) и один сокет.
    2.  **Много `read`/`write`**: Основная работа сосредоточена на дескрипторе сокета (`fd=3`), через который происходит интенсивный обмен данными.

### Эксперимент 3: Проверка на статически слинкованной программе

**Команды:**
```bash
# 1. Создание простой программы hello.c
cat > src/hello.c << EOF
#include <stdio.h>
int main() {
    printf("Hello from static world!\n");
    return 0;
}
EOF

# 2. Компиляция СТАТИЧЕСКОГО бинарника
gcc -static -o hello_static src/hello.c

# 3. Запуск с LD_PRELOAD
LD_PRELOAD=../libsyscall_spy.so ./hello_static > logs/hello_spy.log
```
**Результат:**
```
Hello from static world!
# Вывод [SPY] полностью ОТСУТСТВУЕТ.
```
**Выводы:**
Перехват НЕ работает на статически слинкованном бинарнике. Причина в том, что статически слинкованная программа не использует динамический линкер (```ld.so```) при запуске. Все библиотечные функции, включая ```printf``` (который в итоге вызывает ```write()```), встраиваются (влинковываются) непосредственно в исполняемый файл. Поскольку динамический линкер не задействован, он не считывает переменную окружения ```LD_PRELOAD```, и наша библиотека ```libsyscall_spy.so``` не загружается в адресное пространство процесса.

Также упоминаем, что у нас были эксперименты на 2х командах, потому что в условии не было продумано, что есть вариант с 2мя командами. 

---

## Задание B: Benchmark системных вызовов
**(Обязательно для всех)**

### Исходный код
Измерение проводилось с использованием функции `__rdtsc()` для подсчета тактов CPU и `clock_gettime(CLOCK_MONOTONIC)` для измерения времени в наносекундах. Итерации выполнялись **1 миллион** раз (для `open/close` — 100,000 раз). Используется флаг компиляции `-O2 -march=native` для максимальной оптимизации.

### Таблица результатов (1 миллион итераций)

| Операция | Среднее время (ns) | Циклов CPU (Оценка*) | Во ск. раз медленнее userspace |
| :--- | :--- | :--- | :--- |
| **dummy() userspace** | 2.12 | 10 | 1x (baseline) |
| **getpid()** (Быстрый Syscall) | 178.97 | 716 | $\mathbf{84.4\text{x}}$ |
| **open()+close()** (I/O Syscall) | 2806.00 | 11224 | $\mathbf{1323.6\text{x}}$ |
| **gettimeofday() vDSO** | 1226.26 | 4905 | $\mathbf{578.4\text{x}}$ |

*\* Оценка циклов CPU: сделана исходя из условной частоты $\approx 4\text{ GHz}$, так как прямое измерение `__rdtsc` для длинных циклов в данном коде не дало адекватных результатов.*

**Команды для воспроизведения:**
```bash
gcc -O2 -march=native -o ../benchmark benchmark.c
../benchmark 1000000
```
**Вывод программы:**
```
Iters=1000000

RESULTS (averages):
dummy()         : 2.122835 ns, 0.000026 cycles
getpid()        : 178.974576 ns
gettimeofday()  : 1226.258137 ns
open()+close()  : 2806.000000 ns (measured, 100000 iterations)

Raw cycles (dummy total): 26
Sink: 84000000
```
**Дополнительный замер: влияние кэша страниц**

***Эксперимент:*** Сравниваем время open() на файле, когда кэш страниц ядра сброшен (холодный), и когда файл кэширован (горячий).
Команды (требуют root):
```
# 1. Сброс кэша
sudo sync; sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches'

# 2. Запуск на Холодном кэше
../benchmark 100000

# 3. Запуск на Горячем кэше (сразу после, без сброса)
../benchmark 100000
```

**Результаты:**
| Состояние кэша | Время (ns) Open+Close | Разница (Холодный / Горячий) |
| :--- | :--- | :--- |
| Холодный кэш | $\mathbf{2815.00}\text{ ns}$ | $\mathbf{0.99\text{x}}$ (холодный быстрее горячего) |
| Горячий кэш | $\mathbf{2842.00}\text{ ns}$ | 1x |

## Проверка через perf stat
**Команда:**
```bash
perf stat -e cycles,instructions,context-switches,page-faults ../benchmark 1000000
```
*Вывод:*
```
WARNING: perf not found for kernel 6.14.0-29

  You may need to install the following packages for this specific kernel:
    linux-tools-6.14.0-29-generic
    linux-cloud-tools-6.14.0-29-generic

  You may also want to install one of the following packages to keep up to date:
    linux-tools-generic
    linux-cloud-tools-generic
```
**Выводы:**
Была использована команда:
```
sudo apt update
sudo apt install linux-tools-6.14.0-29-generic linux-cloud-tools-6.14.0-29-generic
```
Но даже после ее использование результаты не поменялись. Это является ограничением среды выполнения. В идеальных условиях, ```perf stat``` должен был показать низкое число context-switches ($\ll 1,000,000$) и низкое число page-faults (0), что подтвердило бы, что накладные расходы на системный вызов идут от переключения режима (mode switch), а не от переключения контекста (process switch).


## Ответы на вопросы к заданию B

### 1. Почему системный вызов в 50-100 раз медленнее userspace функции?

**Объясните механизм context switch (user mode → kernel mode)**

Системный вызов медленнее обычной функции, что подтверждается разницей в $\mathbf{84.4\text{x}}$ между `dummy()` ($\mathbf{2.12\text{ ns}}$) и `getpid()` ($\mathbf{178.97\text{ ns}}$).

Это происходит из-за **переключения режима (Mode Switch)**:
1.  Программа, работающая в User Mode, инициирует прерывание (через инструкцию `syscall`).
2.  Процессор переключается в более привилегированный **Kernel Mode**.
3.  **Что происходит с регистрами CPU?** Ядро сохраняет все регистры CPU и текущее состояние процесса (его "контекст") в памяти, чтобы после выполнения системного вызова восстановить их и позволить программе продолжить работу с того же места.
4.  **Почему ядро должно проверять права доступа?** Ядро должно проверить, имеет ли процесс право на выполнение запрошенной операции, чтобы обеспечить изоляцию процессов и защитить целостность системы и оборудования.

### 2. Почему open() в ~2000 раз медленнее getpid()?

**Приведите конкретные числа из ваших замеров**

Фактическое время, измеренное в бенчмарке: `open()+close()` ($\mathbf{2806.00\text{ ns}}$) медленнее `getpid()` ($\mathbf{178.97\text{ ns}}$) примерно в $\mathbf{15.7\text{x}}$ раз. Ожидаемая разница в $~2000$ раз достигается, когда `open()` требует обращения к физическому диску.

**Что делает `getpid()` vs `open()`:**
* **`getpid()`:** Минимальный syscall — ядро просто читает значение PID, которое кэшировано в структуре процесса.
* **`open()`:** Требует сложной работы **Файловой Системы (ФС)**: парсинг пути, поиск inode, проверка прав, блокировки.

**Как влияет кэш page cache? (используйте данные из эксперимента с drop\_caches)**

* **Наши замеры:** Холодный кэш ($\mathbf{2815.00\text{ ns}}$) и Горячий кэш ($\mathbf{2842.00\text{ ns}}$) почти не различаются ($\approx \mathbf{1.0\text{x}}$).
* **Вывод:** Это говорит о том, что файл `/tmp/benchmark_testfile` был **уже полностью кэширован в оперативной памяти (Page Cache)** даже после сброса кэшей (`drop_caches`). Таким образом, оба замера показывают время работы с RAM ядра.
* **Влияние:** Если бы кэш действительно сработал, "холодный" замер был бы медленнее "горячего" в $10-50$ раз, подтверждая, что Page Cache критически снижает накладные расходы на I/O.

### 3. Что такое vDSO и почему это важно?

**Что такое vDSO и как он избегает context switch?**

* **vDSO (virtual Dynamic Shared Object)** — это специальный блок кода ядра, спроецированный в адресное пространство процесса.
* **Важность и механизм:** Он позволяет выполнять быстрые, детерминированные операции (например, чтение времени) **напрямую в User Mode**, используя кэшированные данные ядра. Это полностью **избегает дорогостоящего переключения режима (Mode Switch)**, что делает вызов почти таким же быстрым, как обычная функция.
* **Какие ещё функции могут быть в vDSO?** Помимо `gettimeofday()` (который мы использовали как `clock_gettime(CLOCK_REALTIME)`), в vDSO часто реализуются такие функции, как `getcpu()`, `gettimeofday()` и `time()`.

### 4. Анализ perf stat вывода:

**На основании лога `perf stat` и ограничений среды:**

* **Сколько context switches произошло на 1 млн итераций? Почему не 1 млн?**
    Мы не смогли получить фактические данные из-за неработающего `perf`. Теоретически, число `context-switches` должно быть близко к $\mathbf{0}$. Это связано с тем, что `context-switch` — это переключение между **процессами/потоками**, а не между режимами (User $\leftrightarrow$ Kernel), которое происходит при каждом syscall.
* **Сколько page faults? О чём это говорит?**
    Предположительно $\mathbf{0}$ (Теоретически). Это говорит о том, что весь необходимый код и данные для выполнения бенчмарка были загружены в оперативную память на этапе запуска.
* **Какой IPC (instructions per cycle)? Высокий или низкий? Почему?**
    Предположительно $\mathbf{IPC} \gg 1.0$ (Высокий). Системные вызовы, хоть и медленные, занимают относительно малую долю от общего времени выполнения, и процессор эффективно выполняет инструкции в циклах `for` между вызовами.

### 5. Практические выводы:

* **Как эти знания помогут оптимизировать код?**
    1.  **Буферизация (Когда буферизация важна?):** Буферизация (например, в `stdio.h` через `printf`/`fwrite`) критически важна для I/O, чтобы заменить множество дорогих `read`/`write` (syscalls) на один крупный вызов, снижая накладные расходы на переключение режимов.
    2.  **Минимизация Syscalls:** Избегать системных вызовов в высокочастотных циклах.
* **В каких ситуациях стоит избегать системных вызовов?**
    В циклах с высокой итерацией, при работе с временем (использовать vDSO-оптимизированные функции) и в функциях, критичных к задержкам.

---

### Ответы на обязательные вопросы

### 1. Что такое системный вызов и чем он отличается от обычной функции?

**Системный вызов (syscall)** — это механизм, посредством которого программа, работающая в непривилегированном режиме пользователя (User Mode), запрашивает сервис у ядра операционной системы, которое работает в привилегированном режиме (Kernel Mode) .

**Отличие:**
1.  **Режим:** Обычная функция выполняется полностью в User Mode. Syscall требует **переключения режима (Mode Switch)** в Kernel Mode.
2.  **Доступ:** Ядро (Kernel Mode) имеет полный доступ к оборудованию, памяти и всем ресурсам. Программа (User Mode) имеет ограниченный доступ только к своей памяти.
3.  **Защита:** Syscall необходим для **защиты памяти** и изоляции процессов. Ядро проверяет права доступа, предотвращая прямой и бесконтрольный доступ программ к критическим ресурсам.

### 2. Почему системный вызов медленнее обычной функции?

Системный вызов медленнее, что подтверждается разницей в $\mathbf{84.4\text{x}}$ между `dummy()` ($\mathbf{2.12\text{ ns}}$) и `getpid()` ($\mathbf{178.97\text{ ns}}$) по нашим замерам.

**Причина:** Накладные расходы на **переключение режима (Mode Switch)**:
1.  **Механизм:** Требуется выполнение специальной инструкции процессора (`syscall`/`int`).
2.  **Сохранение регистров CPU:** Ядро должно сохранить все регистры CPU и текущее состояние процесса в User Mode, чтобы гарантировать его корректное восстановление.
3.  **Проверки прав:** Перед выполнением запроса ядро должно проверить права доступа и валидность аргументов, что добавляет время, но критически важно для безопасности.

### 3. Как работает LD_PRELOAD и в каких случаях он НЕ работает?

* **Как работает LD\_PRELOAD:** **LD\_PRELOAD** — это переменная окружения, которая принуждает **динамический линкер** (`ld.so`) загрузить указанную динамическую библиотеку-перехват (`libsyscall_spy.so`) **раньше всех остальных** (включая `libc`). Таким образом, при разрешении символов (`dlsym(RTLD_NEXT, ...)`), линкер использует нашу функцию-перехват.
* **В каких случаях НЕ работает:**
    1.  **Статические программы:** Как показано в **Эксперименте 3**, статические бинарники **не используют динамический линкер**, так как все библиотечные функции встроены. Перехват невозможен.
    2.  **Setuid/Setgid бинарники:** Для предотвращения повышения привилегий через внедрение вредоносного кода, ядро игнорирует `LD_PRELOAD` для программ с установленным флагом `setuid`/`setgid`.

### 4. Что такое vDSO и зачем он нужен?

* **Что такое vDSO:** **vDSO (virtual Dynamic Shared Object)** — это специальный блок кода ядра, спроецированный в адресное пространство процесса (User Mode).
* **Зачем нужен:** Он позволяет выполнять частые и быстрые операции (например, чтение времени) **напрямую в User Mode**, используя кэшированные данные ядра, и **избегать дорогостоящего переключения режима (Mode Switch)**.
* **Как vDSO избегает context switch:** Поскольку вся необходимая логика и данные находятся в User Mode, процессу не нужно инициировать syscall, сохранять контекст и переключаться в Kernel Mode.
* **Какие ещё функции могут быть в vDSO?** Функции, которые требуют только чтения состояния ядра, но не записи или доступа к оборудованию: `gettimeofday()`, `time()`, `getcpu()`.

### 5. Почему open() медленнее getpid() на несколько порядков?

Фактическое время, измеренное в бенчмарке: `open()+close()` ($\mathbf{2806.00\text{ ns}}$) медленнее `getpid()` ($\mathbf{178.97\text{ ns}}$) примерно в $\mathbf{15.7\text{x}}$ раз.

* **Причина:** `open()` требует работы всей **Файловой Системы (ФС)**: парсинг пути, поиск inode, проверка прав доступа.
* **Влияние Page Cache:** Самый большой фактор. В нашем эксперименте Page Cache был "горячий" (сравнение: Холодный $\mathbf{2815\text{ ns}}$ vs Горячий $\mathbf{2842\text{ ns}}$). Если бы кэш был действительно сброшен и потребовалось обращение к **диску**, задержка могла бы достигать $\mathbf{35,000-50,000\text{ ns}}$, что подтверждает, что `open()` потенциально медленнее на порядки.

---

## Воспроизводимость

### Команды для полного воспроизведения

*Примечание: предполагается, что сборка происходит из корневой директории lab4/gr1sub1/Джига_Анна/.*

```bash
# --- 1. СБОРКА ---
# Сборка LD_PRELOAD библиотеки
gcc -shared -fPIC -o ../libsyscall_spy.so syscall_spy.c -ldl

# Сборка бенчмарка
gcc -O2 -march=native -o ../benchmark benchmark.c

# --- 2. ЗАДАНИЕ A (LD_PRELOAD) ---
# Эксперимент с curl
LD_PRELOAD=../libsyscall_spy.so curl -vI https://example.com 2> ../logs/curl_spy.log

# Эксперимент с wget
LD_PRELOAD=../libsyscall_spy.so wget -O - https://example.com 2> ../logs/wget_spy.log

# Проверка на статической программе (пример)
gcc -static -o ../hello_static src/hello.c
LD_PRELOAD=../libsyscall_spy.so ../hello_static > ../logs/hello_spy.log

# --- 3. ЗАДАНИЕ B (BENCHMARK) ---
# Основной замер (1 млн итераций)
../benchmark 1000000 > ../logs/benchmark_full.log

# Замер Холодный/Горячий кэш
sudo sync; sudo sh -c 'echo 3 > /proc/sys/vm/drop_caches'
../benchmark 100000 > ../logs/benchmark_cold.log
../benchmark 100000 > ../logs/benchmark_hot.log

# Запуск perf (для получения лога)
# (Несмотря на ошибку, команда должна быть приведена)
perf stat -e cycles,instructions,context-switches,page-faults ../benchmark 1000000 2> ../logs/perf_stat_full.log
```

---

## Общие выводы

### Что нового узнали о работе syscalls?
Узнали, что "простые" библиотечные функции C, такие как `open()` и `read()`, на самом деле являются сложными операциями, требующими **переключения режима** процессора. Обнаружили, что сетевые программы (`curl`, `wget`) в первую очередь делают не `open`/`close` файлов, а множество мелких `read`/`write` на сокеты, а также проверяют неочевидные системные псевдо-файлы (вроде `/proc/sys/crypto/fips_enabled`) для оценки безопасности.

### Какие инструменты показались наиболее полезными?
1.  **LD\_PRELOAD** (и наша библиотека `libsyscall_spy.so`): Самый полезный инструмент. Позволил детально "прослушать" программу изнутри, не меняя ее исходного кода, и отследить, какие файлы открываются, даже если они не существуют (поиск конфигов).
2.  **Бенчмарк C (`__rdtsc`):** Критически важен для измерения накладных расходов в наносекундах и сравнения производительности разных типов вызовов.

### Какие трудности возникли?
1.  **Сброс кэша:** Эксперимент с `drop_caches` показал, что файл `/tmp/benchmark_testfile` оставался кэшированным в RAM ядра, что помешало получить замер "холодного" обращения к диску.
2.  **Проблема с `perf`:** Утилита `perf stat` не заработала для текущей версии ядра (`6.14.0-29-generic`), что помешало получить точные данные об IPC, циклах и количестве переключений контекста.
3.  **Аномалия vDSO:** Замер `gettimeofday()` оказался аномально высоким, что указывает либо на неполное использование vDSO, либо на дополнительные накладные расходы на синхронизацию.

### Как понимание границы userspace↔kernel поможет в дальнейшем изучении Linux?
Понимание границы userspace $\leftrightarrow$ kernel — это фундаментальная база:
1.  **Оптимизация:** Знание того, что syscall стоит в $\mathbf{84\text{x}}$ раз дороже простой функции, побуждает к использованию буферизации (`printf`, `fwrite`) и минимизации прямого I/O в высокопроизводительном коде.
2.  **Отладка:** Понимание, что программа ищет конфиги или проверяет `/proc`/`/sys` (как в случае с `fips_enabled`), помогает быстро диагностировать проблемы безопасности или совместимости.
3.  **Разработка ядра:** Это знание необходимо для разработки драйверов и модулей, которые работают непосредственно в Kernel Mode.

*Дополнительные данные:*
ИИ использовался только при обнаружении ошибки perf, ему был приведен вопрос как это исправить и в ответ не было получено решения. 