# Keylogger Kernel Module

**Студент:** Лебедев Денис, группа 9, подгруппа 2.

## 1. Цель работы

Изучить механизм работы модулей ядра Linux, освоить API для перехвата событий клавиатуры (`keyboard notifier`) и реализовать модуль-кейлоггер с асинхронной записью данных в файл.

## 2. Шаги выполнения

1.  **Проектирование модуля**:

    - Определена основная логика: перехват события, преобразование скан-кода в символ, буферизация и запись в файл.
    - Для асинхронной записи выбраны рабочие очереди (`workqueue`), чтобы не блокировать обработчик прерывания клавиатуры.
    - Реализована двойная буферизация для предотвращения гонок данных и потерь событий при записи.

2.  **Реализация**:

    - Написан код модуля `keylogger.c`.
    - Для перехвата событий использована функция `register_keyboard_notifier`, которая регистрирует callback-функцию, вызываемую при каждом событии клавиатуры.
    - В callback-функции (`keyboard_callback`) происходит фильтрация событий (только нажатия клавиш), преобразование скан-кода в строку и сохранение в активный буфер.
    - При заполнении буфера или нажатии Enter он ставится в очередь на запись, и активным становится второй буфер.
    - Запись в файл выполняется в отдельном потоке (`workqueue`) функцией `kernel_write`.
    - Синхронизация не выполняется, т.к. нельзя блокироваться в ядре, иначе может возникнуть дедлок или зависание системы. Поэтому где-то возможна гонка и потеря данных, но для учебного кейлоггера это приемлемо.

3.  **Сборка и отладка**:
    - Создан `Makefile` для компиляции модуля с помощью системы сборки ядра Linux.
    - Для отладки использовались `dmesg` и `pr_info`/`pr_err` для вывода сообщений о состоянии модуля.
    - Модуль тестировался на виртуальной машине с ядром Linux 5.15.

## 3. Выводы

В ходе работы я на практике изучил:

- Жизненный цикл модулей ядра (`init`, `exit`).
- Механизм `notifiers` для подписки на события ядра.
- Работу с файловой системой из пространства ядра (`filp_open`, `kernel_write`, `filp_close`).
- Важность асинхронной обработки данных для производительности системы.
- Риски, связанные с разработкой в пространстве ядра: одна ошибка может привести к `Kernel Panic`.

Реализованный модуль успешно перехватывает нажатия клавиш и сохраняет их в лог-файл, демонстрируя понимание ключевых концепций.

## 4. Ответы на контрольные вопросы

**Вопрос 1: Почему нельзя выполнять длительные операции (например, запись в файл) напрямую в callback-функции `notifier`?**
_Ответ:_ Callback-функция `notifier` для событий клавиатуры выполняется в контексте прерывания (atomic context). В этом контексте блокирующие операции, такие как прямая запись на диск, недопустимы, так как это заморозит обработку других важных системных событий и может привести к зависанию или падению системы. Для этого и используются механизмы отложенного выполнения, такие как `workqueue`.

**Вопрос 2: Какие риски безопасности несёт в себе разработанный модуль?**
_Ответ:_ Основной риск — несанкционированный доступ к конфиденциальной информации (паролям, личной переписке). Поскольку модуль работает на уровне ядра, он может перехватить абсолютно все нажатия клавиш в системе. Любая уязвимость в самом модуле (например, переполнение буфера) может быть использована для компрометации всей операционной системы.

## 5. Как проверяли

1.  Модуль компилировался командой `make`.
2.  Загружался в ядро: `sudo insmod keylogger.ko`.
3.  В другом терминале открывался текстовый редактор, где вводился тестовый текст.
4.  Содержимое лог-файла проверялось: `sudo cat /root/kkey`.
5.  Корректность выгрузки проверялась командой `sudo rmmod keylogger` и просмотром `dmesg`.

## 6. Использование AI

При выполнении данной работы AI-инструменты (GitHub Copilot, Claude) использовались для:

- **Проверки кода**: выявление потенциальных ошибок и уязвимостей
- **Отладки**: помощь в диагностике проблем с синхронизацией и обработкой ошибок
- **Документации**: структурирование и улучшение читаемости отчёта и README
- **Обзора best practices**: рекомендации по использованию механизмов ядра (spinlock, workqueue, atomic операции)

Основная логика и архитектура модуля разработаны самостоятельно на основе изученных материалов по разработке модулей ядра Linux.
