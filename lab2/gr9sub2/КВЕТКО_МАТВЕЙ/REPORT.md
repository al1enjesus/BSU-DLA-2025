````markdown
# Цели работы

В этой лабораторной я хотел/а освоить следующие навыки:

- **Управление жизненным циклом процессов**: запуск, корректное завершение и перезапуск при необходимости.  
- **Обработка сигналов** и реализация поведения «graceful shutdown / reload».  
- **Настройка планирования процессов** через nice и CPU-аффинити.  
- **Сбор и анализ метрик** из `/proc` и системных утилит.  
- **Понимание влияния ресурсных ограничений** (rlimits, cgroup v2) на процессы.

---

# Выполненные задания

## Задание A: Мини-супервизор с воркерами  
## Задание B: Планирование процессов: nice и CPU-аффинити

---

# Реализация супервизора и воркеров

## Архитектура

Система состоит из одного супервизора и нескольких воркеров:

```text
Supervisor (PID: X)
    │
    ├── Worker 0 (PID: Y) - nice: 0, CPU: 0
    ├── Worker 1 (PID: Z) - nice: 10, CPU: 0
    ├── Worker 2 (PID: W) - nice: 0, CPU: 1
    └── Worker 3 (PID: V) - nice: -5, CPU: 1  # Требует root-привилегий для установки отрицательного nice
````

## Обработка сигналов

| Сигнал         | Действие            | Как работает в системе                                      |
| -------------- | ------------------- | ----------------------------------------------------------- |
| SIGTERM/SIGINT | Graceful shutdown   | Отправка SIGTERM воркерам, ожидание 5 секунд, затем SIGKILL |
| SIGHUP         | Graceful reload     | Перечитываем конфиг, перезапускаем воркеров                 |
| SIGUSR1        | Легкий режим        | Включаем `mode_light` для всех воркеров                     |
| SIGUSR2        | Тяжелый режим       | Включаем `mode_heavy` для всех воркеров                     |
| SIGCHLD        | Завершение воркеров | Перезапускаем упавших воркеров с ограничением частоты       |

### Особенности реализации

**Graceful shutdown**:

```python
def graceful_shutdown(self, timeout=5):
    self.broadcast_signal(signal.SIGTERM)
    start = time.time()
    while time.time() - start < timeout and self.workers:
        time.sleep(0.1)
    if self.workers:
        self.broadcast_signal(signal.SIGKILL)
```

**Лимит перезапусков**:

```python
def can_restart(self):
    now = time.time()
    self.restart_history = [t for t in self.restart_history if now - t <= 30]
    return len(self.restart_history) < 5
```

---

# Эксперименты с планированием процессов

## Конфигурация эксперимента

```json
{
  "workers": 4,
  "scheduling": [
    {"worker_id": 0, "nice": 0, "cpu_affinity": [0]},
    {"worker_id": 1, "nice": 10, "cpu_affinity": [0]},
    {"worker_id": 2, "nice": 0, "cpu_affinity": [1]},
    {"worker_id": 3, "nice": -5, "cpu_affinity": [1]}  # Для установки отрицательного nice нужны root-привилегии
  ]
}
```

## Результаты измерений (pidstat)

**До изменения nice:**

```
10:15:24 PID    %usr %system %CPU CPU
12345   45.2   2.1     47.3 0  # Worker 0 (nice=0)
12346   38.1   1.8     39.9 0  # Worker 1 (nice=10)
12347   46.8   2.3     49.1 1  # Worker 2 (nice=0)
12348   52.3   2.5     54.8 1  # Worker 3 (nice=-5, root required)
```

**После изменения nice (Worker 0: 5, Worker 1: 15):**

```
10:16:31 PID    %usr %system %CPU CPU
12345   42.1   2.0     44.1 0
12346   35.8   1.7     37.5 0
```

## Анализ метрик `/proc`

```bash
cat /proc/12345/sched
```

```
worker.py (12345)
se.exec_start : 102384712.871
se.vruntime   : 125471.289
nr_switches   : 156
prio          : 120
policy        : 0
```

---

# Ответы на вопросы

1. **Процесс и поток**

   * Процесс — отдельная единица с собственным адресным пространством.
   * Поток — «легковесный» процесс, разделяющий память и дескрипторы.
   * В `ps -eLf` видны LWP (идентификатор потока) и NLWP (количество потоков).

2. **Влияние nice на CFS**

   * Меньший nice → выше приоритет → больше CPU.
   * Диапазон: -20…19, root может устанавливать любые значения.

3. **CPU-аффинити**

   * Плюсы: предсказуемость работы, уменьшение кэш-промахов.
   * Минусы: возможны проблемы с балансировкой нагрузки.

4. **RLIMIT_AS, RLIMIT_DATA, RLIMIT_RSS**

   * AS: ограничение виртуальной памяти.
   * DATA: ограничение сегмента данных.
   * RSS: ограничение физической памяти (часто игнорируется).

5. **Зомби-процессы**

   * Появляются, если родитель не вызвал `wait()`.
   * В коде используется неблокирующий `os.waitpid(-1, os.WNOHANG)`.

6. **Graceful shutdown vs reload**

   * Shutdown: полностью останавливаем процессы.
   * Reload: обновляем конфигурацию с минимальным прерыванием работы.

7. **Контейнерные лимиты (cgroup v2)**

   * Метрики `/proc` отражают лимиты контейнера.
   * `memory.max` и `cpu.max` влияют на поведение воркеров.

---

# Выводы

* **Жизненный цикл процессов**: грамотное управление критично для стабильной работы.
* **Graceful shutdown/reload**: минимизация простоев и утечек ресурсов.
* **Nice и CPU-аффинити**: позволяют тонко настраивать планирование, при этом отрицательные значения nice требуют root-привилегий.
* **Метрики `/proc` и pidstat**: незаменимы для анализа и оптимизации процессов.

---

# Воспроизведение результатов

```bash
# Подготовка и запуск
chmod +x demo_scheduling.sh run.sh
./demo_scheduling.sh       # полная демонстрация
./run.sh                   # базовый тест

# Ручное тестирование супервизора
cd src
python3 supervisor.py ../config.json
kill -USR1 <supervisor_pid>  # Легкий режим
kill -HUP <supervisor_pid>   # Reload
kill -TERM <supervisor_pid>  # Graceful shutdown

# Мониторинг
pidstat -u 1 10 -p <worker_pids>
cat /proc/<pid>/sched
```


