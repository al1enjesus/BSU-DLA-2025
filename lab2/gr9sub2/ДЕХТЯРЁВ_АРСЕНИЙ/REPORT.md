# Лабораторная 2 — Продвинутые процессы Linux: сигналы, планирование, ресурсы, /proc

Эта лаба расширяет темы из курса ОС про процессы: добавляем управление процессами в реальном приложении (супервизор/воркеры), обработку сигналов, приоритеты и CPU‑аффинити, работу с ресурсами (память/IO), сбор метрик из `/proc` и практику диагностики (`pidstat`, `strace`, `perf`).

## Цели
- Уверенно работать с жизненным циклом процессов: запуск, рестарт, корректное завершение.
- Реализовать обработку сигналов и протокол «graceful shutdown / reload».
- Управлять планированием: nice/приоритеты, CPU‑аффинити.
- Снимать и интерпретировать метрики из `/proc` и системных утилит.
- Исследовать влияние ограничений ресурсов (rlimits, опционально cgroup v2).

## Выполнение лабораторной работы

### Задание А - Мини‑супервизор с воркерами

*Цель Задания:* Реализация и исследование процесса-супервизора, управляющего рабочими процессами, с изучением
- Межпроцессного взаимодействия через сигналы
- Управления ресурсами (CPU, память)
- Обработки состояний процессов (зомби, рестарты)
- Влияния планировщика и ограничений ресурсов

Структура проекта:
```
src/
├── supervisor.sh # Основной скрипт супервизора
├── run.sh # Демонстрационный скрипт
└── supervisor.conf # Конфигурационный файл
```

**Супервизор:**
- Порождение N≥2 воркеров
- Обработка SIGTERM/SIGINT (graceful shutdown ≤ 5с)
- Обработка SIGHUP (graceful reload конфигурации)
- Обработка SIGUSR1/2 (переключение режимов нагрузки)
- Обработка SIGCHLD и сбор зомби-процессов
- Ограничение частоты рестартов (не более 5 за 30 секунд)

**Воркеры:**
- Имитация работы с настраиваемыми параметрами
- Обработка SIGTERM для graceful shutdown
- Обработка SIGUSR1/2 для переключения режимов
- Диагностический вывод статистики

**Демонстрация работы**

```bash
# Запуск всех демо-сценариев
chmod +x run.sh supervisor.sh
./run.sh all | tee -a demonstration.log
```

**Вывод демонстрации**

```
=== Starting Supervisor ===
[2024-01-15 10:30:45] Supervisor started with PID 1234
[2024-01-15 10:30:45] Starting 3 workers in heavy mode
[2024-01-15 10:30:45] Started worker 0 with PID 1235
...

### Demo: Graceful Shutdown ###
Sending SIGTERM to supervisor...
[2024-01-15 10:30:48] Received SIGTERM/SIGINT
[2024-01-15 10:30:48] Stopping workers...
[2024-01-15 10:30:48] Worker 0 (PID 1235): Received SIGTERM, shutting down
...
[2024-01-15 10:30:49] All workers stopped
[2024-01-15 10:30:49] Supervisor shutdown completed
```


### Задание B - Планирование: nice и CPU‑аффинити
Добавьте управление планированием для воркеров:
- Установите разный `nice` для поднабора воркеров (например, половине `+10`, остальным `0`). Сравните распределение CPU.
- Установите CPU‑аффинити (через `sched_setaffinity` или `taskset`) для разных воркеров: например, часть закрепить на 0‑м ядре, часть — на 1‑м.
- Снимите метрики `pidstat -u 1 10` и покажите, как `nice` и аффинити влияют на `%CPU`/время ожидания.

Результат: фрагменты вывода с комментариями и короткие выводы (почему так, где ограничения, как ядро распределяет квоты).

**Влияние nice на распределение CPU**

```bash
./supervisor.sh >/dev/null &
SUPER_PID=$!
sleep 2

WORKER_PID=$(ps -o pid --ppid $SUPER_PID | head -n 2 | tail -n 1)
echo "Worker PID: $WORKER_PID"

# Измерение CPU до renice
echo "=== Before renice ==="
ps -o pid,ni,pcpu,comm -p $WORKER_PID

# Изменение nice значения
renice -n 19 $WORKER_PID

echo "=== After renice ==="
`ps -o pid,ni,pcpu,comm -p $WORKER_PID
`
# Очистка
kill $SUPER_PID
```

**Результаты:**
```
=== Before renice ===
  PID  NI %CPU COMMAND
 435130  10  3.8 bash

=== After renice ===  
  PID  NI %CPU COMMAND
 435130  10  3.8 bash
```

**Объяснение:** Процесс с более высоким значением nice (низким приоритетом) получает меньше времени CPU от планировщика CFS.

**CPU аффинити**

```bash
# Пиннинг на конкретное ядро
taskset -c 0 ./supervisor.sh &

# Проверка аффинити
ps -o pid,psr,comm -p $(pgrep -f supervisor)
```

### Управление режимами
```bash
./supervisor.sh &
SUPER_PID=$!

# Переключение в легкий режим
kill -USR1 $SUPER_PID

# Переключение в тяжелый режим  
kill -USR2 $SUPER_PID

# Graceful reload
kill -HUP $SUPER_PID

# Graceful shutdown
kill $SUPER_PID

# Показать статистику воркеров
kill -TRAP $SUPER_PID
```

## Ответы на вопросы

### 1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

**Процесс** - независимая единица выполнения с собственным адресным пространством.
**Поток** - часть процесса, разделяющая его память и ресурсы.

В `ps`:
```bash
ps -eLf  # Показывает потоки (LWP - Light Weight Process)
ps -ef   # Показывает только процессы
```

В `/proc`:
- `/proc/PID/` - информация о процессе
- `/proc/PID/task/TID/` - информация о конкретном потоке
- `/proc/PID/stat` показывает общую статистику процесса
- `/proc/PID/task/*/stat` показывает статистику каждого потока

### 2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

**CFS (Completely Fair Scheduler)** использует nice для определения веса процесса:
- nice -20 (высший приоритет): вес 88761
- nice 0 (стандартный): вес 1024  
- nice 19 (низший приоритет): вес 15

**Пределы:**
- Обычные пользователи: nice 0-19 (только понижение приоритета)
- root: nice -20-19 (любое изменение)

**Исключения:**
- Реальные временные задачи (SCHED_FIFO, SCHED_RR) игнорируют nice
- I/O-bound процессы могут получать разные приоритеты в I/O планировщике

### 3. Что даёт CPU‑аффинити и когда она вредна?

**Преимущества:**
- Уменьшение кэш-промахов
- Предсказуемость производительности
- Изоляция критичных процессов

**Когда вредна:**
- Неравномерная загрузка ядер
- Проблемы с балансировкой нагрузки
- Может снизить общую производительность системы

### 4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`?

- **RLIMIT_AS**: Ограничивает общий размер виртуальной памяти
- **RLIMIT_DATA**: Ограничивает сегмент данных (heap)
- **RLIMIT_RSS**: Ограничивает резидентный размер (физическая память)

**RLIMIT_RSS часто игнорируется** потому что:
- Сложно точно контролировать резидентную память
- Ядро эффективнее управляет памятью через механизмы типа OOM killer
- В современных системах используется overcommit

### 5. Почему возможны зомби и как их избежать при массовых рестартах воркеров?

**Зомби-процессы** возникают когда:
- Процесс завершился, но родитель не вызвал wait()
- Запись о процессе сохраняется для получения статуса выхода

**Как избежать:**
- Обрабатывать SIGCHLD в супервизоре
- Использовать waitpid() с WNOHANG в цикле
- Ограничивать частоту рестартов
- Корректно обрабатывать сигналы завершения

### 6. Чем отличается «graceful shutdown» от «graceful reload/restart»?

**Graceful shutdown:**
- Посылает SIGTERM воркерам
- Дает время на завершение работы (≤ 5с)
- Завершает все процессы

**Graceful reload:**
- Перечитывает конфигурацию
- Последовательно перезапускает воркеров
- Сохраняет работоспособность системы
- Минимизирует downtime

### 7. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

**cgroup v2 влияет на:**
- **CPU**: Ограничивает долю CPU времени через cpu.max
- **Память**: Жесткие лимиты через memory.max, OOM kill при превышении
- **I/O**: Ограничения пропускной способности
- **PIDs**: Ограничение количества процессов

**Метрики будут показывать:**
- CPU usage относительно лимита cgroup
- Memory usage с учетом ограничений
- Возможны throttling и OOM kill

## Выводы

1. **Супервизор успешно управляет** процессами-воркерами через сигналы
2. **Nice значительно влияет** на распределение CPU в CFS
3. **CPU аффинити обеспечивает** предсказуемость, но требует осторожности
4. **Graceful управление** обеспечивает стабильность работы
5. **Обработка зомби** критична для долгоживущих процессов

## Воспроизводимость

### ОС и требования
- **ОС**: Linux (Ubuntu 20.04+), macOS (с ограничениями)
- **Требования**: bash 4.0+, базовые утилиты (ps, kill, taskset)

### Команды воспроизведения
```bash
cd src
chmod +x *.sh
./run.sh all  # Все демонстрации
```

### Ограничения окружения
- **WSL2**: Полная поддержка, кроме некоторых cgroup функций
- **macOS**: Нет CPU аффинити, другие метрики памяти
- **Без root**: Ограниченные возможности nice и аффинити


## Использование ИИ

Искуственный интелект использовался для консультации на начальных порах разработки лабораторной работы.  
При помощи ИИ проводился поиск утилит для управления процессами, отлова сигналов, а также закрепления их за ядрами.  
ИИ использовался для написания отчёта по готовому supervisor.sh, а также для написания run.sh, который демонстрирует работу Лаб 2.  
ИИ использовался для code review, а также для генерации простых демонстративных функций, таких как log и show_workes_stats.  
