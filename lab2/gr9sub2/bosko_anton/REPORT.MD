# REPORT.MD — Лабораторная 2 (A, B, D*)

---

## Что сделано

* Реализован `src/supervisor.py` и `src/worker.py`. Супервизор:

  * порождает N≥2 воркеров;
  * обрабатывает SIGCHLD, SIGTERM/SIGINT (graceful shutdown ≤5s), SIGHUP (reload), SIGUSR1/2 (переключение режимов);
  * рестартует упавших детей с ограничением частоты рестартов.
* Воркеры имитируют нагрузку (busy work + sleep), обрабатывают SIGTERM, SIGUSR1, SIGUSR2 и печатают PID, режим и тик.
* Реализовано назначение `nice` (чётные воркеры — nice 0, нечётные — nice +10).
* Сделан минимальный эксперимент по памяти (инструкции для mem_touch / ulimit).

---

## Как запустить (копировать и запускать)

1. Запустить супервизор:

```bash
export PYTHONUNBUFFERED=1
./run.sh
# либо напрямую:
python3 src/supervisor.py config.yaml &
echo $! > supervisor.pid
```

2. Проверить воркеры:

```bash
ps -ef | grep worker.py | grep -v grep
```

3. Примеры сигналов:

```bash
SUP_PID=$(cat supervisor.pid)
kill -USR1 $SUP_PID   # все воркеры -> LIGHT
kill -USR2 $SUP_PID   # все воркеры -> HEAVY
kill -HUP $SUP_PID    # reload config (graceful restart)
kill -TERM $SUP_PID   # graceful shutdown
```

---

## Эксперименты и примеры команд

### A) Сигналы и graceful

* Запустил супервизор, отправлял SIGUSR1/SIGUSR2 для переключения режимов, SIGHUP для перезагрузки воркеров, SIGTERM для завершения.
* Наблюдал в логах смену режима в воркерах и корректное завершение в пределах 5 секунд.

### B) Планирование (nice, affinity)

* Снимал метрики командой:

```bash
pidstat -u 1 10 -p <pid1>,<pid2>
```

* Фрагмент реального вывода, который был снят:

```
pidstat -u 1 10 -p 13380
Linux 6.14.0-32-generic (anton-QEMU-Virtual-Machine) 	09/25/2025 	_aarch64_	(4 CPU)

10:28:09 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
10:28:10 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     0  python3
10:28:11 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     1  python3
10:28:12 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     1  python3
10:28:13 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     1  python3
10:28:14 PM  1000     13380    0.99    0.00    0.00    0.00    0.99     0  python3
10:28:15 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     0  python3
10:28:16 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     0  python3
10:28:17 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     0  python3
10:28:18 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     0  python3
10:28:19 PM  1000     13380    0.00    0.00    0.00    0.00    0.00     3  python3
```

* Комментарий: при реальной конкуренции за одно ядро процесс с меньшим nice получит большую долю CPU. В данном фрагменте видим, что процесс загружался редко (в большинстве интервалов %CPU ~0), в одном интервале — ~1%.

### D) Память

* Скрипт/утилита `mem_touch` или аналог запускается и по шагам пишет в память; на каждом шаге снимаются:

```bash
pid=$(pgrep -f mem_touch.py)
cat /proc/$pid/status | egrep 'VmSize|VmRSS|VmPeak'
pidstat -r 1 10 -p $pid
free -h
```

* Тест ограничения через `ulimit`:

```bash
bash -c "ulimit -v $((200*1024)); python3 src/mem_touch.py --rss-mb 300 --step-mb 64 --sleep-ms 200"
```

* Ожидаемое поведение: при превышении лимита — malloc/alloc выдаст ошибку либо процесс упадёт; RSS растёт по мере реального «трогания» страниц.

---

## Короткие ответы на контрольные вопросы

1. **Процесс vs поток**: процесс — отдельное адресное пространство; поток — лёгкая единица в том же адресном пространстве. Видно в `ps -eLf` (LWP) и в `/proc/<pid>/task/`.
2. **nice и CFS**: `nice` меняет относительный приоритет; при конкуренции CFS даст больше процессорного времени процессу с меньшим nice. Снижение nice (дать более высокий приоритет) обычно требует root.
3. **CPU-affinity**: закрепление на ядре улучшает локальность кэша и детерминированность, но может навредить, если ядро перегружено или мешает балансировке.
4. **RLIMIT_AS / RLIMIT_DATA / RLIMIT_RSS**: `AS` — виртуальное пространство; `DATA` — сегмент данных; `RSS` — физическая память. `RLIMIT_RSS` часто игнорируется ядром/overcommit'ом.
5. **Зомби и массовые рестарты**: зомби появляются если родитель не вызывает `wait()`; избегают обработкой SIGCHLD и вызовом `waitpid(-1, WNOHANG)` в цикле.
6. **Graceful shutdown vs reload**: shutdown — остановить и выйти; reload — перечитать конфиг и перезапустить воркеры без большого прерывания. Безопасная последовательность: послать SIGTERM, ждать таймаут, затем SIGKILL оставшимся.
7. **cgroup v2 и метрики**: cgroup v2 ставит жёсткие лимиты (memory.max). При превышении процессы в группе могут быть убиты — это видно в `/proc/<pid>/status` и dmesg.

---

## Выводы

* На практике: `nice` и `affinity` работают заметно только при конкуренции за CPU; для чистых sleep/неинтенсивных задач эффекта не видно.
* Для контроля памяти надёжнее использовать cgroup v2, `ulimit`/`setrlimit` работают, но поведение зависит от overcommit и способа аллокации.
* Супервизор + сигналы — простой и надёжный механизм: SIGUSR1/2 для переключений, SIGHUP для reload, SIGTERM для graceful shutdown.

---

## Примечание

Код Python-файлов (супервизор/воркер) и база для экспериментов были сгенерированы и отлажены с помощью ИИ (ChatGPT). Я проверял и запускал всё лично, оформил выводы и результаты в этом отчёте.

