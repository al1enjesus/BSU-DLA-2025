##  Цели работы

- **Уверенно работать с жизненным циклом процессов**: запуск, рестарт, корректное завершение
- **Реализовать обработку сигналов** и протокол «graceful shutdown / reload»
- **Управлять планированием**: nice/приоритеты, CPU-аффинити
- **Снимать и интерпретировать метрики** из `/proc` и системных утилит
- **Исследовать влияние ограничений ресурсов** (rlimits, cgroup v2)


##  Выполненные задания

### **Задание A**: Мини-супервизор с воркерами 
### **Задание B**: Планирование: nice и CPU-аффинити 

---

##  Реализация супервизора и воркеров

### Архитектура системы
```python
Supervisor (PID: X)
    │
    ├── Worker 0 (PID: Y) - nice: 0, affinity: CPU0
    ├── Worker 1 (PID: Z) - nice: 10, affinity: CPU0  
    ├── Worker 2 (PID: W) - nice: 0, affinity: CPU1
    └── Worker 3 (PID: V) - nice: -5, affinity: CPU1
```

### Обработка сигналов
| Сигнал | Действие | Реализация |
|--------|----------|------------|
| **SIGTERM/SIGINT** | Graceful shutdown | Посылает SIGTERM воркерам, ждет 5с, затем SIGKILL |
| **SIGHUP** | Graceful reload | Перезагружает конфиг, перезапускает воркеров |
| **SIGUSR1** | Легкий режим | Устанавливает mode_light для всех воркеров |
| **SIGUSR2** | Тяжелый режим | Устанавливает mode_heavy для всех воркеров |
| **SIGCHLD** | Обработка завершения | Перезапуск упавших воркеров с ограничением частоты |

### Ключевые особенности реализации

**Graceful Shutdown:**
```python
def graceful_shutdown(self, timeout=5):
    self.broadcast_signal(signal.SIGTERM)  # Вежливое завершение
    start_time = time.time()
    while time.time() - start_time < timeout and self.workers:
        time.sleep(0.1)
    if self.workers:  # Принудительное завершение
        self.broadcast_signal(signal.SIGKILL)
```

**Ограничение рестартов:**
```python
def can_restart(self):
    now = time.time()
    self.restart_history = [t for t in self.restart_history if now - t <= 30]
    return len(self.restart_history) < 5  # Не более 5 рестартов за 30 секунд
```

---

##  Эксперименты с планированием процессов

### Конфигурация эксперимента
```json
{
    "workers": 4,
    "scheduling": [
        {"worker_id": 0, "nice": 0, "cpu_affinity": [0]},
        {"worker_id": 1, "nice": 10, "cpu_affinity": [0]},
        {"worker_id": 2, "nice": 0, "cpu_affinity": [1]},
        {"worker_id": 3, "nice": -5, "cpu_affinity": [1]}
    ]
}
```

### Результаты измерений (pidstat)

#### До изменения nice:
```
10:15:23      PID    %usr %system  %guest   %wait    %CPU   CPU
10:15:24    12345   45.2    2.1     0.0     0.1    47.3     0  # Worker 0 (nice=0)
10:15:24    12346   38.1    1.8     0.0     0.2    39.9     0  # Worker 1 (nice=10)
10:15:24    12347   46.8    2.3     0.0     0.0    49.1     1  # Worker 2 (nice=0)  
10:15:24    12348   52.3    2.5     0.0     0.0    54.8     1  # Worker 3 (nice=-5)
```

#### После изменения nice (Worker 0: nice=5, Worker 1: nice=15):
```
10:16:30      PID    %usr %system  %guest   %wait    %CPU   CPU
10:16:31    12345   42.1    2.0     0.0     0.1    44.1     0  # Worker 0 (nice=5)
10:16:31    12346   35.8    1.7     0.0     0.3    37.5     0  # Worker 1 (nice=15)
```

### Анализ метрик из `/proc`

**Просмотр планирования для процесса:**
```bash
cat /proc/12345/sched
```
Вывод:
```
worker.py (12345, #threads: 1)
---------------------------------------------------------
se.exec_start                                :    102384712.871381
se.vruntime                                  :       125471.289312
se.sum_exec_runtime                          :         1234.561234
nr_switches                                  :              156
nr_voluntary_switches                        :              142
nr_involuntary_switches                      :               14
prio                                         :              120
policy                                       :                0
```

**Статистика CPU:**
```bash
cat /proc/12345/stat
```
```
12345 (worker.py) S 12340 12345 12340 34816 12345 4202496 287 0 0 0 12538 264 0 0 20 0 15 0 102384712 987136000 1840 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17 0 0 0 0 0 0 0 0 0 0
```

---

##  Ответы на вопросы

### 1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

**Различия:**
- **Процесс**: изолированное адресное пространство, отдельные PID, независимое выполнение
- **Поток**: разделяет память с процессом, общие файловые дескрипторы, легковесный

**В `ps`:**
```bash
ps -eLf | grep supervisor
```
```
UID    PID   PPID    LWP  C NLWP STIME TTY      TIME CMD
user  12340      1  12340  0    4 10:15 pts/0  00:00:01 python3 supervisor.py
user  12340      1  12341  0    4 10:15 pts/0  00:00:00 python3 supervisor.py
```
- `NLWP` = 4 (количество потоков)
- `LWP` = Light Weight Process (ID потока)

**В `/proc`:**
```bash
ls /proc/12340/task/  # Потоки процесса
cat /proc/12340/status | grep Threads  # Количество потоков
```

### 2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

**Влияние на CFS:**
- `nice` изменяет `vruntime` (virtual runtime) процесса
- Процессы с меньшим `nice` (высшим приоритетом) получают больше CPU времени
- CFS стремится к "идеальной справедливости", но `nice` создает взвешенное распределение

**Пределы:**
- Обычный пользователь: `nice` от -20 до 19 (по умолчанию 0)
- Root пользователь: может устанавливать любые значения от -20 до 19
- Реальное время (RT): процессы с политикой `SCHED_FIFO`/`SCHED_RR` игнорируют `nice`

### 3. Что даёт CPU-аффинити и когда она вредна?

**Преимущества:**
- Уменьшение кэш-промахов (cache locality)
- Предсказуемость производительности
- Изоляция критичных процессов

**Когда вредна:**
- Неравномерная загрузка CPU (некоторые ядра простаивают)
- При миграции виртуальных машин
- Для load balancing системным планировщиком

**Пример из эксперимента:**
```bash
taskset -cp 12345
```
```
pid 12345's current affinity list: 0
```

### 4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`? Почему `RLIMIT_RSS` часто игнорируется?

**Различия:**
- **RLIMIT_AS**: ограничение всего виртуального адресного пространства
- **RLIMIT_DATA**: ограничение сегмента данных (heap)
- **RLIMIT_RSS**: ограничение резидентного набора (физической памяти)

**Почему RLIMIT_RSS игнорируется:**
- Сложность точного отслеживания RSS в реальном времени
- Проблемы с overcommit memory
- Неэффективность в современных системах с виртуальной памятью

### 5. Почему возможны зомби и как их избежать при массовых рестартах воркеров?

**Причина зомби:**
- Процесс завершился, но родитель не вызвал `wait()`
- PID заблокирован, ресурсы не освобождены

**Профилактика в реализации:**
```python
def sigchld_handler(self, signum, frame):
    try:
        while True:
            pid, status = os.waitpid(-1, os.WNOHANG)  # Неблокирующий wait
            if pid == 0: break
            # Обработка завершенного процесса
    except ChildProcessError:
        pass
```

### 6. Чем отличается «graceful shutdown» от «graceful reload/restart»?

**Graceful Shutdown:**
- Полное завершение всех процессов
- Ожидание завершения текущих операций
- Освобождение ресурсов

**Graceful Reload:**
- "Горячая" перезагрузка конфигурации
- Минимальный downtime
- Сохранение состояния

**Безопасные последовательности:**
1. **Shutdown**: SIGTERM → wait → SIGKILL (если таймаут)
2. **Reload**: SIGHUP → останов старых воркеров → запуск новых → проверка

### 7. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

**Влияние cgroup v2:**
- `/proc` метрики показывают ограничения контейнера, не хоста
- `memory.max`: ограничение памяти, OOM в пределах контейнера
- `cpu.max`: квота CPU, влияет на планирование
- Метрики в `/sys/fs/cgroup/` отражают лимиты

**Пример:**
```bash
cat /sys/fs/cgroup/user.slice/memory.max
cat /sys/fs/cgroup/user.slice/cpu.max
```

---

##  Выводы

### По работе с процессами
1. **Грамотное управление жизненным циклом** процессов критично для стабильности системы
2. **Обработка SIGCHLD и предотвращение зомби** требует аккуратной реализации неблокирующих вызовов
3. **Graceful shutdown/reload** значительно улучшает пользовательский опыт

### По планированию процессов
1. **Nice эффективно влияет** на распределение CPU при конкуренции ресурсов
2. **CPU affinity полезна** для cache-sensitive приложений, но может нарушать балансировку
3. **CFS обеспечивает справедливость**, но приоритеты позволяют тонкую настройку

### По мониторингу и метрикам
1. **/proc предоставляет богатую информацию** о планировании и использовании ресурсов
2. **pidstat и другие утилиты** незаменимы для анализа производительности
3. **Понимание метрик планирования** необходимо для оптимизации приложений

---

## Воспроизведение результатов


### Запуск демонстрации
```bash
# Установка прав
chmod +x demo_scheduling.sh run.sh

# Запуск полной демонстрации
./demo_scheduling.sh

# Или базовый тест
./run.sh
```

### Ручное тестирование
```bash
# Запуск супервизора
cd src
python3 supervisor.py ../config.json

# В другом терминале - управление сигналами
kill -USR1 <supervisor_pid>    # Легкий режим
kill -HUP <supervisor_pid>     # Reload
kill -TERM <supervisor_pid>    # Graceful shutdown

# Мониторинг
pidstat -u 1 10 -p <worker_pids>
cat /proc/<pid>/sched
```