# Лабораторная 2 — Продвинутые процессы Linux: сигналы, планирование, ресурсы, /proc

Курс: Проектирование приложений под Linux (DLA, 4 курс)

Эта лаба расширяет темы из курса ОС про процессы: добавляем управление процессами в реальном приложении (супервизор/воркеры), обработку сигналов, приоритеты и CPU‑аффинити, работу с ресурсами (память/IO), сбор метрик из `/proc` и практику диагностики (`pidstat`, `strace`, `perf`).

## Цели
- Уверенно работать с жизненным циклом процессов: запуск, рестарт, корректное завершение.
- Реализовать обработку сигналов и протокол «graceful shutdown / reload».
- Управлять планированием: nice/приоритеты, CPU‑аффинити.
- Снимать и интерпретировать метрики из `/proc` и системных утилит.
- Исследовать влияние ограничений ресурсов (rlimits, опционально cgroup v2).

## Подготовка среды
```bash
sudo apt update && sudo apt install -y \
  build-essential pkg-config git \
  procps psmisc util-linux sysstat \
  strace perf linux-tools-common linux-tools-generic
# Опционально: bpfcc-tools (если есть поддержка BPF в ядре)
```

## Где работать и как сдавать
Работайте в своей папке по схеме (аналогично lab1):
```

### Связь с курсом ОС (BSU-OS-2025)
- Эту работу логично делать после ознакомления с `BSU-OS-2025/lab2` (процессы и `/proc`). Здесь требования глубже: сигналы, супервизор, планирование, метрики.
- Для справок по базовым командам и `/proc` можете ориентироваться на материалы `BSU-OS-2025/lab2/README.md`.
lab2/
  gr<группа>sub<подгруппа>/
    ФАМИЛИЯ_ИМЯ/
      REPORT.MD   # обязательный отчёт: цель → шаги → выводы → ответы → проверка
      README.md   # как запустить и воспроизвести
      src/        # исходники C/C++/Python/Bash, Makefile
      run.sh      # (по желанию) сценарий запуска/демо
```
Ветка/PR — как в корневом `README.md`: личная ветка от `main`, работать только в своей папке, открыть PR в `main`.

## Обзор заданий

### A) Мини‑супервизор с воркерами (обязательно)
Реализуйте процесс‑родителя (супервизор), который:
- Порождает N воркеров (N ≥ 2), отслеживает их состояние через `SIGCHLD`, корректно «подбирает» зомби.
- Поддерживает сигналы:
  - `SIGTERM`/`SIGINT`: корректное завершение — послать воркерам «стоп» и дождаться их выхода (graceful shutdown ≤ 5 секунд).
  - `SIGHUP`: «graceful reload» — перечитать конфиг и «мягко» перезапустить воркеров без потери работы (допускается короткая пауза).
  - `SIGUSR1`: широковещательно переключить воркеров в «лёгкий» режим нагрузки, `SIGUSR2` — обратно в «тяжёлый».
- При аварийном выходе воркера — перезапускает его (ограничить частоту рестартов, например не более 5 за 30 секунд).

Требования к воркерам:
- Воркеры выполняют имитацию работы: период «вычислений» + период ожидания, параметры берутся из конфига.
- Воркеры обрабатывают `SIGTERM` (корректное завершение) и `SIGUSR1/2` (переключение профиля нагрузки).
- Выводят диагностические строки: PID, режим работы, тик‑статистику, на какой(их) CPU исполняются.

Формат конфига (минимум):
```
workers: 3
mode_heavy: { work_us: 9000, sleep_us: 1000 }
mode_light: { work_us: 2000, sleep_us: 8000 }
```
Формат свободный (ini/yaml/json/простой `KEY=VALUE`), но документируйте его в своём `README.md`.

Демонстрация: `run.sh`/команды для запуска супервизора, отправки сигналов, показа перезапусков и корректного завершения.

### B) Планирование: nice и CPU‑аффинити (обязательно)
Добавьте управление планированием для воркеров:
- Установите разный `nice` для поднабора воркеров (например, половине `+10`, остальным `0`). Сравните распределение CPU.
- Установите CPU‑аффинити (через `sched_setaffinity` или `taskset`) для разных воркеров: например, часть закрепить на 0‑м ядре, часть — на 1‑м.
- Снимите метрики `pidstat -u 1 10` и покажите, как `nice` и аффинити влияют на `%CPU`/время ожидания.

Результат: фрагменты вывода с комментариями и короткие выводы (почему так, где ограничения, как ядро распределяет квоты).

### C) /proc и собственная утилита pstat (обязательно)
Напишите утилиту `pstat <pid>`, которая:
- Читает `/proc/<pid>/stat`, `/proc/<pid>/status`, `/proc/<pid>/io`, `/proc/<pid>/smaps_rollup` (если есть).
- Выводит краткую сводку: `PPid`, `Threads`, `State`, `utime/stime`, `voluntary_ctxt_switches`, `nonvoluntary_ctxt_switches`, `VmRSS`, `RssAnon`, `RssFile`, `read_bytes`, `write_bytes`.
- Умеет форматировать числа (МиБ/КиБ) и считает `RSS MiB` и «CPU time sec = (utime+stime)/HZ`.

Сравните показания с `ps`, `pidstat`, `top` в отчёте.

### D) Память и OOM (обязательно)
Исследуйте поведение приложений под давлением памяти:
- С помощью утилиты из `samples/mem_touch.c` или собственного кода постепенно увеличивайте RSS.
- Снимайте `pidstat -r 1 10` и `cat /proc/<pid>/status | head -20` на разных этапах.
- Ограничьте адресное пространство через `ulimit -v` и/или `setrlimit(RLIMIT_AS)` и покажите разницу с `RLIMIT_DATA/RLIMIT_RSS` (где поддерживается).
- Опционально: создайте cgroup v2 с `memory.max` (если доступно) и поместите процесс внутрь; зафиксируйте событие OOM и как оно отражается в `dmesg`/`/proc/<pid>/status`.

### E*) Диагностика и профилирование (со звёздочкой)
- `strace -f -c -p <pid>`: топ системных вызовов воркера в тяжёлом/лёгком режимах.
- `perf stat -p <pid> sleep 5`: базовые аппаратные счётчики (cycles, instructions, branches).
- (Опционально) `perf top`/flamegraph на локальной машине для демонстрации «горячих мест» в тяжёлом режиме.

### F*) Безостановочный reload (со звёздочкой)
Реализуйте протокол «graceful restart»: при `SIGHUP` супервизор сначала запускает новую волну воркеров с новым конфигом, затем корректно останавливает старую волну (нулевой простой).

## Что конкретно нужно сделать
- Код (в `src/`):
  - Супервизор+воркеры: порождение N≥2, обработка `SIGTERM`/`SIGINT` (graceful shutdown ≤ 5с), `SIGHUP` (graceful reload), `SIGUSR1/2` (переключение режима). Обработка `SIGCHLD` и «подбор» зомби, ограничение частоты рестартов.
  - Утилита `pstat <pid>`: сводка по `/proc` (см. раздел C).
  - `Makefile` или чёткие команды сборки в `README.md` у студента; при желании `run.sh`.
- Эксперименты (в `REPORT.MD` с командами и выводами):
  - CPU: запустить 2 процесса нагрузки; снять «до/после» `renice` (на Linux желательно добавить пиннинг обоих на одно ядро `taskset -c 0` для наглядности). Кратко пояснить, почему изменилась доля CPU.
  - Память: запустить `mem_touch` (или свой аналог) с ростом RSS ступенями; показать per‑process `RSS/VSZ` и системные метрики. На macOS прокомментировать «Unused мало, смотрим Available/компрессию»; на Linux — `free -h`/`vmstat`. Показать реакцию на `SIGUSR1/2` (+/− шаг памяти). По возможности продемонстрировать лимит памяти (`ulimit -v`/`setrlimit` или cgroup v2) либо объяснить ограничения окружения.
  - Сигналы: показать управление режимами воркеров (`SIGUSR1/2`), мягкое завершение (`SIGTERM/INT`), reload (`SIGHUP`).
- Отчёт: цель → шаги/команды → фрагменты выводов → ответы на вопросы → выводы → как воспроизводить и на какой ОС.

## Артефакты и структура сдачи
- Исходники супервизора и воркеров (`src/`), `Makefile` или инструкции сборки.
- Утилита `pstat`.
- Скрипты/команды воспроизведения экспериментов (nice/affinity/memory/OOM/strace/perf).
- `REPORT.MD` с:
  - краткой теорией/обоснованием шагов,
  - командами и фрагментами вывода,
  - ответами на вопросы (ниже),
  - выводами (что влияет на что и почему),
  - описанием ограничений окружения (WSL2/виртуалка/без root).

## Вопросы для отчёта
1. Чем процесс отличается от потока в Linux? Где это видно в `/proc` и `ps`?
2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?
3. Что даёт CPU‑аффинити и когда она вредна?
4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`? Почему `RLIMIT_RSS` часто игнорируется?
5. Как понять из `/proc/<pid>/io`, что процесс «шумит» по IO? Чем это отличается от «ожидания IO» в `top`/`pidstat`?
6. Что означают поля `utime/stime` и как перевести их в секунды?
7. Почему возможны зомби и как их избежать при массовых рестартах воркеров?
8. Чем отличается «graceful shutdown» от «graceful restart»? Какие сигналы и последовательности безопасны?
9. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

## Критерии зачёта
- Супервизор порождает и управляет N воркерами, корректно обрабатывает `SIGTERM`/`SIGINT`/`SIGHUP`/`SIGUSR1/2`, подбирает зомби.
- Демонстрация влияния `nice` и CPU‑аффинити на распределение CPU (выводы и данные).
- Утилита `pstat` выводит требуемые поля из `/proc`, числа корректны и прокомментированы.
- Исследование памяти: показаны изменения RSS, работа `ulimit`/`setrlimit`, описано поведение при нехватке памяти; (опционально) кейс с cgroup v2.
- `REPORT.MD` структурирован: цель → шаги → данные → ответы → выводы → воспроизводимость.
- Со звёздочкой: хотя бы один пункт из E/F реализован и продемонстрирован.

Примечания для кроссплатформенности:
- macOS: CPU‑аффинити нет — оцениваем `renice` и поведение нагрузки; память смотрим через `vm_stat`/`memory_pressure` (ожидаемо «Unused» низкий, важнее «Available»/компрессия). Лимиты через `ulimit -v` могут работать не так, как в Linux — опишите ограничения.
- Linux: приветствуется пиннинг обоих процессов на одно ядро для наглядности эффекта `nice`; лимиты памяти (`ulimit`/cgroup v2) — по возможности продемонстрировать.

## Приложение: samples
В каталоге `samples/` есть вспомогательные утилиты для генерации нагрузок:
- `cpu_burn.c` — «сжигатель CPU» с сигналами переключения профилей и CPU‑аффинити.
- `mem_touch.c` — постепенное наращивание RSS с возможностью «добавить/убрать» память по сигналам.

Сборка (пример):
```bash
cd lab2/samples
make
./cpu_burn --work-us 9000 --sleep-us 1000 --duration 10
./mem_touch --rss-mb 512 --step-mb 64 --sleep-ms 200
```

Вы можете использовать их в отчёте для демонстраций, но супервизор/утилита `pstat` — ваша собственная реализация.

## Диагностика и советы
- Для корректного вывода при сигналax используйте неблокирующие обработчики и атомарные флаги, а печать делайте в основном цикле.
- Следите за «дребезгом» рестартов: вводите backoff/ограничение частоты.
- На WSL2 часть файлов `/proc` и `perf` может быть недоступна — задокументируйте ограничения и покажите альтернативы.


## Быстрое демо (macOS и Linux)
В репозитории есть скрипт, демонстрирующий CPU/планирование (`nice`) и память (`RSS/Available`). Он автоматически собирает примеры и запускает последовательность измерений с корректными командами для вашей ОС.

```bash
bash lab2/tools/demo.sh
```

Скрипт показывает:
- Два процесса `cpu_burn` с переключением режимов и изменением `nice`; снимки метрик до/после на macOS (`top -l 1 -pid ...`) или Linux (`pidstat`, `top -b`).
- Процесс `mem_touch`, рост `RSS`, системные метрики памяти: на macOS (`PhysMem`, `vm_stat`, оценка Available, compressor), на Linux (`free -h`, `vmstat`, `/proc/meminfo`).

Подсказки:
- Эффект `renice` виден при конкуренции на CPU (когда оба процесса активны). На Linux дополнительно усиливается при пиннинге обоих процессов на одно ядро (`taskset -c 0`).
- На macOS «Unused» почти всегда мал; ориентируйтесь на «Available ≈ free+inactive+speculative» и `memory_pressure`.

### Запуск с параметрами
```bash
# Только CPU-демо на 5 секунд
bash lab2/tools/demo.sh --cpu-only --cpu-duration 5

# Только память: цель 1 ГБ, шаг 128 МБ, пауза 100 мс
bash lab2/tools/demo.sh --mem-only --rss-mb 1024 --step-mb 128 --sleep-ms 100

# Linux: подчеркнуть конкуренцию, закрепив оба процесса на CPU 0
bash lab2/tools/demo.sh --cpu-only --pin
```
Доступные флаги:
- `--cpu-only`, `--mem-only`
- `--cpu-duration SEC`
- `--heavy-work-us N`, `--heavy-sleep-us N`, `--light-work-us N`, `--light-sleep-us N`
- `--rss-mb N`, `--step-mb N`, `--sleep-ms N`
- `--pin` (Linux, при наличии `taskset`)



