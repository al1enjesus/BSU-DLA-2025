# Отчёт по лабораторной работе №2
**Продвинутые процессы Linux: сигналы, планирование, ресурсы, /proc**

## Цели работы
- Освоить управление жизненным циклом процессов (запуск, рестарт, graceful shutdown)
- Реализовать обработку сигналов и протокол graceful reload
- Исследовать влияние приоритетов (nice) и CPU-аффинити на планирование процессов
- Научиться собирать и анализировать метрики из `/proc` и системных утилит

## Выполненные задания

### Задание A: Мини-супервизор с воркерами

#### Реализованная функциональность
- Супервизор порождает N воркеров (в тестах - 3 и 6 процессов)
- Обработка сигналов:
  - `SIGTERM`/`SIGINT` - graceful shutdown
  - `SIGHUP` - перезагрузка конфигурации
  - `SIGUSR1`/`SIGUSR2` - переключение между легким и тяжелым режимами работы
- Автоматический рестарт упавших воркеров с ограничением частоты
- Корректная очистка ресурсов и отсутствие зомби-процессов

#### Демонстрация работы

**Запуск системы с 3 воркерами:**
```bash
./supervisor
```
```
[S] spawned pid=11518
[S] spawned pid=11519
[S] spawned pid=11520
[S] entering main loop pid=11517
[W 11518] tick=0 mode=HEAVY cpu=15 heavy(work/sleep)=7000/3000 light(work/sleep)=3000/7000
[W 11519] tick=0 mode=HEAVY cpu=0 heavy(work/sleep)=7000/3000 light(work/sleep)=3000/7000
[W 11520] tick=0 mode=HEAVY cpu=2 heavy(work/sleep)=7000/3000 light(work/sleep)=3000/7000
```

**Начальное состояние в top (тяжелый режим):**
```bash
top -p 11518,11519,11520
```
```
11520 russlan+  20   0    6060   3200   3072 R  69.7   0.0   0:09.63 worker
11518 russlan+  20   0    6060   3200   3072 R  69.3   0.0   0:09.63 worker
11519 russlan+  20   0    6060   3200   3072 R  69.3   0.0   0:09.63 worker
```

**Переключение в легкий режим (SIGUSR1):**
```bash
kill -USR1 11517
```
```
[S] switching workers to LIGHT mode
```

**Результат в top после переключения:**
```
11518 russlan+  20   0    6060   3200   3072 R  29.9   0.0   1:39.89 worker
11519 russlan+  20   0    6060   3200   3072 S  29.9   0.0   1:39.89 worker
11520 russlan+  20   0    6060   3200   3072 R  29.9   0.0   1:39.89 worker
```

**Возврат в тяжелый режим (SIGUSR2):**
```bash
kill -USR2 11517
```
```
[S] switching workers to HEAVY mode
```

**Результат в top после возврата:**
```
11518 russlan+  20   0    6060   3200   3072 S  69.4   0.0   2:11.76 worker
11520 russlan+  20   0    6060   3200   3072 R  69.4   0.0   2:11.76 worker
11519 russlan+  20   0    6060   3200   3072 R  69.1   0.0   2:11.74 worker
```

**Изменение конфигурации (SIGHUP):**
```bash
kill -HUP 11517
```
```
[S] reloading configuration
[W 11519] tick=29040 mode=HEAVY cpu=13 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 11520] tick=29040 mode=HEAVY cpu=3 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 11518] tick=29041 mode=HEAVY cpu=15 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
```

**Результат в top после обновления конфига:**
```
11518 russlan+  20   0    6060   3200   3072 R  89.0   0.0   5:25.48 worker
11519 russlan+  20   0    6060   3200   3072 R  89.0   0.0   5:25.47 worker
11520 russlan+  20   0    6060   3200   3072 R  88.7   0.0   5:25.48 worker
```

**Легкий режим с новым конфигом:**
```bash
kill -USR1 11517
```
```
[S] switching workers to LIGHT mode
```

**Результат в top:**
```
11518 russlan+  20   0    6060   3200   3072 S  20.3   0.0   6:01.86 worker
11520 russlan+  20   0    6060   3200   3072 S  20.3   0.0   6:01.86 worker
11519 russlan+  20   0    6060   3200   3072 S  20.0   0.0   6:01.84 worker
```

**Завершение работы (SIGTERM):**
```bash
kill -TERM 11517
```
```
[S] shutting down workers...
[W 11518] shutting down
[W 11519] shutting down
[W 11520] shutting down
[S] cleanup done
```

### Задание B: Планирование - nice и CPU-аффинити

#### Эксперимент с 6 воркерами

**Запуск системы с 6 воркерами:**
```bash
./supervisor
```
```
[S] spawned pid=14499
[S] spawned pid=14500
[S] spawned pid=14501
[S] spawned pid=14502
[S] spawned pid=14503
[S] spawned pid=14504
[S] entering main loop pid=14498
[W 14500] tick=0 mode=HEAVY cpu=5 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 14501] tick=0 mode=HEAVY cpu=2 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 14502] tick=0 mode=HEAVY cpu=0 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 14504] tick=0 mode=HEAVY cpu=10 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 14499] tick=0 mode=HEAVY cpu=14 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
[W 14503] tick=0 mode=HEAVY cpu=7 heavy(work/sleep)=9000/1000 light(work/sleep)=2000/8000
```

**Исходное состояние в top:**
```bash
top -p 14499,14500,14501,14502,14503,14504
```
```
14500 russlan+  20   0    6060   3200   3072 R  89.4   0.0   0:54.17 worker
14501 russlan+  20   0    6060   3200   3072 R  89.4   0.0   0:54.18 worker
14502 russlan+  20   0    6060   3200   3072 R  89.4   0.0   0:54.18 worker
14504 russlan+  20   0    6060   3200   3072 R  89.4   0.0   0:54.17 worker
14499 russlan+  20   0    6060   3200   3072 R  89.0   0.0   0:54.16 worker
14503 russlan+  20   0    6060   3200   3072 R  89.0   0.0   0:54.17 worker
```

#### Эксперимент с приоритетами (nice)

**Установка разных nice значений:**
```bash
# Для процессов с высоким приоритетом (nice=0)
sudo renice -n 0 14499 14500 14501

# Для процессов с низким приоритетом (nice=10)
sudo renice -n 10 14502 14503 14504
```

**Результат в top после изменения nice:**
```
14500 russlan+  20   0    6060   3200   3072 R  89.4   0.0   6:00.13 worker  # nice=0
14503 russlan+  30  10    6060   3200   3072 R  89.4   0.0   6:00.11 worker  # nice=10
14501 russlan+  20   0    6060   3200   3072 R  89.0   0.0   6:00.10 worker  # nice=0
14504 russlan+  30  10    6060   3200   3072 R  89.0   0.0   6:00.11 worker  # nice=10
14499 russlan+  20   0    6060   3200   3072 R  69.8   0.0   5:43.06 worker  # nice=0
14502 russlan+  30  10    6060   3200   3072 R  24.9   0.0   5:03.95 worker  # nice=10
```

#### Эксперимент с CPU-аффинити

**Установка CPU-аффинити:**
```bash
# Первая группа на CPU 0
taskset -cp 0 14499
taskset -cp 0 14502  
taskset -cp 0 14500

# Вторая группа на CPU 1
taskset -cp 1 14501
taskset -cp 1 14503
taskset -cp 1 14504
```

**Результат в top после установки аффинити:**
```
14501 russlan+  20   0    6060   3200   3072 R  56.7   0.0  11:01.33 worker  # CPU 1, nice=0
14500 russlan+  20   0    6060   3200   3072 R  47.0   0.0   9:44.49 worker  # CPU 0, nice=0
14499 russlan+  20   0    6060   3200   3072 R  46.7   0.0   9:05.88 worker  # CPU 0, nice=0
14503 russlan+  30  10    6060   3200   3072 R  21.7   0.0  10:18.64 worker  # CPU 1, nice=10
14504 russlan+  30  10    6060   3200   3072 R  18.7   0.0  10:21.46 worker  # CPU 1, nice=10
14502 russlan+  30  10    6060   3200   3072 R   6.3   0.0   5:48.32 worker  # CPU 0, nice=10
```

## Ответы на вопросы

### 1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

**Различия:**
- Процессы имеют независимые адресные пространства, потоки разделяют память
- Каждый процесс имеет уникальный PID, потоки одного процесса имеют одинаковый PID но разные TID
- Создание процесса через `fork()`, создание потока через `pthread_create()`

**В `ps`:**
```bash
ps -eLf | head -10
```
Потоки показываются с одинаковым PID но разными LWP (Light Weight Process)

**В `/proc`:**
```bash
ls /proc/11518/task/
```
Каждый процесс имеет директорию `task/` с поддиректориями для каждого потока

### 2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

**Влияние nice:**
- Значение nice от -20 (высший приоритет) до +19 (низший приоритет)
- CFS использует nice для расчета "виртуального времени" выполнения
- Процессы с низким nice получают больше CPU времени

**Пределы:**
- Обычный пользователь: может повышать nice только до 0 (не может понижать)
- Root: может устанавливать любые значения от -20 до +19
- В реальном времени (RT) класса nice не влияет на планирование

### 3. Что даёт CPU-аффинити и когда она вредна?

**Преимущества:**
- Уменьшает переключения между ядрами (cache locality)
- Улучшает предсказуемость производительности
- Полезно для real-time приложений

**Когда вредна:**
- При неравномерной нагрузке на ядра
- Может привести к недогрузке некоторых CPU
- Усложняет балансировку нагрузки

### 4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`?

- **RLIMIT_AS**: ограничивает общий размер виртуальной памяти процесса
- **RLIMIT_DATA**: ограничивает размер сегмента данных (heap)
- **RLIMIT_RSS**: ограничивает размер резидентной памяти в RAM

**RLIMIT_RSS часто игнорируется** потому что современные системы используют сложные алгоритмы управления памятью и подкачку, что делает точный контроль RSS затруднительным.

### 5. Почему возможны зомби и как их избежать при массовых рестартах воркеров?

**Причины зомби:**
- Процесс завершился, но родитель не вызвал `wait()`
- Запись о процессе остается в таблице процессов

**Как избежать:**
- Обрабатывать SIGCHLD в супервизоре
- Использовать `waitpid()` с флагом `WNOHANG` в цикле
- Ограничивать частоту рестартов (backoff алгоритм)
- В реализации использовано ограничение: не более 5 рестартов за 30 секунд

### 6. Чем отличается «graceful shutdown» от «graceful reload/restart»?

**Graceful shutdown:**
- Посылается SIGTERM всем процессам
- Процессы завершают текущую работу
- Ожидание завершения (timeout)
- Корректное освобождение ресурсов

**Graceful reload:**
- Перечитывается конфигурация
- Посылается SIGHUP для применения изменений
- Процессы продолжают работу с новыми параметрами
- Минимальный простой

### 7. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

**Влияние cgroup v2:**
- Ограничения CPU будут видны в `%CPU` (не сможет превысить лимит)
- Ограничения памяти могут вызвать OOM killer при превышении
- Метрики в `/proc` будут показывать ограниченные значения
- `pidstat` будет отражать ограниченное использование ресурсов

## Выводы

1. **Сигналы эффективны** для управления процессами: graceful shutdown и reload работают корректно
2. **Nice влияет на распределение CPU**: процессы с низким nice получают приоритет, но эффект виден только при конкуренции за ресурсы
3. **CPU-аффинити полезна** для контроля распределения нагрузки по ядрам, но требует тщательного планирования
4. **Ограничение рестартов** предотвращает бесконечные циклы перезапуска
5. **Разделяемая память** эффективна для распространения конфигурации между процессами

## Воспроизводимость

**ОС:** Linux (Ubuntu 22.04)
**Компиляция:**
```bash
g++ -std=c++17 -pthread supervisor.cpp -o supervisor
g++ -std=c++17 -pthread worker.cpp -o worker
```

**Запуск:**
```bash
./supervisor
```

**Сигналы управления:**
```bash
# Переключение в легкий режим
kill -USR1 <supervisor_pid>

# Переключение в тяжелый режим  
kill -USR2 <supervisor_pid>

# Обновление конфигурации
kill -HUP <supervisor_pid>

# Завершение работы
kill -TERM <supervisor_pid>
```