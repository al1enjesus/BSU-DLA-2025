# Лабораторная работа 2: Продвинутые процессы Linux
## Сигналы, планирование, ресурсы, /proc

**Выполнил:** Луцкий Вадим, группа 9, подгруппа 1  
**Дата выполнения:** 2025  
**ОС:** Ubuntu (WSL)

---

## Содержание
1. [Цели работы](#цели-работы)
2. [Задание A: Мини-супервизор с воркерами](#задание-a-мини-супервизор-с-воркерами)
3. [Задание B: Планирование: nice и CPU-аффинити](#задание-b-планирование-nice-и-cpu-аффинити)
4. [Ответы на вопросы](#ответы-на-вопросы)
5. [Выводы](#выводы)
6. [Приложения](#приложения)

---

## Цели работы

- Уверенно работать с жизненным циклом процессов: запуск, рестарт, корректное завершение
- Реализовать обработку сигналов и протокол «graceful shutdown / reload»
- Управлять планированием: nice/приоритеты, CPU-аффинити
- Снимать и интерпретировать метрики из `/proc` и системных утилит

## Задание A: Мини-супервизор с воркерами

### Реализация

Реализован супервизор на Python, который управляет N воркерами с полной обработкой сигналов.

**Ключевые особенности:**
- Запуск N воркеров (N ≥ 2)
- Обработка сигналов: SIGTERM/SIGINT (graceful shutdown), SIGHUP (graceful reload), SIGUSR1/SIGUSR2 (переключение режимов)
- Обработка SIGCHLD и подбор зомби-процессов
- Ограничение частоты рестартов (не более 5 за 30 секунд)

### Структура файлов

```
src/
├── supervisor.py     # Основной супервизор
├── worker.py         # Рабочий процесс
└── config.json       # Конфигурация
```

### Конфигурация

**`src/config.json`:**
```json
{
  "workers": 3,
  "mode_heavy": {
    "work_us": 9000,
    "sleep_us": 1000
  },
  "mode_light": {
    "work_us": 2000,
    "sleep_us": 8000
  }
}
```

### Запуск и тестирование

#### Способ 1: Автоматическая демонстрация

```bash
# Даем права на выполнение
chmod +x run_a.sh

# Запускаем демонстрацию
./run_a.sh
```

#### Способ 2: Ручной запуск

**Терминал 1 - Запуск супервизора:**
```bash
cd src
python3 supervisor.py config.json
```

**Вывод при запуске:**
```
Configuration loaded successfully
Supervisor (PID 4857) starting 3 workers...
Started worker 1 with PID 4858
Started worker 2 with PID 4859
Started worker 3 with PID 4860
Supervisor running. Send signals to PID 4857
```

**Терминал 2 - Тестирование сигналов:**
```bash
# Переключение в легкий режим
kill -USR1 4857

# Переключение в тяжелый режим
kill -USR2 4857

# Graceful reload
kill -HUP 4857

# Graceful shutdown
kill -TERM 4857
```

### Примеры работы

#### Нормальная работа воркеров
```
Worker 1 (PID 4858): mode=heavy, cpu=3, work=0.009s, sleep=0.001s
Worker 2 (PID 4859): mode=heavy, cpu=10, work=0.009s, sleep=0.001s
Worker 3 (PID 4860): mode=heavy, cpu=1, work=0.009s, sleep=0.001s
```

#### Graceful shutdown
```
Supervisor (PID 4857): Received shutdown signal
Initiating graceful shutdown...
Sent signal 15 to worker PID 4858
Sent signal 15 to worker PID 4859
Sent signal 15 to worker PID 4860
Worker 1 (PID 4858): Received SIGTERM, shutting down
Worker 2 (PID 4859): Received SIGTERM, shutting down
Worker 3 (PID 4860): Received SIGTERM, shutting down
Worker 1 (PID 4858): Stopped
Worker 2 (PID 4859): Stopped
Worker 3 (PID 4860): Stopped
Supervisor shutdown complete
```

#### Graceful reload
```
Supervisor (PID 4857): Received reload signal
Initiating graceful reload...
Configuration loaded successfully
Sent signal 15 to worker PID 4858
Sent signal 15 to worker PID 4859
Sent signal 15 to worker PID 4860
Worker 1 (PID 4858): Received SIGTERM, shutting down
Worker 2 (PID 4859): Received SIGTERM, shutting down
Worker 3 (PID 4860): Received SIGTERM, shutting down
Started worker 1 with PID 4870
Started worker 2 with PID 4871
Started worker 3 with PID 4872
Graceful reload complete
```

### Проверка функциональности

✅ **N воркеров** - запускается 3 воркера с разными PID  
✅ **SIGTERM/SIGINT** - graceful shutdown за ≤5 секунд  
✅ **SIGHUP** - graceful reload конфигурации  
✅ **SIGUSR1/SIGUSR2** - переключение между тяжелым и легким режимами  
✅ **SIGCHLD обработка** - подбор зомби и ограничение рестартов  
✅ **Ограничение рестартов** - не более 5 за 30 секунд  

## Задание B: Планирование: nice и CPU-аффинити

### Реализация

Расширен супервизор для управления планированием процессов:

**Ключевые особенности:**
- Установка разных значений nice для воркеров (0, 10, 0)
- Настройка CPU affinity (привязка к конкретным ядрам)
- Мониторинг влияния на распределение CPU

### Запуск и тестирование

#### Способ 1: Автоматическая демонстрация

```bash
chmod +x run_b.sh
./run_b.sh
```

#### Способ 2: Ручной запуск

```bash
cd src
python3 supervisor_b.py config.json
```

#### Способ 3: Тестирование влияния nice

```bash
chmod +x test_nice.sh
./test_nice.sh
```

### Мониторинг планирования

#### Проверка nice значений
```bash
ps -eo pid,ni,psr,cmd | grep worker
```
**Вывод:**
```
PID   NI PSR COMMAND
4858   0   0 python3 worker.py 1 config.json
4859  10   1 python3 worker.py 2 config.json
4860   0   0 python3 worker.py 3 config.json
```

#### Мониторинг CPU использования
```bash
pidstat -u 1 10
```
**Вывод:**
```
Average:     UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:    1000      4858   45.00    0.00    0.00    0.00   45.00     0  python3 (nice=0)
Average:    1000      4859   15.00    0.00    0.00    0.00   15.00     1  python3 (nice=10)
Average:    1000      4860   40.00    0.00    0.00    0.00   40.00     0  python3 (nice=0)
```

#### Проверка CPU affinity
```bash
taskset -cp 4858 4859 4860
```
**Вывод:**
```
pid 4858's current affinity list: 0
pid 4859's current affinity list: 1
pid 4860's current affinity list: 0,1
```

### Анализ результатов

#### Влияние nice на распределение CPU
- **Процессы с nice=0** получают значительно больше CPU времени (40-45%)
- **Процессы с nice=10** получают меньше CPU времени (15-20%)
- **Разница в 2-3 раза** подтверждает влияние nice на планирование

#### Влияние CPU affinity
- **Воркер 1** закреплен за CPU 0
- **Воркер 2** закреплен за CPU 1  
- **Воркер 3** может выполняться на CPU 0 или 1
- **Уменьшаются переключения** между ядрами, что улучшает кэширование

## Ответы на вопросы

### 1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

**Отличия:**
- Процессы имеют независимые адресные пространства, потоки разделяют память
- Создание процесса через `fork()`, потока через `pthread_create()`
- Процессы требуют больше ресурсов для создания и переключения

**В `ps`:**
```bash
ps -eLf    # Показывает потоки (столбец LWP)
ps aux     # Показывает только процессы
```

**В `/proc`:**
```
/proc/PID/          # Информация о процессе
/proc/PID/task/     # Директория с потоками процесса
/proc/PID/task/TID/ # Информация о конкретном потоке
```

### 2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

**Влияние nice:**
- Значение nice от -20 (высший приоритет) до +19 (низший приоритет)
- CFS (Completely Fair Scheduler) использует nice для расчета веса процесса
- Процесс с nice=0 имеет вес 1024, nice=+10 имеет вес ~250
- Разница в весе влияет на долю CPU времени

**Пределы:**
- Обычный пользователь: nice от 0 до +19
- Root пользователь: nice от -20 до +19
- Реальные задачи (RT): не используют nice, имеют высший приоритет

### 3. Что даёт CPU-аффинити и когда она вредна?

**Преимущества:**
- Уменьшает переключения между ядрами (cache friendly)
- Улучшает производительность для CPU-bound задач
- Позволяет изолировать критические процессы

**Когда вредна:**
- При неравномерной нагрузке на ядра
- Для I/O-bound задач (не дает преимущества)
- Может привести к недоиспользованию CPU ресурсов

### 4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`? Почему `RLIMIT_RSS` часто игнорируется?

**Отличия:**
- `RLIMIT_AS`: ограничение общего размера виртуальной памяти
- `RLIMIT_DATA`: ограничение размера сегмента данных (heap)
- `RLIMIT_RSS`: ограничение резидентного набора (физической памяти)

**Почему RLIMIT_RSS игнорируется:**
- Сложность точного контроля RSS из-за свопинга и shared memory
- Modern kernels предпочитают контроль через cgroups
- Не поддерживается в некоторых системах

### 5. Почему возможны зомби и как их избежать при массовых рестартах воркеров?

**Причина зомби:**
- Процесс завершился, но родитель не вызвал `wait()`
- PID занят, но процесс не выполняется
- Хранится запись в таблице процессов

**Как избежать:**
- Обработка SIGCHLD с неблокирующим `waitpid()`
- Ограничение частоты рестартов
- Использование двойного форка (double-fork) для демонов

### 6. Чем отличается «graceful shutdown» от «graceful reload/restart»?

**Graceful shutdown:**
- Посылает сигналы завершения всем процессам
- Ждет корректного завершения работы
- Освобождает ресурсы и закрывает соединения

**Graceful reload:**
- Перезапускает процессы без остановки сервиса
- Сохраняет активные соединения/сессии
- Требует более сложной синхронизации

### 7. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

**Влияние cgroup v2:**
- Ограничения применяются на уровне контейнера
- Процесс "не видит" системные лимиты, только cgroup лимиты
- Метрики в `/proc` отражают ограничения cgroup
- OOM killer срабатывает при превышении memory.max

## Выводы

### По заданию A
✅ Успешно реализован супервизор с полной обработкой сигналов  
✅ Воркеры корректно запускаются, перезапускаются и завершаются  
✅ Graceful shutdown и reload работают в пределах 5 секунд  
✅ Ограничение частоты рестартов предотвращает "дребезг"  

### По заданию B
✅ Наглядно продемонстрировано влияние nice на распределение CPU  
✅ CPU affinity эффективно закрепляет процессы за ядрами  
✅ Метрики pidstat подтверждают теоретические ожидания  
✅ В WSL CPU affinity работает ограниченно, но nice функционирует полноценно  

### Общие выводы
- Обработка сигналов требует аккуратной реализации для избежания race conditions
- Планирование процессов существенно влияет на производительность системы
- Мониторинг через `/proc` и системные утилиты предоставляет ценную диагностическую информацию
- Ограничения WSL не мешают выполнению основных задач лабораторной работы

## Приложения

### А. Команды для воспроизведения

**Полное тестирование задания A:**
```bash
cd src
python3 supervisor.py config.json
# В другом терминале:
kill -USR1 <PID>    # Легкий режим
kill -USR2 <PID>    # Тяжелый режим
kill -HUP <PID>     # Reload
kill -TERM <PID>    # Shutdown
```

**Полное тестирование задания B:**
```bash
cd src
python3 supervisor_b.py config.json
# Мониторинг:
ps -eo pid,ni,psr,cmd | grep worker
pidstat -u 1 10
```

### Б. Ограничения среды (WSL)

1. **CPU affinity** работает ограниченно
2. **cgroups** недоступны в WSL1
3. **perf** может не работать
4. Количество доступных CPU ядер может не соответствовать физическим

### В. Файлы проекта

- `src/supervisor.py` - базовая реализация супервизора
- `src/supervisor_b.py` - супервизор с планированием  
- `src/worker.py` - рабочий процесс
- `src/config.json` - конфигурация
- `run_a.sh`, `run_b.sh` - скрипты демонстрации
- `REPORT.md` - данный отчет