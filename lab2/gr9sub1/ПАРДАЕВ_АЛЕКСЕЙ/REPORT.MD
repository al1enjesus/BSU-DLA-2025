# Лабораторная 2 — Продвинутые процессы Linux: сигналы, планирование, ресурсы, /proc

Курс: **Проектирование приложений под Linux (DLA, 4 курс)**

---

## Цели
- Освоить управление жизненным циклом процессов: запуск, рестарт, корректное завершение.
- Реализовать обработку сигналов и протокол «graceful shutdown / reload».
- Управлять планированием: `nice`-приоритеты, CPU-аффинити.
- Снимать и интерпретировать метрики из `/proc` и системных утилит.
- Исследовать влияние ограничений ресурсов (`rlimits`, опционально cgroup v2).

---
### Ход работы
#### A) Мини-супервизор с воркерами

Исходный код расположен в src/supervisor.py и src/worker.py.
Основные функции:
Супервизор порождает N=4 воркеров, обрабатывает сигналы:
SIGTERM/SIGINT — корректное завершение.
SIGHUP — перезагрузка конфигурации и перезапуск воркеров.
SIGUSR1/SIGUSR2 — переключение режима нагрузки у всех воркеров.
Воркеры имитируют работу в режимах heavy и light, печатают PID, режим и текущий CPU.

*Запуск и демонстрация*
```bash
python3 supervisor.py
kill -USR1 <pid_supervisor>  # переключить в light
kill -USR2 <pid_supervisor>  # обратно в heavy
kill -HUP  <pid_supervisor>  # перезагрузка воркеров
kill -TERM <pid_supervisor>  # корректное завершение
```
*Фрагмент лога*
[supervisor] Spawned worker id=0 pid=60321 nice=0 cpu={0}
[worker 60321] heavy tick=1
...
[supervisor] received SIGUSR1 -> broadcasting LIGHT mode
[worker 60321] switched to light
...
[supervisor] received SIGHUP -> graceful reload
[supervisor] restarted worker id=0 pid=60345
...
[supervisor] received SIGTERM -> shutting down workers
[supervisor] shutdown complete

#### B) Планирование: nice и CPU-аффинити
При старте супервизор назначает:
воркерам 0 и 1 nice=0, CPU 0;
воркерам 2 и 3 nice=10, CPU 1.

*Команды и метрики*
```bash
pidstat -u 1 10      # загрузка CPU по процессам
taskset -pc <pid>    # проверка привязки к CPU
ps -o pid,ni,psr,cmd # nice и текущий CPU
```

*Наблюдения*
На одном ядре процессы с nice=0 стабильно получают больше квантов CPU, чем с nice=10.
Привязка к конкретным ядрам исключает миграцию и даёт предсказуемую загрузку.


### Ответы на вопросы

1) Чем процесс отличается от потока в Linux? Где это видно в ps и /proc?
Поток — сущность внутри процесса, имеющая собственный стек и регистры, но общее адресное пространство.
В ps -T потоки видны с одинаковым PID в поле PID, но разным SPID (TID). В /proc/<pid>/task/ каждый поток имеет отдельный каталог.

2) Как nice влияет на планирование CFS? Какие есть пределы/исключения?
Параметр nice меняет weight задачи в планировщике CFS: чем выше nice, тем меньше доля CPU. Диапазон от -20 (максимальный приоритет) до +19 (минимальный). Root может понижать nice ниже 0.

3) Что даёт CPU‑аффинити и когда она вредна?
Позволяет закрепить процесс за конкретным ядром, что снижает миграции и кэш-промахи, но может привести к дисбалансу нагрузки при малом числе ядер.

4) Чем отличаются RLIMIT_AS, RLIMIT_DATA, RLIMIT_RSS? Почему RLIMIT_RSS часто игнорируется?
RLIMIT_AS — лимит на всё адресное пространство (обычно реально ограничивает).
RLIMIT_DATA — лимит сегмента heap (часто не используется).
RLIMIT_RSS — лимит резидентной памяти, в Linux обычно игнорируется.

5) Почему возможны зомби и как их избежать при массовых рестартах воркеров?
Возникают, если родитель не делает wait(). Решение — обработчик SIGCHLD и waitpid в супервизоре.

6) Чем отличается «graceful shutdown» от «graceful reload/restart»? Какие последовательности безопасны?
Shutdown — последовательное завершение всех воркеров и самого супервизора.
Reload — перезапуск воркеров без остановки супервизора и приёма сигналов.

7) Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?
Контейнерные лимиты памяти/CPU изменяют данные /proc (например MemAvailable) и могут ограничить реальное потребление независимо от ulimit.

### Выводы
Реализованный супервизор корректно управляет воркерами и обрабатывает сигналы (SIGTERM, SIGHUP, SIGUSR1/2).
Планировщик CFS реагирует на nice: процессы с низким nice получают больше CPU, особенно при пиннинге на одно ядро.
CPU-аффинити повышает предсказуемость, но может привести к недоиспользованию ресурсов.