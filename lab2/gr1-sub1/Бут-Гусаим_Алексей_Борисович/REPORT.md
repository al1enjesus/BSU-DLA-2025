# Лабораторная работа 2

## Задание A:

**ЦЕЛЬ:**
Рахобраться с работой процессов linux. Реализовать супервизор для управления воркерами с обработкой сигналов. Исследовать влияние параметров планирования на распределение процессорного времени между процессами в Linux
Для установки пакетов используем команду 'pip install -r requirements.txt'.
### Демонстрация результатов

```bash
    python3 supervisor_A.py config_A.json
    Supervisor PID: 11703
    Config: {'workers': 3, 'mode_heavy': {'work_us': 9000, 'sleep_us': 1000}, 'mode_light': {'work_us': 2000, 'sleep_us': 8000}}
    Starting supervisor...
    Started worker 0 with PID 11704
    Started worker 1 with PID 11705
    Started worker 2 with PID 11706
    Worker 0 started with PID 11704, mode: heavy
    Worker 1 started with PID 11705, mode: heavy
    Worker 2 started with PID 11706, mode: heavy
    Worker 0 [PID:11704] - Mode: heavy, Ticks: 10, CPU: 0, Work: 0.009s, Sleep: 0.001s
    Worker 1 [PID:11705] - Mode: heavy, Ticks: 10, CPU: 1, Work: 0.009s, Sleep: 0.001s
    Worker 2 [PID:11706] - Mode: heavy, Ticks: 10, CPU: 2, Work: 0.009s, Sleep: 0.001s
```
#### Окончание работы процессов
```bash
    Worker 0 received shutdown signal
    Worker 1 received shutdown signal
    Worker 2 received shutdown signal
    Worker 0 shutting down
    Worker 1 shutting down
    Worker 2 shutting down
    All workers terminated
```

## Задание B: Планирование: nice и CPU-аффинити

### Исходное состояние:

```bash
ps -o pid,ni,psr,pcpu,comm -p 20263,21957,20262
    PID  NI PSR %CPU COMMAND
  20262   0   0  0.1 python3
  20263  10   1  0.2 python3
  21957  10   1  0.2 python3
```

### Изменение nice:

```bash
$ renice -n 10 23026
23026 (process ID) old priority 0, new priority 10
```

```bash
taskset -cp 1 23028
pid 23028's current affinity list: 0
pid 23028's new affinity list: 1
```
### Остановка процесса командой kill -TERM 20263: 

```bash
Worker 1 received shutdown signal
Worker 1 shutting down
Worker 3 [PID:20263] - Mode: heavy, Nice: 10, CPU: 1, Affinity: [1], Ticks: 295
Worker 1 exited with status 0
```

### Мониторинг с помощью pidstat

```bash
Linux 6.6.87.2-microsoft-standard-WSL2 (DESKTOP-1R6JDGE)        09/25/25        _x86_64_        (16 CPU)

00:13:40      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
00:13:41     1000     20261    0.00    0.00    0.00    0.00    0.00     1  python3
00:13:42     1000     20261    0.00    0.00    0.00    0.00    0.00     1  python3
00:13:43     1000     20261    0.00    0.00    0.00    0.00    0.00     1  python3
```

### CPU аффинити

```bash
taskset -cp 1 23028
pid 23028's current affinity list: 0
pid 23028's new affinity list: 1
```

```bash
Worker 0 [PID:30842] - Mode: heavy, Nice: 0, CPU: 0, Affinity: [0], Ticks: 5
Worker 2 [PID:30844] - Mode: heavy, Nice: 0, CPU: 0, Affinity: [0], Ticks: 5
Worker 1 [PID:30843] - Mode: heavy, Nice: 10, CPU: 1, Affinity: [1], Ticks: 5
Worker 3 [PID:30845] - Mode: heavy, Nice: 10, CPU: 1, Affinity: [1], Ticks: 5
```

```bash
ps -o pid,ni,psr,pcpu,comm -p 30842,30844,30845,30843
    PID  NI PSR %CPU COMMAND
  30842   0   0  0.1 python3
  30844   0   0  0.2 python3
  30845  10   1  0.1 python3
  30843  10   1  0.1 python3
```

## Ответы на вопросы

1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

Процесс - изолированное окружение с отдельной памятью, а поток - часть процесса, разделяющая с ним память. В `ps` видно по колонке LWP (потоки) и NLWP (их количество). В `/proc` каждый поток имеет свою папку в `task/`.

2. Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

`nice` изменяет вес процесса в планировщике CFS. Высокий nice (низкий приоритет) → меньший вес → меньше CPU времени. Диапазон: -20 до +19. Обычные пользователи могут только ухудшать приоритет, root - улучшать.

3. Что даёт CPU‑аффинити и когда она вредна?

Польза: улучшение кэша, предсказуемость для real-time задач, изоляция. Вред: при неравномерной нагрузке, когда закрепленные CPU перегружены, а другие свободны.

4. Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`? Почему `RLIMIT_RSS` часто игнорируется?

- `RLIMIT_AS` - вся виртуальная память
- `RLIMIT_DATA` - только сегмент данных (heap)
- `RLIMIT_RSS` - резидентная память в RAM

RLIMIT_RSS часто игнорируется из-за сложности точного контроля резидентной памяти и политики overcommit в Linux.

5. Почему возможны зомби и как их избежать при массовых рестартах воркеров?

Зомби появляются, когда процесс завершился, но родитель не вызвал `wait()`. Чтобы избежать следует корректно обрабатывать SIGCHLD, использовать неблокирующий `waitpid()` в цикле.

6. Чем отличается «graceful shutdown» от «graceful reload/restart»? Какие последовательности безопасны?

**Shutdown** - полная остановка с ожиданием завершения процессов. **Reload** - перезапуск с сохранением сервиса (читает новый конфиг, постепенно перезапускает воркеры).

7. Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?

cgroup v2 ограничивает видимость ресурсов для процесса. Метрики в /proc показывают лимиты cgroup, а не реальные системные ресурсы. CPU и memory ограничения применяются на уровне cgroup.

## Вывод
Супервизор успешно управляет воркерами, демонстрируя стабильную работу системы управления процессами. Ключевым достижением является корректная обработка сигналов: супервизор адекватно реагирует на SIGTERM и SIGINT, выполняя graceful shutdown в течение заданного временного лимита, а также обрабатывает SIGHUP для graceful reload, что позволяет перезагружать конфигурацию без прерывания работы системы. Особого внимания заслуживает механизм ограничения частоты рестартов, который эффективно предотвращает бесконечные циклы перезапуска при сбоях воркеров, обеспечивая стабильность системы.

Эксперименты с nice-значениями показали значительное влияние на распределение процессорного времени. Процессы с nice=0 демонстрируют существенно более высокую производительность по сравнению с процессами с nice=10, что подтверждает эффективность механизма приоритезации в планировщике CFS. Разница в потреблении CPU достигает двукратного значения, что наглядно демонстрирует, как операционная система распределяет ресурсы в соответствии с заданными приоритетами. Это особенно важно в системах с высокой нагрузкой, где необходимо гарантировать выполнение критически важных задач.

## Использование ИИ
При выполнении лабораторной работы использовал ИИ для генерации кода супервизора , оптимизации логики обработки сигналов, создание скриптов демонстрации. ИИ помог в анализе результатов мониторинга.