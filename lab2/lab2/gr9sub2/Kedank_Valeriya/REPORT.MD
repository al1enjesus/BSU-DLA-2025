# Лабораторная 2
# Задание A: Мини-супервизор

## Цель

Реализовать супервизор, управляющий воркерами через сигналы, отслеживающий их состояние, обеспечивающий корректное завершение, перезапуск при аварии, переключение режимов нагрузки и мягкую перезагрузку конфигурации.

## Шаги реализации

1. Создана структура проекта: `supervisor.py`, `worker.py`, `config.json`, `run.sh`.
2. Воркеры запускаются супервизором как дочерние процессы.
3. Обработка сигналов:
   - `SIGCHLD` — отслеживание завершения воркеров.
   - `SIGTERM` / `SIGINT` — корректное завершение всех воркеров.
   - `SIGHUP` — мягкий reload конфигурации и перезапуск воркеров.
   - `SIGUSR1` / `SIGUSR2` — переключение режима нагрузки.
4. Реализована защита от частого перезапуска: не более 5 рестартов за 30 секунд.
5. Воркеры выводят диагностические строки: PID, режим, тик, CPU.
6. Добавлена совместимость с Python 3.8 — замена `os.sched_getcpu()` на чтение из `/proc/self/stat`.

## Выводы

- Сигналы корректно обрабатываются: воркеры переключаются между режимами, завершаются и перезапускаются.
- Перезапуск ограничен по частоте, как указано в задании.
- После завершения супервизора некоторые воркеры остались активны — добавлена зачистка через `pkill`.
- Все действия демонстрируются через `run.sh`.

### Пример вывода из консоли:

```text
[Supervisor PID=26511] Running with 3 workers.
[Worker PID=26513] Mode=heavy Tick=98 CPU=4
[Worker PID=26514] Mode=heavy Tick=98 CPU=3
[Worker PID=26515] Mode=heavy Tick=98 CPU=1
Switching to light mode
[Worker PID=26513] Mode=light Tick=292 CPU=7
[Worker PID=26514] Mode=light Tick=292 CPU=0
[Worker PID=26515] Mode=light Tick=293 CPU=1
Reloading config
[Supervisor] Reloading config and restarting workers...
[Worker PID=26515] Exiting gracefully.
[Supervisor] Worker 26515 exited with code 0
[Supervisor] Restarting worker 26515
[Supervisor] Restart limit reached
Graceful shutdown
[Supervisor] Shutting down...
[Supervisor] All workers exited.
```

# Задание Б: Планирование — nice и CPU-аффинити

##  Цель

Исследовать влияние параметров планирования процессов на их поведение и загрузку CPU:

- Установить разные значения `nice` для воркеров
- Назначить CPU-аффинити (закрепление за конкретными ядрами)
- Сравнить метрики использования CPU и времени ожидания


##  Шаги реализации

1. В `supervisor.py` добавлена функция `spawn_worker(nice_value, cpu_core)`:
   - Воркеры запускаются с `nice=10` (низкий приоритет) или `nice=0` (стандартный)
   - Используется библиотека `psutil` для назначения CPU-аффинити: часть воркеров закреплена за ядром 0, часть — за ядром 1

2. В конфигурации указано `workers: 4`, чтобы протестировать оба режима

3. После запуска лабораторной (`./run.sh`) выполнена команда:

```bash
ps -ef | grep worker.py
```

Получен PID воркера: 30707

Сняты метрики через: pidstat -u 1 10 -p 30707

Пример вывода:
```text

Time       UID     PID   %usr %system %guest %wait  %CPU  CPU Command
14:37:32   1000   30707   1.00    0.00   0.00   1.00   1.00   0  python3
14:37:33   1000   30707   0.00    1.00   0.00   0.00   1.00   0  python3
14:37:34   1000   30707   1.00    0.00   0.00   0.00   1.00   0  python3
14:37:35   1000   30707   0.00    1.00   0.00   0.00   1.00   0  python3
14:37:36   1000   30707   1.00    0.00   0.00   1.00   1.00   0  python3
14:37:37   1000   30707   0.00    0.00   0.00   0.00   0.00   0  python3
14:37:38   1000   30707   1.00    0.00   0.00   0.00   1.00   0  python3
14:37:39   1000   30707   1.00    0.00   0.00   0.00   1.00   0  python3
14:37:40   1000   30707   0.00    1.00   0.00   0.00   1.00   0  python3
14:37:41   1000   30707   0.00    0.00   0.00   0.00   0.00   0  python3

Среднее: PID 30707 — %usr: 0.50, %system: 0.30, %wait: 0.20, %CPU: 0.80

```

# Задание D*: Память и OOM

## Цель

Исследовать поведение процессов при росте потребления памяти и при ограничениях:

- Постепенно увеличивать RSS (реальный объём занятой памяти).
- Снимать метрики через `pidstat` и `/proc/<pid>/status`.
- Ограничить адресное пространство через `ulimit` и `setrlimit`.
- Зафиксировать поведение при достижении лимита памяти.

## Шаги реализации

1. Написан Python-скрипт `mem_touch.py`, который каждую секунду выделяет и заполняет 10 MB памяти. В начале работы устанавливается ограничение на виртуальную память через `setrlimit(RLIMIT_AS)`:

```python
import time
import resource

limit_mb = 500
limit_bytes = limit_mb * 1024 * 1024
resource.setrlimit(resource.RLIMIT_AS, (limit_bytes, limit_bytes))

print(f"[mem_touch] RLIMIT_AS установлен: {limit_mb} MB")

blocks = []
step_mb = 10
step_bytes = step_mb * 1024 * 1024

try:
    for i in range(100):
        block = bytearray(step_bytes)
        for j in range(0, step_bytes, 4096):
            block[j] = 1
        blocks.append(block)
        print(f"[mem_touch] Выделено: {(i+1)*step_mb} MB")
        time.sleep(1)
except MemoryError:
    print("[mem_touch] MemoryError: достигнут предел RLIMIT_AS")

print("[mem_touch] Завершение")
time.sleep(60)
```

Скрипт запущен: python3 mem_touch.py

Вывод в терминале:
```text
[mem_touch] RLIMIT_AS установлен: 500 MB
[mem_touch] Выделено: 10 MB
[mem_touch] Выделено: 20 MB
[mem_touch] Выделено: 30 MB
[mem_touch] Выделено: 40 MB
[mem_touch] Выделено: 50 MB
[mem_touch] Выделено: 60 MB
[mem_touch] Выделено: 70 MB
[mem_touch] Выделено: 80 MB
[mem_touch] Выделено: 90 MB
```

Получен PID процесса:
```bash
ps -ef | grep mem_touch.py
#PID: 34101
```

## Метрики потребления памяти
### Вывод /proc/<pid>/status
```text
Name:   python3
State:  S (sleeping)
VmPeak:   511784 kB
VmSize:   511784 kB
VmRSS:    500292 kB
VmData:   500000 kB
Threads:    1
```
### Вывод pidstat -r 1 10 -p 34101
```text
Linux 5.15.0-46-generic (lera-VivoBook-ASUSLaptop-X513EAN-K513EA)  28.09.2025  _x86_64_  (8 CPU)

Time       UID     PID   minflt/s  majflt/s     VSZ     RSS   %MEM  Command
15:04:19   1000   34101      0.00      0.00   511784  500292   3.11  python3
15:04:20   1000   34101      0.00      0.00   511784  500292   3.11  python3
...
Среднее:   1000   34101      0.00      0.00   511784  500292   3.11  python3
```

## Ограничение памяти

Установлено через setrlimit(RLIMIT_AS) в Python: 500 MB.
При достижении лимита возникает MemoryError, процесс не завершается аварийно.
Поведение отличается от RLIMIT_DATA и RLIMIT_RSS — они не поддерживаются в Python напрямую.
Ограничение работает: VmSize и VmRSS стабилизируются около 500 MB.

## Выводы

RSS растёт линейно при выделении и заполнении памяти.
Ограничение через RLIMIT_AS работает: при превышении лимита возникает MemoryError.
Ядро отслеживает потребление через /proc/<pid>/status, VmRSS, VmSize, VmPeak.
pidstat показывает рост RSS и %MEM.
RLIMIT_DATA и RLIMIT_RSS не влияют на поведение Python-процесса.
Поведение при OOM можно дополнительно протестировать через cgroup v2.


## Ответы на теоретические вопросы

### Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?

- Процесс — это независимая единица выполнения с собственным адресным пространством.
- Поток (thread) — часть процесса, разделяющая память и ресурсы с другими потоками.
- В `ps` потоки отображаются с флагом `-L` (например, `ps -eLf`).
- В `/proc/<pid>/task/` — каждый поток имеет собственный TID и подкаталог.

---

### Как `nice` влияет на планирование CFS? Какие есть пределы/исключения?

- `nice` определяет приоритет процесса: от `-20` (высокий) до `+19` (низкий).
- В планировщике CFS (`Completely Fair Scheduler`) `nice` влияет на вес процесса — чем выше `nice`, тем меньше CPU.
- Исключения:
  - Не влияет на процессы с реальным временем (`SCHED_FIFO`, `SCHED_RR`).
  - В многопроцессорных системах эффект может быть сглажен.

---

### Что даёт CPU-аффинити и когда она вредна?

- CPU-аффинити закрепляет процесс за конкретным ядром.
- Полезно для:
  - Повышения кэш-локальности
  - Снижения миграций между ядрами
- Вредно, если:
  - Ядро перегружено, а другие простаивают
  - Процессу не хватает ресурсов, но он не может мигрировать

---

### Чем отличаются `RLIMIT_AS`, `RLIMIT_DATA`, `RLIMIT_RSS`? Почему `RLIMIT_RSS` часто игнорируется?

| Лимит         | Описание                                       | Поддержка          |
|---------------|------------------------------------------------|--------------------|
| `RLIMIT_AS`   | Ограничивает виртуальное адресное пространство | да                 |
| `RLIMIT_DATA` | Ограничивает размер сегмента данных (heap)     | ограничено         |
| `RLIMIT_RSS`  | Ограничивает реальный объём в RAM (RSS)        | часто игнорируется |

- `RLIMIT_RSS` игнорируется, так как ядро Linux не отслеживает RSS как лимитируемый ресурс.

---

### Почему возможны зомби и как их избежать при массовых рестартах воркеров?

- Зомби возникают, когда дочерний процесс завершился, но родитель не вызвал `wait()`.
- При массовых рестартах:
  - Если не обрабатывать `SIGCHLD`, зомби накапливаются.
  - Решение: обработка `SIGCHLD` и вызов `waitpid()` или `poll()`.

---

### Чем отличается graceful shutdown от graceful reload/restart? Какие последовательности безопасны?

- **Graceful shutdown**:
  - Отправка `SIGTERM`/`SIGINT`
  - Ожидание завершения воркеров (≤ 5 секунд)
  - Завершение супервизора

- **Graceful reload**:
  - Отправка `SIGHUP`
  - Перечитывание конфигурации
  - Перезапуск воркеров без остановки супервизора

- Безопасная последовательность:
  - `SIGHUP` -> `SIGTERM` воркерам → запуск новых воркеров → продолжение работы

---

### Как повлияют контейнерные лимиты (`cgroup v2`) на наблюдаемые метрики процесса?

- `cgroup v2` позволяет задать лимиты:
  - `memory.max` — ограничение по памяти
  - `cpu.max` — ограничение по CPU
- Влияние:
  - Процесс может быть завершён при OOM -> видно в `dmesg`
  - Метрики в `/proc/<pid>/status` и `pidstat` покажут ограниченное потребление
  - Поведение зависит от политики: `oom.kill`, `swap.max`, `memory.high`

