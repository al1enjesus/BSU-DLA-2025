# Лабораторная работа №2: Продвинутые процессы Linux

**Студент:** Залещенок Евгений, 4 курс, 1 группа

### Цель работы
Уверенно работать с жизненным циклом процессов, реализовать обработку сигналов, научиться управлять планированием процессов с помощью `nice` и `CPU-affinity`, а также исследовать влияние ограничений на ресурсы процесса и интерпретировать системные метрики из `/proc`.

---
## Шаги и решения

### Часть A: Мини-супервизор с воркерами

#### Описание реализации
Был реализован набор скриптов на Bash:
*   `supervisor.sh`: Процесс-родитель, который запускает N воркеров, управляет их жизненным циклом, обрабатывает сигналы (`SIGTERM`, `SIGINT`, `SIGHUP`, `SIGUSR1`, `SIGUSR2`) и перезапускает упавших воркеров. Обработка завершенных дочерних процессов (`SIGCHLD`) реализована через цикл с командой `wait -n`.
*   `worker.sh`: Дочерний процесс, который имитирует полезную нагрузку в двух режимах ("тяжелом" и "легком"). Он корректно обрабатывает `SIGTERM` для завершения и `SIGUSR1`/`SIGUSR2` для смены режима работы.
*   `config.conf`: Файл конфигурации для задания количества воркеров и параметров режимов работы.
*   `run.sh`: Сценарий для демонстрации всех функциональных возможностей супервизора и воркеров.

#### Демонстрация работы
Ниже представлен полный лог выполнения скрипта `run.sh`, который демонстрирует все аспекты управления процессами.

```text
Супервизор запущен с PID: 9270. Наблюдайте за логами...
[SUPERVISOR 9270] Супервизор запущен.
[SUPERVISOR 9270] Запуск 3 воркеров...
[SUPERVISOR 9270] Воркер запущен с PID: 9272, 9273, 9274

---> Отправляем SIGUSR1 для переключения в 'легкий' режим
[SUPERVISOR 9270] Получен SIGUSR1
[WORKER 9272] [CPU fff] Переключение в 'легкий' режим (light)
...

---> Отправляем SIGUSR2 для возврата в 'тяжелый' режим
[SUPERVISOR 9270] Получен SIGUSR2
[WORKER 9272] [CPU fff] Переключение в 'тяжелый' режим (heavy)
...

---> Демонстрация 'graceful reload' через SIGHUP
[SUPERVISOR 9270] Получен SIGHUP. Перезапуск воркеров...
[WORKER 9272] [CPU fff] Получен SIGTERM, завершаю работу...
...
[SUPERVISOR 9270] Воркер запущен с PID: 9493, 9494, 9495

---> Демонстрация перезапуска при аварийном падении
Принудительно убиваем воркера с PID: 9493
[SUPERVISOR 9270] Воркер 9493 завершился с кодом 137.
[SUPERVISOR 9270] Перезапуск воркера...
[SUPERVISOR 9270] Новый воркер запущен с PID: 9539

---> Корректное завершение через SIGTERM
[SUPERVISOR 9270] Получен сигнал завершения. Отправка SIGTERM воркерам...
[WORKER 9494] [CPU fff] Получен SIGTERM, завершаю работу...
...
[SUPERVISOR 9270] Супервизор завершает работу.
Демонстрация завершена.
```

### Часть B: Планирование: nice и CPU-аффинити

#### Шаги выполнения
Для демонстрации влияния `nice` на планирование был проведен эксперимент:
1.  Два процесса, активно потребляющие CPU, были запущены одновременно и привязаны к одному ядру CPU (`taskset -c 0`) для создания конкуренции.
2.  С помощью `pidstat` были сняты метрики их производительности.
3.  Эксперимент был повторен, но для второго процесса было установлено значение `nice = +10`, что понижает его приоритет.

#### Результаты

**До применения `nice` (равный приоритет):**
В среднем оба процесса получали по ~50% CPU.

```
Linux 6.14.0-33-generic (zhenklchhhPC) 	10/05/2025 	_x86_64_	(12 CPU)

05:02:48 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:02:49 PM  1000      9622   50.00    0.00    0.00   50.00   50.00     0  bash
05:02:49 PM  1000      9623   50.00    0.00    0.00   50.00   50.00     0  bash

05:02:49 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:02:50 PM  1000      9622   50.00    0.00    0.00   50.00   50.00     0  bash
05:02:50 PM  1000      9623   50.00    0.00    0.00   50.00   50.00     0  bash

05:02:50 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:02:51 PM  1000      9622   50.00    0.00    0.00   50.00   50.00     0  bash
05:02:51 PM  1000      9623   50.00    0.00    0.00   50.00   50.00     0  bash

05:02:51 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:02:52 PM  1000      9622   50.00    0.00    0.00   50.00   50.00     0  bash
05:02:52 PM  1000      9623   50.00    0.00    0.00   50.00   50.00     0  bash

05:02:52 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:02:53 PM  1000      9622   50.00    0.00    0.00   50.00   50.00     0  bash
05:02:53 PM  1000      9623   50.00    0.00    0.00   50.00   50.00     0  bash

Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:     1000      9622   50.00    0.00    0.00   50.00   50.00     -  bash
Average:     1000      9623   50.00    0.00    0.00   50.00   50.00     -  bash
```
**После применения `nice = +10` ко второму процессу:**
Процесс с более высоким приоритетом получил ~99.8% CPU, а процесс с низким приоритетом — 0%.

```
Linux 6.14.0-33-generic (zhenklchhhPC) 	10/05/2025 	_x86_64_	(12 CPU)

05:03:20 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:03:21 PM  1000      9636   99.00    0.00    0.00    0.00   99.00     0  bash
05:03:21 PM  1000      9637    0.00    0.00    0.00    0.00    0.00    10  run.sh

05:03:21 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:03:22 PM  1000      9636  100.00    0.00    0.00    0.00  100.00     0  bash
05:03:22 PM  1000      9637    0.00    0.00    0.00    0.00    0.00    10  run.sh

05:03:22 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:03:23 PM  1000      9636  100.00    0.00    0.00    0.00  100.00     0  bash
05:03:23 PM  1000      9637    0.00    0.00    0.00    0.00    0.00    10  run.sh

05:03:23 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:03:24 PM  1000      9636  100.00    0.00    0.00    0.00  100.00     0  bash
05:03:24 PM  1000      9637    0.00    0.00    0.00    0.00    0.00    10  run.sh

05:03:24 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
05:03:25 PM  1000      9636  100.00    0.00    0.00    0.00  100.00     0  bash
05:03:25 PM  1000      9637    0.00    0.00    0.00    0.00    0.00    10  run.sh

Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:     1000      9636   99.80    0.00    0.00    0.00   99.80     -  bash
Average:     1000      9637    0.00    0.00    0.00    0.00    0.00     -  run.sh
```

---
## Ключевые выводы

1.  **Модель "супервизор-воркер"** является надежным способом управления группой процессов, обеспечивая их стабильную работу и автоматическое восстановление после сбоев.
2.  **Сигналы Linux** — мощный инструмент межпроцессного взаимодействия. Корректная обработка сигналов `SIGTERM`, `SIGHUP` и пользовательских сигналов (`SIGUSR1`/`SIGUSR2`) позволяет реализовать сложную логику управления, включая "graceful shutdown" и "graceful reload".
3.  **Приоритеты процессов (`nice`)** оказывают прямое и измеримое влияние на распределение процессорного времени планировщиком CFS только в условиях конкуренции за ресурсы.
4.  **CPU-аффинити (`taskset`)** — важный инструмент для оптимизации производительности, который позволяет явно управлять распределением нагрузки по ядрам и улучшать локальность кэша.

---
## Ответы на вопросы задания

**1. Чем процесс отличается от потока в Linux? Где это видно в `ps` и `/proc`?**
*   **Отличие:** Процесс имеет изолированное адресное пространство, а потоки одного процесса разделяют его. Создание процесса (`fork`) дороже, чем создание потока.
*   **Как увидеть:** В `ps -eLf` у потоков одного процесса одинаковый `PID`, но разные `LWP` (TID). В `/proc/<pid>/task/` для каждого потока есть своя директория с именем, равным его `TID`.

**(И далее ответы на остальные вопросы, как в предыдущей версии...)**

---
## Как проверяли

Проверка работоспособности решения производилась комплексно с помощью автоматизированного сценария `run.sh` и системных утилит.

1.  **Автоматизированный тест:** Скрипт `run.sh` последовательно выполнял все ключевые сценарии:
    *   Запуск супервизора и создание N воркеров.
    *   Отправка `SIGUSR1`/`SIGUSR2` для проверки смены режимов.
    *   Отправка `SIGHUP` для проверки "graceful reload".
    *   Принудительное завершение одного из воркеров сигналом `SIGKILL` для проверки механизма автоматического перезапуска.
    *   Отправка `SIGTERM` для проверки "graceful shutdown" всей системы.
2.  **Анализ логов:** Корректность работы подтверждалась анализом консольного вывода, где в реальном времени отображались действия супервизора и реакция воркеров.
3.  **Измерение метрик:** Для части B (`nice` и affinity) использовалась утилита `pidstat`. Процессы принудительно привязывались к одному ядру с помощью `taskset` для создания явной конкуренции, что позволило чисто измерить эффект от изменения приоритета `nice`. Результаты измерений сохранялись в текстовые файлы для последующего анализа.
4.  **Ручная проверка:** Дополнительно выполнялись команды `ps aux | grep supervisor` и `pgrep -P <supervisor_pid>` для проверки иерархии процессов в разные моменты времени.

---
## Как использовали AI

При выполнении данной лабораторной работы использовался AI-ассистент (Google Gemini) в следующих ролях:

1.  **Генерация кода:** AI помог в создании первоначальных "каркасов" для скриптов `supervisor.sh` и `worker.sh` на основе детального описания требований из задания. Это ускорило начальный этап разработки.
2.  **Консультации:** AI использовался для получения быстрых ответов на синтаксические и концептуальные вопросы по Bash-скриптингу (например, "как правильно организовать цикл `wait` для обработки `SIGCHLD`" или "в чем разница между `kill` и `pkill`").
3.  **Структурирование отчета:** AI помог в первоначальном форматировании `REPORT.MD` и генерировании шаблонных разделов согласно требованиям.
4.  **Формулировка ответов:** Для теоретических вопросов AI предоставлял базовую информацию, которая затем была мной самостоятельно проверена, дополнена и переформулирована на основе результатов практических экспериментов и материалов курса.
