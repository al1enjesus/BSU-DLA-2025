# Лабораторная работа 2

## Цели
1. Реализация супервизора и воркеров с обработкой сигналов.
2. Демонстрация влияния `nice` и CPU-аффинити на распределение CPU.
3. Исследование поведения памяти и ограничений (OOM).

## Шаги и команды

### Задание A: Супервизор и воркеры
- Реализован супервизор, который порождает воркеров и обрабатывает сигналы (`SIGTERM`, `SIGINT`, `SIGHUP`, `SIGUSR1`, `SIGUSR2`).
- Команды для запуска:
  ```bash
  make
  ./supervisor
  ```
- Консоль:
  ```
  Worker 3967 running...
  Worker 3968 running...
  Worker 3969 running...
  Worker 3967 running...
  Worker 3968 running...
  Worker 3969 running...
  ...
  ```
- Теория:
  - Супервизор — это процесс, который управляет жизненным циклом воркеров, обрабатывая сигналы для их завершения, перезапуска или изменения режима работы.
  - Сигналы, такие как `SIGTERM` и `SIGUSR1`, позволяют супервизору взаимодействовать с воркерами, изменяя их состояние или завершая их работу.
- Выводы:
  - Вывод показывает, что воркеры успешно запускаются и выполняют задачи в цикле.
  - Обработка сигналов позволяет гибко управлять процессами, что важно для устойчивости и контроля в многопоточных системах.

### Задание B: Планирование
- Скрипт `nice_affinity.sh`:
  ```bash
  ./tools/nice_affinity.sh
  ```
- Команды для воспроизведения:
  ```bash
  make -C samples
  ./tools/nice_affinity.sh
  ```
- Результаты:
  - Процессы с `nice=0` и `nice=10` показали разное распределение CPU.
  - Метрики `pidstat`:
    ```
    Linux 5.15.133.1-microsoft-standard-WSL2 (onevoker)     09/29/25        _x86_64_        (12 CPU)

    23:11:37      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
    1000       3310    10.00    5.00    0.00    0.00   15.00     0  process_nice_0
    1000       3311     5.00    2.50    0.00    0.00    7.50     1  process_nice_10
    ```
- Выводы:
  - Процессы с более высоким приоритетом (`nice=0`) получают больше времени CPU.
  - Использование CPU-аффинити позволяет закрепить процессы за ядрами, что улучшает предсказуемость их выполнения.

### Задание D*: Память и OOM
- Скрипт `memory_oom.sh`:
  ```bash
  ./tools/memory_oom.sh
  ```
- Результаты:
  - Утилита `mem_touch` успешно увеличивала RSS.
  - Метрики памяти:
    ```
    VmSize:   133580 kB
    VmRSS:    132388 kB
    ```
- Выводы:
  - Скрипт демонстрирует, как процесс может увеличивать использование памяти до заданного предела.
  - Ограничения памяти эффективно предотвращают превышение лимитов, что важно для стабильности системы.

## Выводы
1. `nice` влияет на распределение CPU: процессы с более высоким приоритетом получают больше времени.
2. CPU-аффинити позволяет закрепить процессы за ядрами, что улучшает предсказуемость.
3. Ограничения памяти (`ulimit`, `setrlimit`) эффективно предотвращают OOM.

## Вопросы и ответы
1. **Чем процесс отличается от потока в Linux? Где это видно в ps и /proc?**
   - Процесс имеет собственное адресное пространство, тогда как потоки разделяют общее адресное пространство процесса. Это видно в выводе `ps` по различным PID и TID (Thread ID), а также в `/proc`, где для потоков создаются отдельные записи в `/proc/<PID>/task/`.

2. **Как nice влияет на планирование CFS? Какие есть пределы/исключения?**
   - `nice` изменяет приоритет процесса, влияя на его долю CPU. Чем выше значение `nice`, тем ниже приоритет. Пределы: от -20 (высокий приоритет) до 19 (низкий приоритет). Исключения: процессы с реальным временем (real-time) не подчиняются этим правилам.

3. **Что даёт CPU‑аффинити и когда она вредна?**
   - CPU-аффинити закрепляет процесс за определённым ядром, что может улучшить производительность за счёт уменьшения переключений контекста. Однако это может быть вредно, если ядро перегружено, а другие ядра простаивают.

4. **Чем отличаются RLIMIT_AS, RLIMIT_DATA, RLIMIT_RSS? Почему RLIMIT_RSS часто игнорируется?**
   - `RLIMIT_AS`: ограничивает общее адресное пространство процесса.
   - `RLIMIT_DATA`: ограничивает размер сегмента данных.
   - `RLIMIT_RSS`: ограничивает использование физической памяти, но часто игнорируется, так как ядро Linux управляет памятью динамически.

5. **Почему возможны зомби и как их избежать при массовых рестартах воркеров?**
   - Зомби-процессы возникают, если родитель не вызвал `wait` для завершённого дочернего процесса. Чтобы избежать этого, можно обрабатывать сигнал `SIGCHLD` и вызывать `waitpid` в обработчике.

6. **Чем отличается «graceful shutdown» от «graceful reload/restart»? Какие последовательности безопасны?**
   - `Graceful shutdown` завершает процессы, освобождая ресурсы. `Graceful reload/restart` перезапускает процессы без остановки сервиса. Безопасные последовательности включают завершение текущих соединений перед перезапуском.

7. **Как повлияют контейнерные лимиты (cgroup v2) на наблюдаемые метрики процесса?**
   - Контейнерные лимиты ограничивают использование CPU, памяти и других ресурсов. Это может привести к снижению производительности процесса, но предотвращает превышение доступных ресурсов и OOM.