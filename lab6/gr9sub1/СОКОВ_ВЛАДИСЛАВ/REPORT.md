# Отчёт по лабораторной работе 6 — Файловые системы FUSE

**Студент:** Соков Владислав  
**Операционная система:** Ubuntu 24.04.3 LTS  
**Ядро:** Linux 6.6.87.2-microsoft-standard-WSL2  
**Дата:** 2025-11-21

## 1. Цель работы
Изучить архитектуру виртуальной файловой системы (VFS) Linux и научиться создавать пользовательские файловые системы с использованием FUSE.  
Разработать три простых файловых системы:
* passthrough (зеркалирование)
* rot13 (шифрование ROT13)
* upper (верхний регистр при чтении)

Проверить корректность операций и оценить влияние userspace-файловой системы на производительность.

## 2. Теоретическая часть

### Архитектура VFS и роль FUSE
- **VFS (Virtual File System)** — абстрактный слой в ядре Linux, который предоставляет единый интерфейс для разных реальных файловых систем. VFS инкапсулирует операции над файлами (read, write, open, getattr и т.д.) и работает с абстракциями `inode`, `dentry`, `file`/файловыми дескрипторами и `superblock`.

- **Роль FUSE:** FUSE (Filesystem in Userspace) позволяет реализовывать файловые системы в пространстве пользователя (userspace) при помощи небольшого модуля в ядре, который проксирует запросы VFS в userspace-процесс. Это делает разработку FS безопаснее и быстрее по циклу разработки, но добавляет оверхед на переключениях между ядром и userspace.

### Схема взаимодействия
```
┌────────────┐
│ Приложение │
└──────┬─────┘
│ system calls (open, read, write…)
▼
┌────────────┐
│    VFS     │
└──────┬─────┘
│ generic FS interface
▼
┌─────────────────┐
│ FUSE kernel mod │
└──────┬──────────┘
│ FUSE protocol
▼
┌─────────────────┐
│ Userspace FS    │  ← наша программа myfuse
└─────────────────┘
```

### Реализованные file operations
В работе реализованы следующие операции:
- `getattr` — получение атрибутов файла/директории (`stat`).
- `readdir` — чтение содержимого директории.
- `open` — проверка возможности открытия файла (проверка прав).
- `read` — чтение данных (с поддержкой offset).
- `write` — запись данных (с поддержкой offset); в rot13 — записываются зашифрованные данные.
- `create` — создание нового файла.
- `unlink` — удаление файла.
- `mkdir` — создание директории.
- `rmdir` — удаление директории.
- `destroy` — очистка при размонтировании.

Для режима `rot13` добавлено преобразование данных при чтении/записи; для режима `upper` — преобразование в верхний регистр при чтении. Все операции логируются в `stderr` в формате `[TIMESTAMP] OPERATION: path (result)`.

## 3. Ход выполнения

### Общая организация
Реализована единая программа `myfuse`, которая запускается в одном из трёх режимов: `passthrough`, `rot13`, `upper`. Режим задаётся опцией `--mode=<passthrough|rot13|upper>` (по умолчанию `passthrough`). Базовая директория (source) передаётся как первый аргумент, точка монтирования — второй.

Файлы реализации:
```
src/
├── myfuse.c        # точка входа, разбор аргументов, вызов fuse_main
├── operations.c    # реализация операций FUSE
├── operations.h    # заголовок
└── utils.c         # логирование, безопасное соединение путей, ROT13/upper
```

Ключевые моменты реализации:
- Безопасное вычисление полного пути (`normalize_join`) — защита от path traversal (`..`) и проверка, что итоговый путь лежит внутри `base`.
- Логирование каждой операции с временной меткой.
- Корректная обработка ошибок: при системных ошибках возвращаем `-errno`.
- Трансформации:
  - `rot13` — при `write` буфер шифруется ROT13 перед записью, при `read` — результат расшифровывается перед возвратом.
  - `upper` — при `read` результат переводится в верхний регистр.

### Задание A: Passthrough FUSE

#### Реализация
Passthrough реализован как проксирование операций в реальную файловую систему — все системные вызовы выполняются над `base` + `path`. Ключевые функции:
- `fs_getattr` — `lstat(fullpath, stbuf)`; возвращает `-errno` при ошибке.
- `fs_readdir` — `opendir(fullpath)` + `readdir()` + `filler`.
- `fs_open` — `open(fullpath, flags)` (проверка доступности).
- `fs_read`/`fs_write` — `pread`/`pwrite` с логированием.
- `fs_create`/`fs_unlink`/`fs_mkdir`/`fs_rmdir` — соответствующие вызовы libc.

#### Команды для запуска
```bash
make
mkdir -p /tmp/source /mnt/fuse
./myfuse /tmp/source /mnt/fuse -f
```

#### Тестирование

```bash
$ echo "test" > /mnt/fuse/file.txt
[2025-11-21 05:24:27] CREATE: /file.txt (result: 0)
[2025-11-21 05:24:27] GETATTR: /file.txt (result: 0)
[2025-11-21 05:24:27] WRITE: /file.txt (result: 5)

$ cat /mnt/fuse/file.txt
[2025-11-21 05:25:28] OPEN: /file.txt (result: 0)
[2025-11-21 05:25:28] READ: /file.txt (result: 5)
test
```

---

### Задание B: ROT13 Encryption Filesystem

#### Реализация

* При `write` данные, приходящие из userspace, копируются во временный буфер и преобразуются ROT13, затем записываются на диск (в `base`).
* При `read` данные читаются с диска (ROT13-enc), затем применяем ROT13 и возвращаем расшифрованный текст пользователю.
* Метаданные (имена, права, временные метки) хранятся и возвращаются без изменений.

#### Команды для запуска

```bash
make
mkdir -p /tmp/source /mnt/fuse
./myfuse /tmp/source /mnt/fuse -f --mode=rot13
```

#### Тестирование

```bash
# На монтированной точке записываем "Hello World"
$ echo "Hello World" > /mnt/fuse/secret.txt
[2025-11-21 05:29:30] CREATE: /secret.txt (result: 0)
[2025-11-21 05:29:30] GETATTR: /secret.txt (result: 0)
[2025-11-21 05:29:30] WRITE: /secret.txt (result: 12)

# Файл на реальной FS хранится зашифрованным:
$ cat /tmp/source/secret.txt
Uryyb Jbeyq

# Через FUSE читаем расшифрованный текст:
$ cat /mnt/fuse/secret.txt
[2025-11-21 05:30:04] OPEN: /secret.txt (result: 0)
[2025-11-21 05:30:04] READ: /secret.txt (result: 12)
Hello World
```

---

### Задание C: Uppercase Filesystem

#### Реализация

* При `read` данные читаются с диска и преобразуются в верхний регистр (`toupper`) в памяти перед возвратом.
* При `write` данные записываются как есть (файлы на диске сохраняются в оригинальном виде).

#### Команды для запуска

```bash
make
mkdir -p /tmp/source /mnt/fuse
./myfuse /tmp/source /mnt/fuse -f --mode=upper
```

#### Тестирование

```bash
$ echo "hello world" > /tmp/source/test.txt

$ cat /tmp/source/test.txt
hello world

$ cat /mnt/fuse/test.txt
[2025-11-21 05:32:42] OPEN: /test.txt (result: 0)
[2025-11-21 05:32:42] READ: /test.txt (result: 12)
HELLO WORLD
```

## 4. Нагрузочное тестирование

### Общие принципы

Сравниваем две цели: **FUSE** (точка монтирования `FUSE_MNT`) и **ext4** (обычная директория `EXT4_DIR` на ext4).

* Для **latency**-теста (операции с малым объёмом) выполняется много повторений (параметр `iterations`, по умолчанию `LAT_ITER`), результаты усредняются.
* Для **throughput**-теста создаются большие файлы (1MB, 10MB, 100MB), измеряется время записи/чтения и вычисляется MB/s.
* Для **IOPS** создаются/удаляются 1000 мелких файлов (~1KB) и измеряется скорость операций (ops/s).

По результатам скрипт сохраняет CSV `test,fs,value,unit`, который затем анализирует `ascii_graph.py` и строит ASCII-графики.

#### Тест 1: Latency операций

Измеряем время вызова операций (отдельно `open`, `getattr`, `read` 4KB, `write` 4KB) с помощью бенчмарка `run_bench.sh`.

* `open` измеряется через вызов bash-builtin `exec`:

  ```bash
  bash -c 'exec 3<"/path/to/file"; exec 3>&-'
  ```

  В скрипте мы выполняем этот вызов `LAT_ITER` раз в цикле и усредняем значения (сумма / `LAT_ITER`). Такой подход измеряет системный `open` (open + close).

* `getattr` (stat) выполняется с помощью `measure_ms_repeated` для повышения точности:

  ```bash
  avg_ms=$(measure_ms_repeated 100 stat -c "%s" "/path/to/file")
  ```

  Здесь `stat` запускается 100 раз подряд, и функция возвращает среднее время одного вызова `stat` в миллисекундах.

* `read 4KB` и `write 4KB` измеряются как повторы вызова:
  ```bash
  dd if="$file" bs=4096 count=1 of=/dev/null
  dd if=/dev/zero of="$tmp" bs=4096 count=1
  ```

  Усреднение делается суммированием в цикле.

#### Тест 2: Throughput

Последовательное чтение/запись больших файлов (1MB, 10MB, 100MB):

```bash
dd if=/dev/zero of="$out" bs=1M count=$size_mb oflag=direct
dd if="$out" of=/dev/null bs=1M iflag=direct
```

#### Тест 3: IOPS (много маленьких файлов)

Создаём 1000 файлов по 1KB и измеряем время создания/удаления:

```bash
sh -c 'for i in $(seq 1 1000); do echo x > /mnt/fuse/f$i; done'
sh -c 'for i in $(seq 1 1000); do rm /mnt/fuse/f$i; done'
```

### Запись и дальнейшая обработка результатов

* Все тесты сохраняются в CSV: `test,fs,value,unit`.
* Для визуализации запускается `python3 ascii_graph.py results.csv`, который:

  * строит ASCII-бар-графики для каждой пары `ext4` vs `fuse` по тестам;
  * выводит итоговую таблицу `test, ext4, fuse, unit`.
* Примеры команд для запуска полного набора:

```bash
./run_bench.sh /mnt/fuse /tmp/source 500
python3 ascii_graph.py results/results.csv
```

### Результаты

**Latency (мс) — среднее на операцию**

|    Операция |   ext4   |   FUSE   |
| ----------: | -------: | -------: |
|        open | 3.718000 | 4.268000 |
|     getattr | 1.750000 | 1.600000 |
|  read (4KB) | 2.694000 | 3.808000 |
| write (4KB) | 3.056000 | 3.892000 |

**Throughput (MB/s) — последовательное чтение 100MB**

| ФС | Чтение | Запись |
|---:|---:|---:|
| ext4 (1MB) | 250.000 MB/s | 142.857 MB/s |
| FUSE (1MB) | 250.000 MB/s | 142.857 MB/s |
| ext4 (10MB) | 1666.667 MB/s | 714.286 MB/s |
| FUSE (10MB) | 769.231 MB/s | 434.783 MB/s |
| ext4 (100MB) | 3125.0 MB/s | 1538.462 MB/s |
| FUSE (100MB) | 943.396 MB/s | 450.45 MB/s |

**IOPS — создание/удаление 1000 файлов (операций/сек)**

|    ФС |     Создание    |    Удаление   |
| ----: | --------------: | ------------: |
|  ext4 | 15873.016 ops/s | 774.593 ops/s |
|  FUSE |  1050.42 ops/s  |  409.5 ops/s  |

#### ASCII-графики

```
open     | ext4: ▉▉▉▉ 3.718 ms  FUSE: ▉▉▉▉▉ 4.268 ms
getattr  | ext4: ▉▉▉▉▉ 1.75 ms  FUSE: ▉▉▉▉▉ 1.6 ms
read 4K  | ext4: ▉▉▉▉ 2.694 ms  FUSE: ▉▉▉▉▉ 3.808 ms
write4K  | ext4: ▉▉▉▉ 3.056 ms  FUSE: ▉▉▉▉▉ 3.892 ms
throughput_write_1MB | ext4: ▉▉▉▉▉ 142.857 MB/s  FUSE: ▉▉▉▉▉ 142.857 MB/s
throughput_read_1MB | ext4: ▉▉▉▉▉ 250.0 MB/s  FUSE: ▉▉▉▉▉ 250.0 MB/s
throughput_write_10MB | ext4: ▉▉▉▉▉ 714.286 MB/s  FUSE: ▉▉▉ 434.783 MB/s
throughput_read_10MB | ext4: ▉▉▉▉▉ 1666.667 MB/s  FUSE: ▉▉ 769.231 MB/s
throughput_write_100MB | ext4: ▉▉▉▉▉ 1538.462 MB/s  FUSE: ▉ 450.45 MB/s
throughput_read_100MB | ext4: ▉▉▉▉▉ 3125.0 MB/s  FUSE: ▉▉ 943.396 MB/s
iops_create_1k | ext4: ▉▉▉▉▉ 15873.016 ops/s  FUSE: ▉ 1050.42 ops/s
iops_delete_1k | ext4: ▉▉▉▉▉ 774.593 ops/s  FUSE: ▉▉▉ 409.5 ops/s
```

### Интерпретация и выводы по тестам

* **Overhead от FUSE:** наблюдается добавленная задержка порядка 10–40% в зависимости от операции и платформы — это следствие переключений контекста и IPC между ядром и userspace.
* **Мелкие операции:** FUSE хуже работает при большом количестве мелких операций (создание/удаление многих файлов, частые `stat`-ы).
* **Большие последовательные операции:** для больших файлов оверхед присутствует из-за того, что команда `dd` пишет в файл блоками по 1 MB. Для файла в 1 MB, который пишется за один вызов операции записи, задержки практически нет.

## 5. Ответы на контрольные вопросы

### Архитектура файловых систем

1. **Что такое VFS (Virtual File System) и зачем она нужна?**
   VFS — абстрактный уровень в ядре Linux, который предоставляет единый интерфейс работы с разными файловыми системами. Он скрывает различия между конкретными FS, позволяет применять единые syscalls и поддерживает плагины/драйверы файловой системы.

2. **Объясните разницу между inode, dentry и file descriptor.**

   * `inode` — структура, описывающая объект хранения (метаданные файла: размеры, права, указатели на блоки).
   * `dentry` — структура кэша имён (directory entry), связывает имя с inode и ускоряет поиск по пути.
   * `file descriptor` — пользовательский дескриптор открытого файла, представляет открытый экземпляр (позиция, флаги) и связан с `struct file`.

3. **Что хранится в структуре `struct inode`?**
   Метаданные: размер файла, режим (права), UID/GID, временные метки (ctime/mtime/atime), номера блоков или указатели, счётчики ссылок и т.д.

4. **Что такое superblock и какую информацию он содержит?**
   `superblock` — глобальная структура файловой системы, содержит метаданные FS (тип, размер, статус, счётчики свободных блоков, параметры монтирования).

5. **Как работает кеш dentry и зачем он нужен?**
   Dentry cache кэширует соответствия имён и inode, чтобы ускорить поиск по пути (path lookup) и уменьшить количество обращений к диску при частых `open`/`stat`.

### FUSE

6. **Как FUSE взаимодействует с ядром Linux?**
   Модуль FUSE в ядре получает syscalls на том файловом пути, формирует запросы и передаёт их в userspace-процесс через специальный интерфейс (обычно `/dev/fuse` и ioctl/мэппинг), затем получает ответы и возвращает их в VFS.

7. **Опишите путь системного вызова `read()` в FUSE FS.**
   Приложение вызывает `read(fd, ...)` → VFS вызывает соответствующий vnode/file->read -> если файл принадлежит FUSE, ядро формирует запрос и отправляет его в userspace FUSE-процесс → userspace обрабатывает запрос (выполняет чтение реального источника или генерирует данные) и возвращает данные в ядро → ядро передаёт данные в приложение.

8. **Почему FUSE работает медленнее нативных kernel FS?**
   Дополнительные контекст-переключения между ядром и userspace, IPC/копирование данных, синхронизация и более высокая задержка на каждую файловую операцию.

9. **Какие преимущества дает разработка FS в userspace?**
   Упрощённая разработка, безопасность (ошибки userspace не крашнут ядро), быстрый цикл разработки/отладки, возможность реализовать FS без написания кода ядра.

10. **Приведите примеры популярных FUSE файловых систем (sshfs, GCS FUSE, etc.).**
    sshfs, google-drive-ocamlfuse / gcsfuse, ntfs-3g, rclone mount, encfs, unionfs-fuse.

### File operations

11. **Что делает операция `getattr()` и когда она вызывается?**
    Возвращает `stat`-информацию о файле/директории: размер, права, временные метки. Вызывается при `stat`, `ls`, перед другими операциями для проверки атрибутов.

12. **В чем разница между `open()` и `create()`?**
    `open()` открывает существующий файл (проверяет права, флаги), `create()` создаёт новый файл (обычно эквивалент open с O_CREAT) и устанавливает начальные метаданные.

13. **Почему `read()` принимает параметр `offset`?**
    Чтобы можно было читать данные в произвольной позиции файла (несколько параллельных чтений/переходы pos), и для реализации предсказуемого чтения без изменения позиционного указателя в открытом файле.

14. **Как `readdir()` возвращает список файлов?**
    Через callback `filler` (в FUSE): сервер/FS вызывает `filler(buf, name, stat, off, flags)` для каждого имени. В POSIX `readdir` возвращает структуры `dirent`.

15. **Что должна возвращать `getattr()` для директории?**
    Структуру `stat` с типом `S_IFDIR`, корректными правами (rwx для owner/group/other), количеством ссылок и прочими метаданными.

### Метаданные и атрибуты

16. **Что такое атрибуты файла? Приведите примеры.**
    Метаданные: размер, права доступа, UID/GID владельца, временные метки (atime, mtime, ctime), режим, количество ссылок.

17. **Что означают биты прав доступа (rwxrwxrwx)?**
    Owner-group-others: r — чтение, w — запись, x — выполнение. Первый трёхсимвольный блок — права владельца, второй — группы, третий — остальных.

18. **Объясните разницу между mtime, atime и ctime.**

    * `atime` — время последнего доступа (read).
    * `mtime` — время последней модификации содержимого (write).
    * `ctime` — время изменения метаданных inode (permissions, owner, ссылки) — изменение inode.

19. **Что такое hard link и как он отличается от symbolic link?**

    * `hard link` — дополнительное имя, указывающее на тот же inode; не работает между FS; удаление имени уменьшает счётчик ссылок; inode сохраняется пока count>0.
    * `symbolic link` — отдельный файл, содержащий путь к другому объекту; может ссылаться на несуществующие цели; работает междисково.

20. **Как FS определяет размер файла?**
    Размер хранится в inode (поле `i_size`) и отражает количество байт в файле; чтение за пределами возвращает 0 (EOF).

### Физическая организация

21. **Что такое блок в файловой системе?**
    Базовая единица хранения данных (обычно 4KB), на которую выравниваются операции ввода-вывода и выделение пространства.

22. **Объясните принцип непрерывного размещения файлов (contiguous allocation).**
    Файлу выделяется последовательный диапазон блоков на диске — быстрый линейный доступ, но приводит к фрагментации и проблемам с ростом файла.

23. **Как работает организация через связанный список блоков (linked allocation)?**
    Каждый блок содержит указатель на следующий блок. Удобно для динамического роста, но случайный доступ дорог (нужно проходить список).

24. **Что такое индексный узел (inode-based allocation)?**
    Inode содержит указатели на блоки файла (прямые, косвенные, двойные и т.д.), позволяет комбинировать случайный доступ и динамическое выделение.

25. **Сравните ext4 и btrfs по структуре хранения данных.**

    * `ext4` — традиционная inode-ориентированная FS с журналированием (journal), простая и стабильная.
    * `btrfs` — copy-on-write, поддерживает снапшоты, субтома, checksums и более сложные структуры (B-tree), ориентирована на продвинутые возможности (но сложнее).

### Производительность и оптимизация

26. **Почему большие файлы читаются быстрее, чем много мелких?**
    Потому что последовательный доступ использует read-ahead и минимизирует seek; числа системных вызовов и переключений контекста на единицу данных меньше.

27. **Что такое read-ahead и как он улучшает производительность?**
    Read-ahead — предварительная загрузка следующих блоков в page cache при последовательном чтении; уменьшает количество блокирующих I/O операций.

28. **Как page cache ускоряет доступ к файлам?**
    Page cache хранит недавно использованные страницы файлов в памяти, что позволяет обслуживать чтения из RAM без дисковых операций.

29. **Почему запись на SSD быстрее, чем на HDD?**
    SSD не имеет механических задержек (seek/rotational latency), обеспечивает меньшую латентность и лучшие случайные IOPS.

30. **Какие параметры влияют на производительность FUSE FS?**

    * частота системных вызовов (мелкие операции),
    * оверхед IPC/контекст-переключений,
    * реализация userspace-сервера (синхронный/асинхронный), буферизация данных,
    * использование `fi->fh` и кеширования,
    * настройки ядра (page cache, aio), аппаратные характеристики.

## 6. Выводы

* FUSE даёт удобный и безопасный способ разработки файловых систем в userspace.
* Простая реализация passthrough/rot13/upper показала принцип работы: FUSE обрабатывает syscalls, проксирует их в userspace, где можно модифицировать поведение.
* Производительность: FUSE добавляет заметный оверхед на мелких операциях, но для больших последовательных операций этот оверхед существенен меньше.

## 7. Использование AI

В ходе выполнения лабораторной работы использовались инструменты искусственного интеллекта для:

* генерации шаблонов кода и структуры проекта,
* написания шаблона отчёта и README,
* формулировки тестов и методик бенчмаркинга.

AI использовался как вспомогательный инструмент: весь код и тесты проверялись и адаптировались вручную, а окончательное содержание отчёта и выводы — сформулированы с учётом полученных результатов и требований.
